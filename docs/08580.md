# 基于输入的安全漏洞的根本原因——不要害怕语法

> 原文：<https://dev.to/bob5ec/the-root-cause-of-input-based-security-vulnerabilities--dont-fear-the-grammar>

缓冲区溢出、跨站点脚本(XSS)和 XXE 等基于输入的攻击在当今的软件中很常见。它们不会消失。但这是为什么呢？难道不应该假设现有的框架能够正确地处理输入，让开发人员不必一次又一次地为正确实现输入处理而挣扎吗？可悲的是，答案是否定的。

在这篇文章中，我总结了一些关于语言安全的想法，这些想法找到了解决这个问题的一般方法，并提供了一些工具来解决这个问题。

尽管有些人不喜欢类型安全编程语言，但从安全的角度来看，它们对保护软件非常有帮助。类型安全确保程序中的数据具有可以依赖的明确定义的结构。每当数据进入或离开这种类型良好的环境时，基于输入的攻击就会出现。攻击者利用程序对其输入做出的假设，将它驱动到一个不希望的状态。这可能是执行任意代码，或使其产生不需要的输出注入，如 XSS。每个处理输入的程序在使用它之前都必须验证对它的输入所做的所有假设。在输入处理过程中，有两个点需要进行验证。
首先，在读取输入时，解析器需要拒绝所有不符合预期格式的输入。其次，当创建特定格式的输出时，解语法分析器必须确保所有干扰输出格式的输入都被编码。由于输入可能在输出中的不同位置使用，并且根据这个位置需要不同的编码，解析器在读取输入时不能执行编码。
因此，解析器、解解析器和编码是确保软件安全的关键点。

漏洞的历史表明，创建自己的解析器和解解析器就像开发自己的密码一样糟糕。在 [Langsec](http://langsec.org) 中列出了一些侧重于安全性的解析器和解解析器构造工具包。目前 [MCHammerCoder](https://github.com/McHammerCoder) 是使用 [Hammer](https://github.com/UpstandingHackers/hammer) 自动创建解析器和解解析器的首选武器。如果这些工具不支持您喜欢的编程语言，请随意修改它们使用的概念，在 [LangSec 邮件列表](https://mail.langsec.org/list/)上寻求帮助，或者访问 [LangSec 黑客马拉松](http://spw17.langsec.org/hackathon.html)。

将来，每一种编程语言都应该支持简单易用的方法来创建这样的解析器和非解析器，以使开发人员能够创建出即使黑客试图利用它们也能按预期工作的程序。

你们中的一些人仍然对“不要害怕标题中的语法，现在是时候了；我们必须谈论语法。也许你还记得在一些理论计算机科学课上，你听说过上下文无关语法。可悲的是，计算机不是万能的，无法可靠地识别比确定性上下文无关语言更复杂的语言(参见第二页边栏的[网络堆栈不安全的暂停问题](http://langsec.org/papers/Sassaman.pdf))。如果存在于规范中，它们不能“明智地”解决歧义；甚至人类偶尔也会失败。这就是语音识别有时会失败的原因。当考虑安全性时，这种故障会被对手利用。为什么这个理论结果对开发者很重要？因为，**每个读取输入的程序都隐式地为它接受的输入定义了一个语法**。如果这种输入比上下文无关的语言更复杂，总会有攻击者能够利用的边缘情况。这就是为什么没有程序可以绝对确定输入是否属于该语言。

因此，在创建下一个定制格式时，最多使用一个上下文无关的语法来定义它，这样可以确保格式不会变得更加复杂，从而避免固有的漏洞。之前提到的工具就是利用了这个原理。因此，在定义新格式时使用它们，就不需要担心 LangSec 背后的复杂性理论。要开始使用锤子，请尝试使用[锤子底漆](https://github.com/sergeybratus/HammerPrimer)。

如果这是一个过于匆忙的话题，看看目前的 Usenix 登录:文章[治愈易受攻击的解析器:安全输入处理的设计模式](https://www.usenix.org/publications/login/spring2017/bratus)以及在 [Langsec](http://langsec.org) 上的所有论文和演讲。