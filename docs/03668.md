# 隐藏复杂性不会让它消失，是吗？

> 原文:[https://dev . to/fros nerd/hiding-complexity-do-it-do-it-51i](https://dev.to/frosnerd/hiding-complexity-does-not-make-it-go-away-or-does-it-51i)

## [](#why-dont-you-simply-use-an-array)“为什么不干脆用数组呢？”

不久前，我和一个朋友一起开发了一个基于浏览器的聊天应用程序。我们希望拥有的功能之一是用户在加入聊天室时可以选择一个预定义的头像。他应该能够通过点击当前头像的图片来循环显示可用的头像，直到他找到他喜欢的那个。

我负责前端部分(用 [Elm](http://elm-lang.org/) 编写)，思考如何实现这个功能。我需要的是一个存储头像的数据结构，一个知道当前选中的头像的方法，以及一个移动到下一个头像的方法。我应该使用哪种数据结构？

我决定去做一个[循环链表](http://www.geeksforgeeks.org/circular-linked-list/)。我需要一个函数来创建包含可用头像的新循环列表，一个函数来获取当前选择的头像，一个函数来循环到一个新的头像。这些是我最后得到的签名:

```
type CircularList a

fromList : a -> List a -> CircularList a

get : CircularList a -> a

next : CircularList a -> CircularList a 
```

视图现在可以像这样呈现头像:

```
img
    [ src ( CircularList.get model.avatar )
    , onClick RotateAvatar
    ]
    [] 
```

实现用于旋转的点击处理程序很简单:

```
RotateAvatar ->
    ( { model | avatar = CircularList.next <| model.avatar }
    , Cmd.none
    ) 
```

当我的朋友检查代码时，他问我“你为什么不简单地使用一个数组？”。我问他如何用数组实现它。他回答说他会保存头像和当前选中头像的索引。如果用户点击，他将增加索引。如果索引超过数组，他将从头开始。

虽然这是一个完全可行的解决方案，但我认为它不是最简单的。有一种特殊的情况，你必须解决，使它更难理解，并给你搞砸的可能性，得到一个超出索引界限的异常。使用循环列表正是你所需要的。API 很清晰，只提供了这个特性所需的功能。

"但是你可以使用一个数组，只是隐藏你定义的 API 背后的复杂性."，他说。他是对的。当阅读使用循环列表的代码时，您只关心接口，而不关心实现。但是隐藏复杂性就能让它消失吗？我认为在这种情况下，它至少是有帮助的，而且它实际上是面向接口而不是实现的封装和编程的优势:你可以有一个干净简单的接口，在它后面是一个高效但可能不那么简单的实现。

在我们看更多的例子之前(这次会更短，不要担心)，让我快速地解释一下我所说的复杂性是什么意思。

## [](#simplicity-vs-complexity)简单与复杂

在引言中，我谈了很多关于复杂性的内容。但这到底意味着什么呢？为什么方案 A 比方案 B 更复杂？让我们定义简单和复杂:

**简单**，来自拉丁语 *simplus* ，最初指由一种成分制成的药物。如果某样东西不是复合的，不是交织的，那么它就是简单的。

**Complex** ，源自拉丁语 *complexus* ，最初指一组相关元素。如果一个事物由许多不同的、相互联系的部分组成，那么它就是复杂的。

作为开发人员，我们的目标应该是编写简单的代码。简单的解决方案更容易维护，更不容易出错，也更容易理解。现在你可能会说理解循环链表并不容易，但是每个人都知道数组是什么。这怎么可能是更好的选择呢？

我再给你举个例子。让我们来看看平板电脑。好用吗？是的。简单吗？我表示怀疑。如果里面有什么东西坏了，我就不能修理它了。把它比作一支铅笔。好用吗？是的。简单吗？是的。你可以向每个人解释铅笔是如何工作的。即使你以前从未见过铅笔，在使用一会儿后，你很可能能够削尖它。

容易和简单这两个词经常互换使用。容易和困难，简单和复杂的区别在于，前两者是主观的，后两者是客观的。有一个非常好的关于这个话题的演讲来自 [Rich Hickey](https://www.infoq.com/presentations/Simple-Made-Easy) 。强烈推荐观看。

既然术语主题已经结束，让我们来看几个其他的例子。

## [](#hidden-complexity-good-or-bad)隐藏的复杂性——好还是坏？

### [](#example-1-writing-to-a-file)例 1:写入文件

将给定字符串写入文件的函数，具有以下签名:`def writeToFile(content: String, file: File): Unit`。从这个方法来看，写入文件似乎相当简单。但是，如果您没有写入该文件所需的权限，会发生什么情况呢？或者文件系统是否繁忙？或者路径不存在。

编写文件很复杂，但是 API 隐藏了这种复杂性。它使 API 易于使用吗？是的。但这并没有让复杂性消失。如果出了问题，就会有例外。这没有编码在返回类型中，留给开发人员去考虑，或者让未处理的异常使程序崩溃。

一种更明确的方法是返回一些指示文件是否已被写入的信息，或者，如果不工作，返回错误是什么。`Either`可以是很好的候选，也可以是可选的错误。

### [](#example-2-null-values)例 2:空值

许多编程语言都支持`null`值。在我看来，任何返回特定类型的方法也可以返回`null`的事实，给每个方法的*增加了额外的复杂性。如果你想对你的程序进行推理，你总是要考虑一个不知从哪里冒出来的野生`null`。*

如果你有一个可能不返回任何东西的方法，例如，因为参数无效，那么返回`null`对查看 API 的人隐藏了复杂性。你可能会想“谁会把一个负整数传递给我的平方根函数？”。相反，如果你的方法可能什么都不返回，那么使用合适的数据类型，比如`Option`(也叫`Maybe`)或者甚至是复数，使它显式。这样，复杂性(在复数的情况下)是可见的，并且可以被解决。

### [](#example-3-sending-a-message-over-the-network)例 3:通过网络发送消息

让我们假设您想通过网络发送一条消息。可以使用 [UDP](https://en.wikipedia.org/wiki/User_Datagram_Protocol) ，一个非常简单的协议。它是无状态的，开销很低。然而，它没有错误恢复机制:*开火然后忘记*。

在上面的两个例子中，我们可以通过假设没有出错来隐藏复杂性。如果出了什么问题，我们也不会注意到。但是，我们也可以使用不同的协议: [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) 。API 看起来相似或相同，情况的复杂性保持不变，但 TCP 协议为我们处理了部分复杂性。如果数据包无法正确传递，它将自动重新发送。

这个例子与前两个有什么不同？为什么我声称在前两个例子中隐藏复杂性是坏事，而在第三个例子中隐藏复杂性是好事？

### [](#hiding-complexity-the-right-way)隐藏复杂性的正确方法

在我看来，隐藏复杂性有两种类型:

1.  把复杂性藏在地毯下(坏方法)
2.  通过将复杂性从实际问题中分离出来，在其他地方处理它(好方法)来隐藏复杂性

很多编码指南都推荐[显式编码](http://docs.python-guide.org/en/latest/writing/style/#explicit-code)。在我看来，明确性还包括明确未处理的复杂性，而不是对用户隐藏。虽然它看起来很烦人，但它可能会保护你免受那些会让你的公司损失很多钱的讨厌的、隐藏的错误。

## [](#reducing-complexity-gt-hiding-complexity)降低复杂度>隐藏复杂度

在我们讨论了很多隐藏的复杂性之后，我想说还有比隐藏它更好的东西:避免它。

当看最初的例子时，我更喜欢使用循环链表实现而不是数组+索引实现，即使它们都在同一个 API 后面。下面是`CircularList`的类型定义以及`get`和`next`方法的实现:

```
type CircularList a
    = CircularList a (() -> CircularList a)

get : CircularList a -> a
get (CircularList a n) =
    a

next : CircularList a -> CircularList a
next (CircularList a n) =
    n () 
```

验证实现做了它应该做的事情是非常简单的。即使在给定类型签名的情况下实现它是如此简单，我也不知道如何以不同的方式实现它。

想象一下会有一个数组。首先，为了实现`get`，除了实际数组之外，您还必须存储一个索引。第二，next 必须根据新的索引是否会超出范围来进行分支。

在其他场景中，您可能能够避免复杂性。如果我的消息丢失了，真的会有问题吗？对于 VOIP 电话来说，丢失一两个数据包不会影响整体质量，所以这并不重要。因此您可以安全地使用 UDP 并避免复杂性。你真的需要使用一个高度优化的排序算法来排序你的 100 个购物车物品列表吗？在我看来，对于大多数正在编写的软件来说，代码质量、可维护性和可理解性比从实现中挤出最后一毫秒要重要得多。

## [](#final-thoughts)最后的想法

虽然简单和复杂是客观标准，但判断一件事是容易还是困难却不是。然而，选择一个简单的解决方案将会增加这样的可能性:无论是谁在看它，都会很容易理解它。

解决问题时，我喜欢遵循一些有用的提示:

*   当实现某个东西时，从满足需求的最简单的解决方案开始。过早的优化是万恶之源(不完全是万恶之源，但你明白这一点)。
*   在你开始编码之前，试着向其他人解释解决方案。甚至可能选择不熟悉问题领域的人。
*   写一个`if`语句处理一个特殊案例的时候，想想这个案例为什么特殊。也许有一种不同的数据结构或算法不需要您处理这种情况。使用它，即使它可能没有你想象的那么快。
*   明确什么会出错。
*   向你的同事展示你的代码，看看他们是否能理解，而不需要你向他们解释。
*   分开关注。如果有需要处理的复杂问题，但它与你当前的问题无关，试着把它转移到其他地方。例如，将计算与 I/O 分开，将错误处理与业务逻辑分开，等等。

## [](#the-end)结束

现在我很好奇你们会说些什么。你同意循环列表解决方案更简单吗？你有没有遇到过这样的情况，你以一种复杂的方式实现了某个东西，后来又把它简化了？你有没有这样的故事，隐藏的复杂性导致了一个本可以避免的错误？请在评论中告诉我你的想法！