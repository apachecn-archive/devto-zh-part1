# 编程会自动化吗？(闲聊和评论)

> 原文：<https://dev.to/tra/will-programming-be-automated-a-slack-chat>

[软件开发者担心自己会被人工智能取代(2016 年 3 月 8 日新闻稿)](https://evansdata.com/press/viewRelease.php?pressID=231):

> 埃文斯数据公司(Evans Data Corp .)将于本周发布的一项针对 550 多名软件开发人员的新调查显示，开发人员担心他们自己会被人工智能淘汰。当被要求找出他们职业生涯中最令人担忧的事情时，最多的人(29.1%)表示，“我和我的开发工作被人工智能取代了。”这明显比平台问题更令人担忧，例如他们的目标平台过时，这是第二大担忧，占 23%，或者他们的目标平台不流行(14%)。
> 
> 由于人工智能而过时的想法也比没有养老金变老、被糟糕的管理扼杀在工作中，或者看到他们的技能和工具变得无关紧要更具威胁性。虽然担心人工智能的开发人员遍布各个行业和平台，但一个强有力的相关性是，他们更有可能自我认同为孤独者，而不是团队成员。

* * *

Dev Bootcamp 是一个为期 19 周的加速编码项目，旨在教人们如何成为 web 开发人员。这个项目的毕业生会被邀请参加一个“校友聚会”，在那里他们可以和其他校友谈论他们未来的编程职业。(披露:我已经从这个项目毕业了，被邀请参加这个聊天。)

2017 年 2 月 1 日，一场关于软件开发自动化未来的讨论在“校友松弛”中展开..是由一次单独谈话中的一句随口评论引发的。在得到参与这次讨论的人的允许后，我稍微编辑了下面的文字记录。为了保护参与讨论的人的身份，他们的名字已经被改变了。

> daphney . cron in--“如今，编程是一种商品，所以，虽然你确实需要胜任，但能赢得这份工作的是你与面试官相处的能力，以及你成为团队一员、为产品做出贡献的真诚愿望。”
> 
> 这句话让我对当前职业的未来感到担忧。当然，这是真的，但是技能组合的商品化最终会导致这些技能组合的自动化。
> 
> 我认为开发的自动化还很遥远。一个[所见即所得](https://en.wikipedia.org/wiki/WYSIWYG)编辑器能做的事情就这么多，而且代码不太容易维护。我在编程中看到的主要挑战不是编写代码，而是编写人类可读的代码，因为计算机是愚蠢的，人工智能还没有发展到足以像人类一样调试的程度。
> 
> 所见即所得是一个“例如”的 BTW。
> 
> 我不知道，我认为让计算机驾驶汽车比让它写代码要难得多。
> 
> 我不同意。让一台计算机驾驶一辆汽车是一系列具体的决定，而编写代码是一系列背后有观点的决定
> 
> *skittles_mcbangbang* -我看到“无服务器基础设施”之类的东西已经有了先兆。看看 [aws lambda](https://aws.amazon.com/lambda/?hp=tile&so-exp=below) ，你把代码放在网页上，它给你一个点击的端点。
> 
> 要不了多久，就会有人编写某种适配器，将业务逻辑和书面文本转化为行为。我的意思是，我们已经有了测试框架来做这件事。
> 
> Adaline _ stracke——不过没关系。因为它需要知道如何创建业务逻辑的人。我可以很容易地学会一种新的语法，但编程不是这样。
> 
> 其实那不就是 [Ruby](https://github.com/ruby/ruby) 吗？我们用 Ruby 写逻辑，它编译成 c。
> 
> 是的，更高级的语言抽象已经是半自动代码了。最终都变成了机器码。没有理由相信这种趋势不会继续。
> 
> 非程序员也有逻辑能力，有人可能会说他们对预期产品应该是什么样子有更好的理解。如果你在他们写一个英语句子和看到应用程序行为改变之间提供足够快的反馈循环...
> 
> 是的，这可以说比你正常的开发管道要好。超快速开发和测试。
> 
> 我想我想说的是，从我们现在这样写代码到完全的自然语言处理和翻译成行为，这是一个巨大的飞跃。
> 
> 这是个大问题，但我不认为它像许多人认为的那样难以克服。
> 
> adaline_stracke -同意。
> 
> *skittles _ mcbangbang*——同意。我们可能也不需要自然语言处理。训练人们用特定的结构写英语并不难。这只是工作培训的一部分。
> 
> [https://github.com/cucumber/cucumber/wiki/Gherkin](https://github.com/cucumber/cucumber/wiki/Gherkin)T2】

```
 1: Feature: Some terse yet descriptive text of what is desired
 2:   Textual description of the business value of this feature
 3:   Business rules that govern the scope of the feature
 4:   Any additional information that will make the feature easier to understand
 5:
 6:   Scenario: Some determinable business situation
 7:     Given some precondition
 8:       And some other precondition
 9:     When some action by the actor
10:       And some other action
11:       And yet another action
12:     Then some testable outcome is achieved
13:       And something else we can check happens too 
```

Enter fullscreen mode Exit fullscreen mode

> 在我工作的地方，我们尝试过做类似的测试，但并不成功。
> 
> 我想我看不出教某人用一种结构(像编程语言)表达逻辑和用另一种结构(像你贴在那里的东西)表达逻辑有什么不同。从根本上来说，这归结为具体的训练，这就是上面谈到的。
> 
> *skittles_mcbangbang* -在 IME 的微服务 envs 中非常有用。通过简单地陈述运行实际测试所需的先决条件，这是抽象几个不同调用的简单方法。
> 
> 不同之处在于，另一个人(没有受过如何以那种正式的方式表达逻辑的训练)可以阅读说明书，并准确理解正在发生的事情。
> 
> Adaline _ stracke-@ daphney . cron in，我明白可读性的概念，但我们刚才谈论的是编写代码的自动化。
> 
> 是的，这种类型的方法确实无助于代码自动化(因为你是在用另一种类型的形式化替换一种类型的形式化)。想要自动化代码的公司最好尝试改进代码生成器(比如 T2 的 Rails T3)或 CMSes(比如 T4 的 Rails admin T5、T6、active admin T7 或 T8 的 Wordpress T9)...
> 
> 尽管这并没有消除对开发的需求，因为在使用这些框架时，你仍然需要创建和维护服务器。如果你能在 Lambda 或 [OpenWhisk](https://github.com/openwhisk/openwhisk) 中输入 gherkin，那么你就离取代开发者越来越近了。
> 
> 我认为这才是真正的难点。在 AI 像人类一样擅长调试和维护之前，仍然会有对 dev 的需求。
> 
> 我认为这和自我复制机器人的想法是一样的。在机器人能够自我修复和重建之前，我们需要人来维护它们。在软件好到可以自我修复和编写之前，我们仍然需要人来修复和编写软件。
> 
> 毫无疑问，但是仍然有可能用上面的场景替换很多开发者。你仍然需要人来建造和维护那些类型的基础设施，但是我们需要的人越来越少了。

* * *

评论——计算机科学家*已经*对错误修复的自动化进行了研究——目前最有希望的程序是 [GenProg](http://dijkstra.cs.virginia.edu/genprog/) ，这是一个使用遗传编程来改变现有代码库以修复错误的程序。根据[对其开发者](http://ubiquity.acm.org/article.cfm?id=2746519)的采访，GenProg 非常便宜(8 美元/小时)而且速度很快，但是计算机生成的代码不像人类生成的代码那样可维护。GenProg 也严重依赖于规范来确定它是否已经修复了漏洞，因此使用 GenProg 的软件工程师将从编写代码转向编写测试。业务逻辑的“形式化”仍然由人来完成。

讨论假设对软件的需求将保持不变。这可能不是真的——相反，软件越来越需要变得更复杂，处理更多的东西。这导致了基于托格通勤定律的[复杂性悖论](http://www.asktog.com/columns/011complexity.html):

> “上下班的时间是固定的。只有距离是可变的。”翻译？无论采取什么措施来降低复杂性，人们都会努力在生活中体验同等或不断增加的复杂性。让道路变得更快，人们总是会离得更远。
> 
> ...鉴于人们将继续希望他们生活中的复杂性保持不变，鉴于我们将继续降低我们向用户展示的任何给定功能的复杂性比例，我们可以预计我们自己的任务的难度和复杂性，无论是在应用程序还是操作系统级别，都只会随着时间的推移而增加。到目前为止，情况确实如此——我们已经从简单的备忘录写手和画板发展到文档处理器和 PhotoShop。我们可以假设这只是开始。

因此，当我们构建高级语言、代码生成器和 CMSes 时，我们只是鼓励这些工具的用户用这些工具做更多的“工作”。这增加了最终软件的复杂性，需要更多的维护工作。软件不断被要求改变和升级，领域必须跟上需求。

这似乎表明程序员会有很高的工作保障(Tog 会在他文章的结尾做同样的断言)。然而，所有自动化的目标都是节约成本和提高效率。当你解雇程序员，用更便宜的“规范编写者”取代他们时，会节省成本。随着软件变得越来越复杂和费解，我们可能会更少地依赖非常容易出错的人，而更多地依赖不太容易出错的机器。

因此，可以肯定地说，在相当长的一段时间内，许多开发人员仍然会害怕自动化/人工智能，因此这场辩论仍将继续下去...