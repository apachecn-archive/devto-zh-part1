# 用你的数据库！(第 3 部分)-创建修订系统

> 原文：<https://dev.to/livioribeiro/use-your-database-part-3---creating-a-revision-system-20j7>

如果你曾经使用过 [Hibernate](http://hibernate.org/) ，你可能也使用过 [Hibernate Envers](http://hibernate.org/orm/envers/) ，一个审计和版本控制框架。它基本上存储了对数据库中记录的修改，并提供了一个 API 来管理修改。

但是为什么不仅仅使用数据库来做同样的事情呢？我们可以使用数据库函数和触发器来构建自己的修订系统。

首先，让我们创建两个表(我将使用 Postgres 10):

```
CREATE TABLE tasklist (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE task (
    tasklist_id INTEGER NOT NULL,
    task_number INTEGER NOT NULL,
    name VARCHAR(100) NOT NULL,
    done BOOLEAN DEFAULT FALSE,

    PRIMARY KEY (tasklist_id, task_number),
    FOREIGN KEY (tasklist_id) REFERENCES tasklist (id)
);

CREATE OR REPLACE FUNCTION generate_task_number() RETURNS TRIGGER AS $$
BEGIN
    SELECT coalesce(max(task_number), 0) + 1 INTO NEW.task_number
    FROM task
    WHERE task.tasklist_id = NEW.tasklist_id;

    RETURN NEW;
END
$$ LANGUAGE plpgsql;

CREATE TRIGGER generate_task_number
    BEFORE INSERT ON task
    FOR EACH ROW
    EXECUTE PROCEDURE generate_task_number(); 
```

Enter fullscreen mode Exit fullscreen mode

这里我们有`tasklist`和`task`表格。`tasklist`主键是`GENERATED BY DEFAULT AS IDENTITY`，这是[新的 Postgres 10](https://www.postgresql.org/docs/10/static/sql-createtable.html) ，工作原理与使用串行列相同。

`task`上的主键是一个组合键:它由任务所属的任务列表的主键和一个依赖于任务列表 id 的序列号组成，所以我们使用一个触发器来生成任务号。

为了存储修订，我们需要为每个要版本化的表创建一个修订表。修订表必须有修订号、操作代码(插入、更新或删除)和创建时间戳。修订表的主键将是修订号与原始表的主键的组合。

为了避免为我们需要创建的所有修订表重复这些列，我们可以创建一个临时表，并告诉其他表从其中复制所有的列:

```
-- Base for revision table to avoid repetition
CREATE TEMPORARY TABLE IF NOT EXISTS base_rev (
    rev_number INTEGER NOT NULL,
    rev_operation CHAR(1) NOT NULL CHECK (rev_operation IN ('I', 'U', 'D')),
    rev_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
); 
```

Enter fullscreen mode Exit fullscreen mode

现在我们可以创建如下的其他修订表:

```
-- Revision table for tasklist
CREATE TABLE rev_tasklist (
    LIKE base_rev INCLUDING CONSTRAINTS,
    LIKE tasklist,

    PRIMARY KEY (rev_number, id)
);

-- Revision table for task
CREATE TABLE rev_task (
    LIKE base_rev INCLUDING CONSTRAINTS,
    LIKE task,

    PRIMARY KEY (rev_number, tasklist_id, task_number)
); 
```

Enter fullscreen mode Exit fullscreen mode

`CREATE TABLE`语句中的`LIKE`子句将把表中的列复制到正在创建的表中。你可以在创建表格文档中了解更多[。](https://www.postgresql.org/docs/10/static/sql-createtable.html)

有了所有的表格，我们可以创建一个触发函数来插入修订:

```
CREATE OR REPLACE FUNCTION insert_revision() RETURNS TRIGGER AS $$
DECLARE
    -- operation that triggered this revision, (I)nsert, (U)update, (D)elete
    _op CHAR(1);
    -- current record
    _record RECORD;
    -- current revision number
    _rev_number INTEGER;
    -- revision table name ('rev_' + table name)
    _rev_table VARCHAR := 'rev_' || TG_TABLE_NAME;
BEGIN
    -- Which operation are we dealing with?
    IF TG_OP = 'INSERT' THEN
        _op := 'I';
        _record := NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        _op := 'U';
        _record := NEW;
    ELSE
        _op := 'D';
        _record := OLD;
    END IF;

    -- Retrieve next revision number
    EXECUTE format('SELECT coalesce(max(rev_number), 0) + 1 FROM %s rev_table WHERE rev_table.id = $1', _rev_table)
        INTO _rev_number
        USING _record.id;

    -- Insert revision
    EXECUTE format('INSERT INTO %s VALUES ($1, $2, $3, $4.*)', _rev_table)
        USING _rev_number, _op, now(), _record;

    RETURN _record;
END;
$$ LANGUAGE plpgsql; 
```

Enter fullscreen mode Exit fullscreen mode

上面的函数将为一个表插入一个修订，唯一的要求是这个表有一个名为`id`的主键。

我们使用 [`EXECUTE`](https://www.postgresql.org/docs/10/static/plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN) 是因为我们需要动态执行一条 SQL 语句，因为该函数旨在对满足主键要求的任何表进行操作。

现在我们可以为`tasklist`表创建触发器:

```
CREATE TRIGGER tasklist_revision AFTER INSERT OR UPDATE OR DELETE ON tasklist
    FOR EACH ROW EXECUTE PROCEDURE insert_revision(); 
```

Enter fullscreen mode Exit fullscreen mode

这对`tasklist`有效，但是`task`有一个复合主键，我们需要以某种方式告诉触发器函数。我们可以通过向触发器传递参数并更改触发器函数来使用它们，如果没有传递参数，则假设只有一个主键列`id` :

```
CREATE OR REPLACE FUNCTION insert_revision() RETURNS TRIGGER AS $$
DECLARE
    -- operation that triggered this revision, (I)nsert, (U)update, (D)elete
    _op CHAR(1);
    -- current record
    _record RECORD;
    -- current revision number
    _rev_number INTEGER;
    -- revision table name ('rev_' + table name)
    _rev_table VARCHAR := 'rev_' || TG_TABLE_NAME;
    -- where clause for composite primary key
    _where VARCHAR := '';
    -- variable used to iterate over the TG_ARGV
    _pk VARCHAR;
BEGIN
    -- Which operation are we dealing with?
    IF TG_OP = 'INSERT' THEN
        _op := 'I';
        _record := NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        _op := 'U';
        _record := NEW;
    ELSE
        _op := 'D';
        _record := OLD;
    END IF;

    -- no parameters, assume primary key = id
    IF TG_NARGS = 0 THEN
        _where := '_rev_table.id = $1.id';
    -- process primary key from TG_ARGV
    ELSE
        _where := format('_rev_table.%1$s = $1.%1$s', TG_ARGV[0]);
        FOREACH _pk IN ARRAY TG_ARGV[1:] LOOP
            _where := _where || format(' AND _rev_table.%1$s = $1.%1$s', _pk);
        END LOOP;
    END IF;

    -- Retrieve next revision number
    EXECUTE format('SELECT coalesce(max(rev_number), 0) FROM %s _rev_table WHERE %s', _rev_table, _where)
        INTO _rev_number
        USING _record;

    -- Insert revision
    EXECUTE format('INSERT INTO %s VALUES ($1, $2, $3, $4.*)', _rev_table)
        USING _rev_number + 1, _op, now(), _record;

    RETURN _record;
END;
$$ LANGUAGE plpgsql; 
```

Enter fullscreen mode Exit fullscreen mode

原始函数和更新后的函数的区别如下:

```
-- no parameters, assume primary key = id
IF TG_NARGS = 0 THEN
    _where := '_rev_table.id = $1.id';
-- process primary key from TG_ARGV
ELSE
    _where := format('_rev_table.%1$s = $1.%1$s', TG_ARGV[0]);
    FOREACH _pk IN ARRAY TG_ARGV[1:] LOOP
        _where := _where || format(' AND _rev_table.%1$s = $1.%1$s', _pk);
    END LOOP;
END IF; 
```

Enter fullscreen mode Exit fullscreen mode

这段代码将检查是否有任何参数传递给触发器，并将它们用作构成主键的列(或者主键是否不是`id`)。

最后触发`task` :

```
CREATE TRIGGER task_revision AFTER INSERT OR UPDATE OR DELETE ON task
    FOR EACH ROW EXECUTE PROCEDURE insert_revision('tasklist_id', 'task_number'); 
```

Enter fullscreen mode Exit fullscreen mode

当我们创建触发器时，我们传递`'tasklist_id'`和`'task_number'`作为它的参数，它们是组成`task`表的主键的列。

如果你想知道这些`TG_NARGS`、`TG_ARGV`和`TG_TABLE_NAME`是从哪里来的，这些是 Postgres 在触发函数执行时自动创建的变量[。](https://www.postgresql.org/docs/10/static/plpgsql-trigger.html)

如果您计划在生产中使用这些代码，请随时回到这里并评论您的体验(并且记住在部署之前测试所有内容)。

最后，完整的例子如下所示:

```
CREATE TABLE tasklist (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE task (
    tasklist_id INTEGER NOT NULL,
    task_number INTEGER NOT NULL,
    name VARCHAR(100) NOT NULL,
    done BOOLEAN DEFAULT FALSE,

    PRIMARY KEY (tasklist_id, task_number),
    FOREIGN KEY (tasklist_id) REFERENCES tasklist (id)
);

CREATE OR REPLACE FUNCTION generate_task_number() RETURNS TRIGGER AS $$
BEGIN
    SELECT coalesce(max(task_number), 0) + 1 INTO NEW.task_number
    FROM task
    WHERE task.tasklist_id = NEW.tasklist_id;

    RETURN NEW;
END
$$ LANGUAGE plpgsql;

CREATE TRIGGER generate_task_number
    BEFORE INSERT ON task
    FOR EACH ROW
    EXECUTE PROCEDURE generate_task_number();

-- Base for revision table to avoid repetition
CREATE TEMPORARY TABLE IF NOT EXISTS base_rev (
    rev_number INTEGER NOT NULL,
    rev_operation CHAR(1) NOT NULL CHECK (rev_operation IN ('I', 'U', 'D')),
    rev_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Revision table for tasklist
CREATE TABLE rev_tasklist (
    LIKE base_rev INCLUDING CONSTRAINTS,
    LIKE tasklist,

    PRIMARY KEY (rev_number, id)
);

-- Revision table for task
CREATE TABLE rev_task (
    LIKE base_rev INCLUDING CONSTRAINTS,
    LIKE task,

    PRIMARY KEY (rev_number, tasklist_id, task_number)
);

CREATE OR REPLACE FUNCTION insert_revision() RETURNS TRIGGER AS $$
DECLARE
    -- operation that triggered this revision, (I)nsert, (U)update, (D)elete
    _op CHAR(1);
    -- current record
    _record RECORD;
    -- current revision number
    _rev_number INTEGER;
    -- revision table name ('rev_' + table name)
    _rev_table VARCHAR := 'rev_' || TG_TABLE_NAME;
    -- where clause for composite primary key
    _where VARCHAR := '';
    -- variable used to iterate over the TG_ARGV
    _pk VARCHAR;
BEGIN
    -- Which operation are we dealing with?
    IF TG_OP = 'INSERT' THEN
        _op := 'I';
        _record := NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        _op := 'U';
        _record := NEW;
    ELSE
        _op := 'D';
        _record := OLD;
    END IF;

    -- no parameters, assume primary key = id
    IF TG_NARGS = 0 THEN
        _where := '_rev_table.id = $1.id';
    -- process primary key from TG_ARGV
    ELSE
        _where := format('_rev_table.%1$s = $1.%1$s', TG_ARGV[0]);
        FOREACH _pk IN ARRAY TG_ARGV[1:] LOOP
            _where := _where || format(' AND _rev_table.%1$s = $1.%1$s', _pk);
        END LOOP;
    END IF;

    -- Retrieve next revision number
    EXECUTE format('SELECT coalesce(max(rev_number), 0) FROM %s _rev_table WHERE %s', _rev_table, _where)
        INTO _rev_number
        USING _record;

    -- Insert revision
    EXECUTE format('INSERT INTO %s VALUES ($1, $2, $3, $4.*)', _rev_table)
        USING _rev_number + 1, _op, now(), _record;

    RETURN _record;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tasklist_revision AFTER INSERT OR UPDATE OR DELETE ON tasklist
    FOR EACH ROW EXECUTE PROCEDURE insert_revision();

CREATE TRIGGER task_revision AFTER INSERT OR UPDATE OR DELETE ON task
    FOR EACH ROW EXECUTE PROCEDURE insert_revision('tasklist_id', 'task_number'); 
```

Enter fullscreen mode Exit fullscreen mode