# 没有 HTTP 动词的 RESTful

> 原文：<https://dev.to/carywreams/restful-without-http-verbs-2i>

**更新 2**

从下面的评论中，几个非常有趣的资源浮出了水面。这些文章中最具谴责性的是罗伊·菲尔丁(REST 之父)九年前写的一篇关于沼泽的文章。这段引文出现在:

> 在超文本是一种约束的概念上，需要做什么来使 REST 架构风格变得清晰？换句话说，如果应用程序状态的引擎(以及 API)不是由超文本驱动的，那么它就不可能是 RESTful 的，也不可能是 REST API。句号。是不是某个地方有什么坏掉的手册需要修理？

因此，明确地说，除非我们使用 HTTP 直接管理状态——而不仅仅是作为消息传递层——否则我们就不是 RESTful 的。

明白了。

Kasey Speakman 的评论值得称赞，其中包括 Martin Fowler 关于 T2 Richardson 成熟度模型的文章的链接。

也感谢所有那些有建设性意见的人，他们帮助我理清了对 RESTful 架构的理解。虽然我不关心应用程序与用于客户端和服务器之间通信的协议之间的耦合，但很明显，将这些项目解耦违反了 REST 的预期定义。

**何去何从？**

还不确定。我有责任看一看 Fowler 关于 RMM 的文章中提到的“HATEOAS(作为应用程序状态引擎的超文本)”。我需要协调 HTTP 的双重角色，以提供应用程序状态的传输和管理。

**/更新 2**

* * *

> bene 注意:我真的很期待以“关于什么...，“或者“另外，…”因为列举一些额外的考虑是非常有益的。感谢

# 上下文

我们为客户开发和运营一个私人门户网站。该门户允许客户登录、保存信息、许可知识产权，并生成高度定制的、可打印的 pdf 以用于其业务。因此，API 不是开放的，我们不与其他应用程序或服务集成。这种整合的缺乏极大地简化了我们需要做的事情，因为它消除了遵循当前惯例所获得的许多正常好处。也就是说，...

# 拒绝前提

忠实的 RESTful 实现需要使用适当的 HTTP 动词。

# 初始动机

**更新 1**
这种动机不再令人担忧。然而，我还没吃完我找到的骨头。
**/更新 1**

采用这种思路的原因是出于减少服务器日志文件中暴露的信息量的考虑。所以，它开始时更多的是作为一种好奇，而不是一个特定问题的可能解决方案。为此，这本书读起来更像是*大声说出自己的想法*，而不是一份革命宣言。

如果我使用通常和习惯的 RESTful 实现，路径(但自然不是非 GET 有效负载)会出现在服务器日志中。知识的合理应用和在创作或合并的软件中的暴露可能导致违规。

虽然我喜欢搜集服务器日志以获取情报的想法，但实际上我不会这么做。还有其他更智能的方法来获得这种关于使用的洞察力。

**~~因此，信息在没有提供任何价值的情况下暴露出来，以换取可感知的风险。~~T3】**

# TL；速度三角形定位法(dead reckoning)

客户端软件和服务器端软件不需要使用 HTTP 动词来传达意图——只要浏览器和 web 服务器能够通信，这两个部分就可以相互通信。

因此，我们只要求通信是成功的；并要求浏览器和 web 服务器(Apache、iis、nginx 等)提供 comm 链接或关于为什么 comm 链接不可用的信息。那是他们的工作，让他们去做吧。但是不要要求他们承担整个解决方案的责任。

另一种方法是:将特定于解决方案的服务器端响应代码和数据封装在有效负载中。

为此，我们选择简单地使用带有消息头和消息体的 POST 方法来传达当前通过 HTTP 动词传达的意图。我们接受在不介意暴露 RESTful 结构的地方使用 GET 动词(...或者希望允许书签或支持缓存)。

消息头包含两个字段(隐藏输入，如果您愿意的话):

*   request_type:新建|创建|编辑|更新|显示|列表|删除
*   请求路径:/resource/id/resource2/id2/...

邮件正文包含所有常见的疑点。

```
*---------------*
| request_type  |
| request_path  |
+---------------+
| field1        |
| field2        |
| ...           |
| fieldN        |
*---------------* 
```

特定于解决方案的服务器端响应带有响应头和响应体。响应头负责传递请求的状态(取代以前用于此目的的 HTTP 状态代码),而响应体照常包含任何请求的数据。

```
HTTP headers, ...
HTTP_STATUS: 200, 400, 404
data:
*------------------*
| response_status  |
+------------------+
| field1           |
| field2           |
| ...              |
| fieldN           |
*------------------* 
```

我认为这将各种浏览器和 web 服务器从我的客户端代码和服务器端代码中分离出来。我仍然必须使用 POST 和 GET，但是我*只有*必须使用 POST 和 GET。GET 可以是可选的，也很少见，因为我仍然想从服务器日志中删除信息。

## 风险

*   **缓存**将受到使用 POST 的影响，其中 GET 是合法的候选者；接受调查
*   **书签**将受到使用 POST 的影响，其中 GET 是合法候选项；接受调查
*   在 GET 是合法候选项的情况下使用 POST 将违反当前公认的**原则**；将评估权衡

# STL；BIC

(还是太长了；但是我很好奇)

这是一个思维过程，本质上是放射状和分支的，但必须被折磨成一个线性空间，在这里。

## 你有什么好？

我花了几年时间将我们的 web 应用从一个黑客解决方案改造成一个更加 RESTful 的解决方案。我喜欢相对路径地址路径的简单性和七个操作的性质——对我们来说是八个，因为我已经有了一个停车场项目来处理作为一级请求的搜索。

但是在那段时间里，我一直在努力实现 HTTP 动词和 REST。简单地说，HTML 不支持所有动词的使用。前一种方法可能只有 GET 或 POST，人们可能会问为什么支持 GET。但是，不支持 PUT、PATCH 和 DELETE 选项。

除了一些不为人知的考虑，HTML 表单规范允许:

*   method=POST 以创建资源
*   方法=更新资源的补丁
*   method=PUT 以替换资源
*   method=DELETE 删除资源

...但是我们没有。为了克服这个限制，浏览器供应商和 javascript 库必须开始朝着同一个方向前进(别笑了)。我想这是可能的，我希望 HTML 支持一些它从未打算或预期支持的东西——也许补丁|上传|删除操作是为了服务器到服务器的通信？？不确定。但我知道我需要它们。它们不是天生的。克服本土缺失的做法似乎费力不讨好，而且代价高昂。

...即使我们附加了一些 javascript 和一个库来管理 ajax 通信，以将方法更改为适当的动词，...我的 apache 服务器将它作为 POST 请求处理，无论如何数据必须从 PHP::_POST 数组中获取。这意味着我必须从其他信息中推断出 POST|PUT|PATCH|DELETE 操作(除了动词保留在通信开销中的一些情况)。

那么你有什么好处呢？我们费尽周折，只为在服务器上粉碎我的意图。不用了，谢谢。

## HTTP 状态码

找到了这个[资源](http://www.restapitutorial.com/lessons/httpmethods.html)，它很好地捕获了 HTTP 状态代码的使用，以响应 HTTP 动词。然而，绝大多数与应用程序响应有关，而不是 web 服务器对浏览器的通信响应:

| HTTP 动词 | 状态代码 | 应用范围 | Web 服务器范围 |
| --- | --- | --- | --- |
| 发布(创建) | 201 已创建 | 是 | - |
| 邮政 | 404 未找到 | 可能 | 可能 |
| 邮政 | 409 冲突 | 是 | - |
| 获取(读取) | 200(好的) | 是 | - |
| 得到 | Four hundred and four | 可能 | 可能 |
| 上传(更新/替换) | Two hundred | 是 | - |
| 放 | 204(无内容) | 是 | - |
| 放 | Four hundred and four | 可能 | 可能 |
| 放 | 405(不允许的方法) | 是 | - |
| 修补(更新/修改) | Two hundred | 是 | - |
| 修补 | 204(无内容) | 是 | - |
| 修补 | Four hundred and four | 可能 | 可能 |
| 修补 | 405(不允许的方法) | 是 | - |
| 删除(删除) | Two hundred | 是 | - |
| 删除 | Four hundred and four | 可能 | 可能 |
| 删除 | 405(不允许的方法) | 是 | - |

为了避免这种混乱，我宁愿将浏览器和 web 服务器之间的通信集中在 200(正常)、400(错误请求)和 404(未找到)响应上。要么是通信良好，我要求应用程序使用返回的数据继续处理，要么是没有找到端点(404)，我们根据情况处理该响应。

HTTP 状态代码可以为*应用返回代码*提供一些指导，因为我们可能需要一个标准化的响应，其中

| 被盗的 HTTP 状态代码 | 言出必行 |
| --- | --- |
| Two hundred and one | 资源创建成功 |
| Two hundred and four | 没有要显示的内容 |
| Four hundred and four | 错误的资源 id |
| Four hundred and five | 不允许的方法 |
| Four hundred and nine | 资源已经存在(重复？) |
| Four hundred and eighteen | 如果我们让茶壶来煮咖啡 |

但是，**这些是在应用程序响应头中返回的，而不是 HTTP 响应。**

## 客户端麻烦事

这归结为开发或使用支持 AJAX 通信的包所产生的成本，这些通信形式上是正确的，但在 web 服务器将请求传递给服务器端代码时却变成了 POST。在通信开销中，从请求头而不是动词中分支出来可能只是个人偏好。无论哪种方式，检测工作还是要做的。但我觉得处理请求比处理通信标题更好。

## 服务器端的争论

...接下来，将我的动作检测从 comms 头中提取出来，放入请求头中，这样可以将 web 服务器代码与请求代码分离开来。也就是说，我的服务器脚本端点只需要从 web 服务器获取请求头和请求体，并将其提供给服务器端代码。现在，我们可以解释 web 服务器请求，并将其转换为服务器端代码，为什么还要引入那个动作呢？为什么不完全解耦，只在请求头中声明动作，不动声色地从客户端传递到服务器端呢？

## 越界

重温 HTTP 状态代码的全部使用，告诉我在服务器端代码中发生的一些事情(在 web 服务器之外)。正如我不希望服务器端代码使用来自 comm 头(GET|POST)的信息来知道要采取什么动作(NEW | CREATE | EDIT | UPDATE | SHOW | LIST | DELETE)，我也不希望客户端代码根据 comm 响应中的信息采取与应用程序相关的动作。

为什么通信响应应该是超过 200、400、404 的任何值(对于 web 应用程序)？

现在，在事件中，API 将被公开给第三方使用，第三方(历史上)期望来自通信层的与应用程序相关的响应，我明白了。纳入这些答复的传统原因可能是压倒性的。

我还期望这将有模仿/测试的好处，尽管服务器端代码的适当解耦可能已经实现了这一点，但并没有产生更多的好处。

## 亲吻

在服务器端和客户端标准化请求头和请求体意味着只处理一个创建和响应请求的模型。检查。

将 ajax 通信减少到与 GET、POST 和通信链接的通过/失败特性相关的问题，简化了客户机和服务器之间的通信处理。检查。

将响应体实现到响应的*数据*部分会使客户端处理变得复杂。有一点。啊。

## 服务器日志

**更新 1**
~~哦，我没有在服务器日志中暴露我们的任何结构。当路径进入有效载荷而不是 URI 时，该结构被隐藏。十年前，这可能不是一个问题，但我现在开始认为，这应该是一个更大的问题。就像我们在家里玩所有早期物联网玩具一样，我们可能会冒险让我们的资源端点出现在服务器日志中。~~
**/更新 1**

# 感谢

感谢您花时间阅读本文。如果你选择用建设性的批评来回应/评论，那就更感谢了。值得称赞。