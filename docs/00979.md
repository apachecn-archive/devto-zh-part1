# 技术债务的无害增长

> 原文:[https://dev . to/mortoray/innocent-growth-of-technical-debt-op5](https://dev.to/mortoray/innocent-growth-of-technical-debt-op5)

在过去的几天里，我一直在解开《Fuse》中`Each`的神秘。这是一个强大的功能，已经设法积累了相当份额的技术债务。虽然在这种情况下，债务似乎是由未支付的税款引起的，而不是捷径、草率或糟糕的选择。让我们试着在我的记忆中漫步，看看发生了什么。

## `Instantiator`

为了理解代码发生了什么，我们需要简单地看一下特性本身。`Each`将数据应用到我们的[反应式 UX 语言](https://mortoray.com/2017/08/01/what-is-reactive-and-stream-programming/)的一系列模板中。为了给你一个思路，这里有一个粗略的例子，列出了不同类型的卡:

```
<StackPanel>
    <Each Items="{deck}" MatchKey="type">
        <NumberedCard ux:Template="number"/>
        <FaceCard ux:Template="face"/>
        <JokerCard ux:Template="joker"/>
    </Each>
</StackPanel> 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

`Each`将几个[正交特征](https://mortoray.com/2017/03/27/what-is-orthogonality/)包裹在一起。我们添加的每个特性都增加了代码的复杂性。如果我没记错的话，这是我们添加的主要功能的顺序:

*   迭代一组`Items`并实例化模板。集合可以是一个固定的项目数组，也可以是一个反应式数组(数组可以修改，无需重新分配给`Items`)。
*   基于一个`MatchKey`实例化不同的模板。还有一个很难解释的模板起源特性，它有助于构建组件。
*   在没有数据源的情况下复制项目的`Count`属性。
*   一个单独的`Instance`类，它只实例化一个项目，基本上是使用`Count=1`的捷径。至此基础类`Instantiator`诞生了。
*   数据开窗:只显示在`Offset`和`Limit`范围内的项目。
*   延迟创建项，防止单个框架中的 UI 线程过载。
*   重新使用项目，避免在窗口移动或在一帧中添加/删除项目时需要重新创建实例
*   一种标识功能，用于跟踪逻辑上等同的项目，即使对象本身不同

## [](#growing-complexity)日益复杂

当我们引入`Instance`类时，我们重构了`Each`来使用一个共享的`Instantiator`基类。基类正在成为一个具有多种用途的灵活特性。通过添加一些属性，我们可以使它成为名副其实的主力。

当我添加了`Offset`和`Limit`功能后不久，麻烦就来了:这是高效滚动区域的一个基本元素。不是实例化列表中的所有项目，而是将列表限制为当前可见的项目。

> 为了完成这项工作，还需要`ScrollView`中的各种特性。在这一点上，它仍然有点不稳定，尽管可以用一些 JavaScript 来实现。我正在开发一个影响设计的并行特性，但是它直到很久以后才以`ScrollViewPager`的名字出现。

我添加了延迟创建特性，代码的混乱特性真的让我震惊。我很难理解所有这些部分是如何协同工作的。这并不是因为我们以前做错了什么，或者走了什么捷径。我当时还不确定一个好的结构应该是什么样的。代码肯定很糟糕，但我不知道我能做些什么。

我感觉到逻辑上存在的分组，并使用`partial class`将代码分成多个文件。虽然它使一些任务变得更加困难，但它有助于理解逻辑架构。

当我添加重用和身份特性时，我意识到我可能是唯一一个理解这个`Instantiator`类在做什么的人。更糟糕的是，我很难理解它。

> 为了更好地理解这个问题，请理解所有这些特性都是动态的，我们的用户没有编写静态列表。当我们仍在等待先前节点的延迟创建时，项目列表可能会改变，而且确实会改变。该窗口可以在数据上来回滑动，包括回到仍在等待移除的项目(移除可以是动画)。同时，个别项目可能会更新，可能需要新的模板。

## [](#breaking-point)断点

我想给`Instance`添加一个简单的特性。它无法在它所创建的项目上设置数据上下文:本质上它相当于一个`<Each Count="1">`而不是一个`<Each Items="{ array-of-one }"/>`。后者更加灵活，对我们新的数据模型系统有帮助。

这应该是一个简单的加法。所有的代码都在那里；我会在`Instance`上公开一个`Item`属性，并将其重写为一个数组。我做到了，这很有效，但并不完全有效。我还使用了模板匹配特性`MatchKey`，如果我更改了源数据，它不会选择新的模板。

我一开始并不担心，以为是`Instantiator`的小缺陷。我花了几个小时才找到问题所在。这不是一个错误，而是一个限制。我甚至找到了我写的解释它不能工作的文件。这是所涉及的架构的一个基本问题:根本没有办法让它工作！

> 我记得很久以前就发现了这个限制。没有人故意写它，但只是碰巧有一个正交的功能组合，没有完全一起工作。这显然不会出现在我们的用户代码中，因为没有人报告过，也没有人抱怨过(据我所知)。但是，唉，我的快速新功能需要它工作。

## [](#a-questionable-decision)有问题的决定

概括地说，到目前为止，我并不认为我们构建的代码是错误的。我之前重构过结构，清理过，还添加了很多测试用例。这是一个不幸的复杂性，但没有人主动创造它。相反，累积的债务来自熵税。

除了现在。我没有去面对这个令人费解的巨人，而是找到了实现我的新特性的捷径。我所需要的就是从`Each`中提取一点代码，并在`Instance`中重新实现它。是的，请排队使用`U+1F631`表情符号。我本质上是复制粘贴，而不是修复问题！😱

我对自己不满意。

我决心解决这个问题。但是首先，作为补偿，我重构并删除了表达式系统中的大约 600 行代码。然后我就回到了`Instantiator`。

我走进了厚厚的代码云，只知道如何修复它。经过大约 50 次提交，我一点一点地把它分成三个类，接口清晰，职责分明。主类仍然有大约 900 行代码，但其中大约一半是用户 API 文档——大约 400 行功能代码是合理的，即使仍然有点不清楚。

## [](#the-tax)税收

技术债务的常见原因通常是糟糕的实践:我们未能做的事情的列表，我们没有考虑的事情，或者草率和懒惰。虽然我确实认为这些是常见的原因，但我不认为它适用于这种情况。

你可以通过适当的预见和关注进行正确的编码，但随着时间的推移，你仍然会背负技术债务。即使是一个完美的程序员，或者独角兽，也无法避免支付技术税所需的不断重构。

* * *

> 我在 [Fuse](http://fusetools.com/) 上的工作充满了有趣的编码。[在 Twitter 上关注我](https://twitter.com/edaqa)或[观看我的视频](https://www.twitch.tv/mortoray)以获得更多用户界面和算法的乐趣。