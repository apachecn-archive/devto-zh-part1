# 干燥的谬误

> 原文:[https://dev.to/jeroendedauw/the-fallacy-of-dry](https://dev.to/jeroendedauw/the-fallacy-of-dry)

*最初发表在我的[博客上的](https://www.entropywins.wtf/blog/)为[干](https://www.entropywins.wtf/blog/2017/09/06/the-fallacy-of-dry/)的谬论。*

干，代表[不要重复自己](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)，是软件开发界众所周知的设计原则。

通过诸如“重复是万恶之源”之类的咒语，消除重复占据中心位置并不罕见。然而，虽然重复往往是不好的，但对干燥的良好追求往往会使人误入歧途。要了解原因，让我们后退一步，看看我们通过消除重复想要实现什么。

## [](#the-goal-of-software)软件的目标

首先，软件的存在是为了实现一个目的。你的客户，可能是你的雇主，付钱是因为他们希望软件提供价值。作为开发人员，尽可能有效地提供这种价值是您的工作。这包括除了编写代码来完成客户指定的任务之外的任务，最好不要编写任何代码。代码的创建是昂贵的。代码的维护和遗留代码的扩展更是如此。

由于软件的创建和维护是昂贵的，开发人员工作的质量(当仅仅看代码时)可以通过以令人满意的方式交付功能的速度以及之后维护和扩展系统的容易程度来衡量。许多设计讨论都是关于这两种方法之间的权衡。DRY 原则主要属于后一类:降低维护成本。不幸的是，盲目地使用干料通常会导致维护成本的增加。

## [](#the-good-side-of-dry)干的好的一面

那么 DRY 如何帮助我们降低维护成本呢？如果代码是重复的，并且需要更改，您需要找到所有重复的地方并应用更改。这(显然)比修改一个地方更困难，也更容易出错。您可以忘记一个需要应用更改的地方，您可以意外地在一个位置应用不同的更改，或者您可以修改当前发生相同情况但由于概念差异而不应该更改的代码(稍后将详细介绍)。这也被称为[猎枪手术](https://en.wikipedia.org/wiki/Shotgun_surgery)。重复的代码还会模糊代码的结构和意图，使其更难理解和修改。最后，它传达了一种粗心和缺乏责任感，这导致更多的粗心。

每个在这个行业呆了一段时间的人都遇到过可怕的程序代码，或者可能是假装面向对象的代码，其中复制粘贴显然是其创造者最喜欢的方式。这样的程序员确实应该注意 DRY，因为他们所生产的东西受到我们刚刚讨论过的问题的困扰。那么干的谬误在哪里？

## [](#the-fallacy-of-dry)干的谬论

由于消除重复是提高代码可维护性的一种方法，所以只有当消除重复使代码更易维护时，我们才应该消除重复。

如果你正在读这篇文章，想必你不是一个复制粘贴的程序员。我共事过的人几乎都不是。一旦你知道如何创建设计良好的面向对象应用程序(即通过了解[坚实的原则](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)))、编写测试等，你创建的代码将与复制-粘贴-程序员的工作非常不同。即使当坚持坚实的原则时(在有意义的程度上)，仍然可能存在应该被移除的重复。这里的问题是，这种重复将与应该保留的重复混合在一起，因为删除它会降低代码的可维护性。因此，试图消除所有重复很可能会适得其反。

## [](#costs-of-unification)统一的费用

消除重复如何降低代码的可维护性？如果统一的成本超过复制的成本，那么我们应该坚持复制。我们已经讨论了复制的一些成本，例如需要进行霰弹枪手术。现在让我们来看看统一的成本。

第一个代价是增加了**复杂性**。如果你有两个有一点公共代码的类，你可以把这些公共代码提取到一个服务中，或者如果你是一个受虐狂，把它提取到一个基类中。在这两种情况下，您都通过引入新的类来消除重复。在这样做的时候，您可能会因为没有重复而降低总的复杂性，并且这种提取首先可能是有意义的，例如为了避免违反单个责任原则。尽管如此，如果提取的唯一原因是减少重复，问问你自己，你是减少了整体的复杂性还是增加了它。

另一个成本是**耦合**。如果你有两个有共同代码的类，它们可以是完全独立的。如果您将公共代码提取到一个服务中，那么这两个类都将依赖于这个服务。这意味着，如果您对服务进行更改，您将需要注意使用该服务的两个类，并确保它们不会中断。如果服务最终被扩展来做更多的事情，这尤其是一个问题，尽管这更是一个实实在在的问题。我将跳过通过继承重用代码的结果，以避免我和我的读者产生自杀(或杀人)的想法。

> 干=耦合
> –DD DEU 2017 上的幻灯片

耦合增加了对**通信**的需求。在大范围内，当谈到组件或应用程序之间的统一代码时，以及当不同的团队最终依赖于相同的共享代码时，尤其如此。在这种情况下，每个人都清楚对一段代码的确切期望是什么变得非常重要，并且由于需要进行沟通以确保它们对每个人都有效，因此做出更改通常是缓慢且昂贵的。

统一的另一个结果是代码再也不能**单独进化**。如果我们有两个具有相同代码的类，并且在第一个类中，代码中需要一个小的行为改变，那么这个改变很容易实现。如果您正在处理一个公共服务，您可能会做一些事情，比如添加一个标志。这甚至可能是最好的做法，尽管从设计角度来看这可能是有害的。无论哪种方式，你都开始走上**腐蚀你的服务**的道路，它现在变成了一只正在加热的锅里的青蛙。如果你统一了你的代码，这是另一个你要问自己的地方，这是否仍然是最好的权衡，或者一些复制是否更容易维护。

你也许可以用相同的代码表示两个不同的概念。这是有问题的，不仅因为不同的概念需要能够单独发展，而且**误导**在代码中只有单一的表示，这实际上隐藏了你在处理两个不同的概念。这是重用范围越大越重要的另一点。领域驱动设计有一个被称为[有界上下文](http://martinfowler.com/bliki/BoundedContext.html)的战略模式，它是关于代表不同(子)领域的代码的分离。一般来说，避免在有界上下文之间共享代码是有好处的。你可以在我的关于[实现干净架构](https://www.entropywins.wtf/blog/2016/11/24/implementing-the-clean-architecture/)的博客文章“经验教训:有界上下文”一节中找到一个对两个不同概念使用相同代码的具体例子。

> 干是针对一个有限的环境
> ——Eric Evans 在[中说好的设计是不完美的设计](https://www.youtube.com/watch?v=lY54TmmEllY)

## [](#conclusion)结论

复制本身并不重要。我们关心代码容易(便宜)修改而不引入回归。因此，我们希望[简单的代码易于理解](https://www.entropywins.wtf/blog/2017/01/02/simple-is-not-easy/)。追求消除重复作为最终目标，而不是考虑成本和收益，往往会导致更复杂的代码库，具有更高的耦合性、更高的通信需求、低劣的设计和误导性的代码。