# 为什么 React 需要 Redux

> 原文:[https://dev.to/ross/why-react-needs-redux-b09](https://dev.to/ross/why-react-needs-redux-b09)

# [](#background-and-component-state)背景和组件状态

有时，组件生成的 UI 代码需要在初始呈现后更改(例如，响应用户交互或网络请求)。为了启用这些动态 UI，React 为我们提供了组件状态。组件状态是一个非常有用且设计良好的特性，但是如果使用不当，我们可能会创建脆弱的组件，这对于维护、重用和测试来说是一场噩梦。

# [](#the-problem)问题

当我们试图使用组件状态来管理整个应用程序的状态时，问题就出现了。在现实世界的应用程序中，某些类型的状态需要在组件之间共享。一个常见的例子是身份验证状态，因为应用程序的许多不同组件需要知道用户是否登录以及用户是谁。让我们考虑一个假想的应用程序中的两个组件:`<UserMenu />`，一个位于导航栏某处的下拉用户菜单，和`<LikeButton />`，一个位于页面主体某处的按钮，允许用户喜欢一篇文章。这两个组件都需要知道谁登录了。通过将用户数据保存在父组件状态，例如`<App />`，并将其作为道具通过组件层次结构向下传递，可以在这两个组件之间共享用户数据。除非应用程序非常小或者大部分是无状态的，否则这很快就会成为一个令人头疼的问题。

当我们采用共享组件状态的方法时，我们最终会创建大量的“传递”道具，这些道具除了传递数据和把中间的所有组件弄乱之外，没有什么别的作用。最重要的是，这些直通道具(UserMenu 和 LikeButton)的最终用户最终会得到一个很大的道具表面积。为了让他们渲染，他们的父母必须提供他们需要的许多道具。

需要许多道具的组件更难重用。(`<LikeButton />` vs `<LikeButton loggedIn={this.props.loggedIn} username={this.props.username} likePost={this.props.likePost} />`)。每次我们想用`LikeButton`的时候，所有这些道具都得打出来。当测试一个组件时，这个问题变得更加严重，因为作为道具传递到组件中的每个函数和数据在测试时可能需要被模拟。

当一个组件需要改变共享组件的状态时，事情会变得更加混乱。想象一下:`<App />`通过组件层次向下传递一个`onLike`回调到`<LikeButton />`。当用户点击按钮时，`<LikeButton />`发出网络请求，然后调用`onLike`。回调函数在`<App />`上调用`setState`来记录共享状态的变化。这种类型的安排在组件之间创建了非常难以理解和改变的复杂关系。

# Redux 如何帮助

有了 Redux，我们所有的数据都存储在一个单独的存储中，组件可以只订阅它们需要的数据，无论它们安装在哪里。在我们的例子中，先前存储在`<App />`中的共享状态被移动到 Redux 存储中。当`<LikeButton />`挂载时，它简单地从存储中订阅它需要的数据——程序员不必键入从它的父节点传入的一堆道具。如果`<LikeButton />`需要改变共享应用程序的状态，它可以直接导入动作或动作创建者，并调度它们。`onLike`不再是`<App />`上的一个方法，而是成为了一个动作创造者。

# [](#conclusion)结论

Redux 帮助我们做更少的输入，编写更简单的代码，并开发无耦合和易于重用的组件。