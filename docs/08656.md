# 编写我的第一个编译器

> 原文：<https://dev.to/fcpauldiaz/writing-my-first-compiler>

## 开始

我为一个大学项目写了我的第一个编译器，我真的很喜欢它，所以我想分享我的经验。关于这个问题，我将会讲得非常专业，所以先做一点介绍。

## 设定

如你所知，计算机不理解源代码，它理解二进制代码。那么我们如何从源代码到二进制代码呢？计算机硬件，它执行周期和处理电信号的物理形式，负责将 0 和 1 转换成这些电信号。你猜怎么着？每个编译器都依赖于编译它的处理器(除非在它们之间使用了其他东西，比如 java 虚拟机)。二进制代码有一个称为汇编的上层，这是一种低级编程语言。所以我的编译器的目标是将高级编程语言转换成低级编程语言。考虑到编译器不一定需要转换到低级编程语言，它可以转换到另一种高级编程语言。

## 流程

编译器分为两个主要阶段:分析和综合。分析是通过回忆信息(如变量)来识别源程序的结构，而综合是从结构和回忆的信息中构建翻译。我制作了自己的[版本](%5Bhttps://github.com/fcpauldiaz/LexerParserGenerator)的分析，只是为了经历这个过程，但是对于我的[编译器](https://github.com/fcpauldiaz/Compilador)，我实际上使用了一个强大的解析器生成器来避免我自己实现中的问题，使用访问者模式调用了 [ANTLR](http://www.antlr.org/) 。

## 相位

### 词法分析

根据被分析语言的语法识别源程序的元素。这个阶段保存符号表中的信息，并产生代表元素标识的记号。

```
pos = initial + rate * 60 
```

Enter fullscreen mode Exit fullscreen mode

转换为

```
<id, 1> <=> <id, 2> <+> <id, 3> <*> <60> 
```

Enter fullscreen mode Exit fullscreen mode

### 语法分析

也称为解析，它使用前一阶段的标记来构建一个称为语法树的语法结构。在这个阶段，有可能识别出语法错误，如缺少`;`，缺少括号

### 语义分析

事情开始变得有趣了。我从这一点开始，因为我在前两个阶段使用了 ANTLR。这一部分我喜欢的是，我必须决定我的高级语言输入实际上将会如何。我应该使用缩进(像 python)还是括号(像 java)来定义作用域？我应该使用强类型变量(int var)还是松散类型变量(var)？除了这些问题之外，还有一点必须牢记在心，那就是目标组件。目标程序集将决定您实际能做什么或不能做什么。对于我的编译器，我选择了 RaspberryPi 的 ARM 编译器。

语义分析使用语法树和符号表来验证指令的语义，换句话说，源程序实际上是有意义的。

### 中间代码生成

在这个阶段，我不得不开始生成看起来很像的汇编代码，称为三位地址码。想象一下这个

```
pos = initial + rate * 60

t1 = id3 * t1
t3 = id2 + t2
id1 = t3 
```

Enter fullscreen mode Exit fullscreen mode

其中`id`和`t`将是下一阶段汇编代码的寄存器。理论上，这个阶段可以使编译器独立于目标编译器，因为您可以从相同的中间代码生成中生成不同的汇编。

### 生成代码

在这一部分，我必须考虑几件事。我将如何存储这些值？每种类型将使用多少空间？我将如何保存全局？这些是要解决的第一个问题，这也是为什么了解装配如何工作很重要的原因。我决定所有的东西都用 4 个字节保存，不管是什么类型的变量，只是为了简单，但效率不高。我将在哪里保存这些字节？我决定，全局变量将被保存在内存和堆栈中的其他东西。要考虑的另一个步骤是如何使用以及使用多少寄存器，为此需要寄存器描述符和地址描述符，因为需要知道数据的当前值和地址以及寄存器何时可供使用。

最后，对我来说最困难的部分是激活记录。该部分用于初始化代码块中使用的寄存器，包括参数、返回值、临时变量和控制链接。这一部分是递归工作的关键。

根据[龙书](https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811)改编。