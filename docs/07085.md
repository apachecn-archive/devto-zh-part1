# 技术债务:定义和实践方法

> 原文：<https://dev.to/mikamai/technical-debt-definition-and-practical-approach-1444>

我知道这篇文章并没有发明什么新东西，你可能已经读过几百遍关于技术债务的文章了。这篇文章只是对技术债务问题的又一次探讨，描述了我们在 Mikamai 中遵循的实用方法。

软件开发的过程传统上由三个阶段组成:开发、测试、发布。这些阶段可以进一步细化或拆分:开发阶段可能包括在一个 *alpha* 环境中的频繁部署，该环境将包含不完整的特性，但允许容易地接收反馈；然后，测试可能会在不同的环境中按顺序进行(即，第一个环境是具有空数据集的隔离环境，第二个环境是具有真实数据集的隔离环境，第三个环境可从互联网访问并可用于压力测试，等等)

在传统开发生命周期结束时发生的一件事是发布，这里的术语“发布”更像是“家具装运”而不是数字产品交付。在这个传统的生命周期中，产品确实被认为是稳定的，没有任何问题，我们可以很快忘记它，继续下一个*产品*。可能会有一段时间的可控操作性，我们承认应用程序可能会受到一些错误的影响，这些错误将被修复。但是这段时间之后发生的任何奇怪的事情都被认为是*预料中的*。

问题是:一个软件特性不是一张桌子，或者一个座位。

发布后，即使过了一段合理的时间，我们也会发现开发人员没有完全理解规范，现在需要匆忙重写部分代码，而没有考虑太多的主题，如代码可读性。

还可能发生的是，交付的特性是好的，它交付了我们所要求的商业价值，是高性能的并且没有错误。即使在这种情况下，即使有了这种出色的发展，公司战略的改变可能需要在几个月或几年后改变产品。

即使在最幸运的情况下，仅仅是时间的流逝就日复一日地增加了需要再次修改代码的机会，例如为了适应技术升级。

无论发生什么情况，我们都要突然处理这些可怕的代码，这些代码是由几年前离开团队的开发人员用一种古老的技术编写的，即使是很小很小的变化，通常只需要一天，现在也需要几周。

例如，我们可能发现自己两年前在一个月内编写了一个电子商务，但现在需要两个月来更改一个功能，争论这是谁的错，以及继续维护一个如此昂贵的工具是否合理。

我们夸张了，但没那么夸张。

## 什么是技术债？

*技术债务*的概念是[沃德·坎宁安](https://it.wikipedia.org/wiki/Ward_Cunningham)创造的一个比喻，用来描述软件项目中的复杂性。他的想法是，发布第一次编写的代码就像欠了一屁股债，可以通过重构来偿还。在这段不太正确的代码上花费的每一分钟都会增加债务的利息。

Cunningham 不仅找到了一个好的比喻来描述复杂性，而且这个比喻也很好地描述了最坏的情况，**如果开发没有遵循正确的方法，债务的利息可能会上升到使项目瘫痪的程度**。

显然有开发商和开发商，顾问和咨询师。经验对编写更好的代码、理解规范和第一次尝试就写出最好的实现非常有帮助。但是这还不够:**有时候，即使是最好的代码也很难理解和更改，从而增加了技术债务。**

通常我们倾向于将技术债务视为只影响“旧代码”的东西。但是，70 年代编写的代码会比 90 年代编写的代码更复杂，这一点并不明显。

技术债务的另一个定义，更普遍地被接受，是由[的](https://www.amazon.it/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052) [Michael Feathers](https://michaelfeathers.silvrback.com/) 提供的有效使用遗留代码 : **它是没有测试覆盖的代码**。这是一个很好的定义，可以帮助我们避免将术语“技术债务”与术语“旧代码”联系起来的错误。

编写测试是对技术债务的一个很好的预防措施的原因是**测试提供了一个关于应用程序运行的隐含文档。**

因此，我们不是在谈论“未经测试的代码”，而是在谈论:

——不容易阅读的代码；

–不包含逻辑解释的代码；

——没有对导致编写代码的想法和决策过程的解释。

在这个问题上提供了一个完全不同的观点。因为在这一点上**技术债不仅仅是技术问题，还是沟通问题**。

## 技术债是如何产生的？

我们用开头描述的电商例子。

在前 100 行代码之后，这种技术债务可以通过向同事展示代码来偿还。这个简单的操作意味着共享知识，对逻辑正确性进行反馈，并确认代码对其他人是可读的。

一个月后，当电子商务发布时，我们有了一个正常运行的平台的最低要求。在这一时刻，技术债务可以被偿还，向我们的同事展示购买过程，再次检查代码，以便我们可以确保没有太复杂而难以阅读的黑点，并编写一些自动测试，以允许购买过程正常运行。这个技术债比以前高很多，但还是可以接受的。

发布两个月后，我们被要求添加一个亚洲国家:一切都需要改变，从税收到客户领域。考虑到任何更改都可能破坏购买流程，开发人员已经开始在每次推送后在试运行环境中测试他们的更改。这减缓了开发速度，技术债务现在如此之高，以至于我们开始感觉到第一个问题。为了偿还这笔债务，我们现在应该彻底改变我们的策略，开始投入一些时间来编写测试并清理代码中更多的问题点。

六个月过去了。在每一个新版本中，我们都会发现新的错误，因此我们雇佣了一名 QA 专家，他的职责是在每一个产品发布之前访问试运行环境，帮助发现和修复错误。目前，技术债务的利息如此之高，以至于我们实际上是在支付一名新员工的工资，否则就不需要这笔钱了。

一年后:公司成长了，现在我们需要在电子商务中加入品牌概念。这需要对应用程序进行彻底的重构。该团队正在尽最大努力，但开发进展缓慢。我喜欢认为，在这一点上，技术债务已经获得了一种物理形式:它是一条吞下自己尾巴的蛇。技术债务没有高到任何开发都慢下来，团队在项目上工作很累，但同时又很忙，没有时间进行重构。

我们离我之前提到的最糟糕的情况还没那么近:重写应用程序成本太高(从头重写从来都不是一个好的选择)，改变应用程序反而风险太大。

总结一下，每次我们说的:

——代码难改；

——代码难读；

–不稳定 app

–开发周期慢；

——团队难以扩大；

–应用难以升级；

–应用难以维护；

–表现不佳。

我们在谈论技术债务。

## 怎样才能减少技术债？

技术债务是一个沟通问题，这不可避免地让人想起[康威定律](https://en.wikipedia.org/wiki/Conway%27s_law) : **设计系统的组织……不得不生产这些组织的沟通结构的复制品**。

甚至在解决技术债务进入细节之前，改变代码，我们需要解决沟通问题。我们需要确定我们将使用哪些通信协议来记录项目本身、功能规范、代码背后的思想等等。只有在决定了使用哪些协议之后，我们才能深入研究代码。

这种通信协议是什么，它可以帮助减少技术债务？

–行为测试:测试高级功能的自动测试(即在网络产品中使用浏览器)。除了它们作为测试的价值，它们通常也容易理解，并且可以揭示开发人员的许多意图；

–代码本身:

–注释和代码格式化。即使是代码块之间的一个简单的空白行也可以传达很多信息(例如，处理过程的两个不同阶段的两个块)；

–变量、对象、方法、函数的命名。将一个变量命名为“value”并不能说明它包含了什么，将一个方法命名为“calc”也不能说明它计算了什么；

–错误:提出错误并详细描述正在发生的事情可能会在一年后挽救你的一天，那时错误将在被认为是超稳定的过程中突然出现；

——再谈错误:没有什么比不提出错误更糟糕的了。最糟糕的情况是，您没有收到任何错误，仍然没有得到任何结果(例如，您看到“购买成功”页面，但没有订单生成)。错误总是有用的。

–版本控制系统:在 Git 上写得很好的 commit 可能是解决一个不可理解的 bug 的最珍贵的工具，或者当你正在阅读一行晦涩难懂的代码时。

——典型的“项目文档”:设置过程、部署过程、如何创建试运行/生产环境、如何执行系统任务等；

–公司聊天室、slack、论坛、邮件列表。这些工具具有持久的历史，我们可以使用它们来跟踪决策过程中的讨论；

——还有很多比这些更多的，其中一些比另一些更明显。

使用正确的通信协议可以帮助我们构建一些新的东西，一些可以允许开发者(现在和未来的)之间共享知识的东西，一些充当平台所有者和平台开发者之间的通信桥梁的东西。

一旦我们设置了通讯协议，我们就可以开始分析这个项目，因为它是一个古墓，记录每个发现并试图给每个对象一个解释。

但是真正的清理应该是逐步进行的，同时我们也可能会推出新的功能。但是我们应该避免一下子改变一切。重写一个产品几乎从来都不是一个好主意，因为重写会导致“隐含”规范的丢失，那些隐藏的特性有助于给产品带来我们所知道的体验。

大规模进行重构还有其他一些副作用:

——需要一笔可观的预算；

——清理代码时要求停止开发新功能；

——它增加了产生 bug 的机会，因为我们可能会清理那些效果还不完全清楚的特性，或者因为测试过程不能测试它们所有的边缘情况。

假设我们的房子很乱，有客人要来(买新房卖旧房不是选项)。如果我们试图一起打扫所有的房间，我们就有超时的风险(客人会看到我们的房子乱糟糟的)。我们可以试着对所有的房间做一个粗略的打扫，但是我们的房子还是会很乱，只是没有以前那么乱了。相反，我们可以忽略客人看不到的房间(我们的洗手间和厨房)，专注于他们肯定会去的房间(客厅和浴室)。

当重构时，我们可以采用同样的方法。我们使用新的通信协议创建新功能，每次我们的功能处理或需要更改旧功能时，我们也会清理该功能，将其升级到新标准。

## 实用的方法

经验告诉我们，当客户联系我们重构、升级或维护遗留应用程序时，我们需要遵循一种方法。

在这些情况下，第一步是**代码检查**，以评估情况。我们进行代码分析(在一些工具的帮助下)，因此我们可以了解代码的哪些部分更难阅读或更改，存在哪些安全漏洞，以及文档的状态。因此**我们向客户提交了一份文件，其中描述了我们的发现以及客户可以采取的改善措施**。

在这一点上，由客户来决定这个代码检查是否应该导致改进过程的开始。如果流程开始，是时候**定义一个团队**:

——如果已经有一个高级技术团队，我们的开发人员通常会加入现有的团队；

–如果有一个技术团队，但它主要由初级开发人员组成，我们通常会尝试将新的开发留给现有的团队(后面跟着一个导师)。与此同时，由专家组成的另一个小组进行维护工作；

–如果没有技术团队，我们可以提供一个。

然后是发布生命周期的**定义**:

——在最坏的情况下，如果不创建一个运营团队，我们就做不到这一点；

——如果没有反问题，我们通常会尝试建立一个持续的发布流程；

–在特殊情况下(例如，当每个版本需要为平台用户生成特定文档时)，我们建议使用里程碑和预定版本；

最后，我们可以**定义仪式和沟通协议**:这一步因客户而异，因为他们中的一些人有足够的时间参与每个沟通协议，一些人可能每周只参加一次审查/规划会议，一些人不喜欢视频会议工具，等等。以下是典型设置:

–每天早上 10:00(周三除外)15 分钟单口相声；

–每周三 15:00 30 分钟回顾会；

–每周三 15:30 30 分钟计划会议；

——每周四 02:00 生产发布；

——每月第一个周五 17:00 进行回顾和进度报告；

—*的定义完成*。例如:

–需要在产品化中发布的特性:

–自动单元测试；

—*来自同事的代码评审*；

——记录在*变更日志*中；

–至少进行一次集成测试。

–需要在生产中发布的特性:

–在评审会议上由*产品负责人*批准；

–翻译成每种支持的语言。

–需要发布一个 bug fix:

–至少要有一个测试来测试是否存在 bug。

现在团队可以开始项目工作了。目标是创造稳定，达到增长和稳定之间的平衡点，在保持低技术债务的同时，保持发展的平衡。

通常在一段时间内，我们还会发现自己在缩小团队规模，因为:

——自动化测试的数量减少了任何新特性导致的回归；

——代码变得可读性更强，更易管理；

——初级开发人员学习如何在技术债务水平较低(或没有)的情况下编写代码。

我们在这个过程结束时创造的财富使我们能够轻松地交付新功能。与此同时，这创造了一个新的开发者阶层，他们更有道德，对某些主题更谨慎。**最后我们可以说，这个过程正在成为公司文化的一部分，改变了康威法则的结果**。