# 测试遗留代码，第 1 部分:如何开始

> 原文:[https://dev . to/rapasoft/testing-legacy-code-part-1-how-to-start-2k M7](https://dev.to/rapasoft/testing-legacy-code-part-1-how-to-start-2km7)

我正在开始这个迷你系列，它是我之前关于为什么我认为遗留代码库应该被测试的文章的延续。在这一部分中，我将更加概括，但稍后我将主要写一些使用 Java 代码库时的实用技巧。

意图很清楚，如果这些要点听起来很熟悉，您应该能够从中受益:

*   您正在维护一个大型代码库
*   您正在重构旧组件(重写逻辑、升级)
*   您无权访问代码历史(原始开发人员不在公司，VCS 历史不可用或存储库被迁移，等等)。)
*   您没有文档，或者文档已经过时

## [](#how-to-start)如何开始？

### [](#static-code-analysis)静态代码分析

在这种情况下，你需要有系统的方法。首先，我建议安装任何用于静态代码分析的工具。我真的不知道为什么，但是我帮助维护/改进的大多数遗留项目都遭受了巨大的技术债务。换句话说，代码质量是一些抽象的术语，静态分析是完全缺失的。我发现安装专用的 SonarQube 实例很有用，你的团队可以使用它。设置质量关卡应该是个性化的，但是我强烈建议至少启用标准配置。

> 为什么这很重要？

这种分析应该让您了解代码的实际问题以及潜在问题可能出现在哪里。然后，您可以创建针对这些问题的测试场景。例如潜在的`NullPointerException`或错误关闭流的问题。在这一点上，你应该注意到它们是一些*红旗*，它会把你指向系统中应该优先处理的部分。

SonarQube 可以给你一份关于覆盖率的非常全面的报告，所以如果你的目标是真正地*找到好的测试候选人*，这就是开始的地方。它也非常容易安装，对于非技术人员来说好处也是显而易见的(图表之类的)。

### [](#individual-code-analysis)个人代码分析

你还需要在个人分析上投入一些精力。这些是我对遗留代码的通常观察:

*   代码是不可单元测试的(大方法——没有单元，类承担太多责任，缺少依赖注入，复杂的类层次结构，等等。)
*   业务逻辑很复杂，需要大量的测试数据准备
*   需要外部库或第三方应用程序来执行某些操作(外部 API、数据库等)。)

当你试图使用简单的方法时，这些都是潜在的障碍。以上所有的问题都可以通过一定的代价得到缓解，但是在这个阶段，您应该关注您所拥有的关于您想要测试的系统的信息。

### [](#follow-the-thread)跟随线索

无论是一个 web 应用程序还是一个集成项目，你都应该准备一些场景，来模仿现实生活中的用法。例如，如果实现不清楚，至少应该清楚系统总体做什么。

例如，如果应用程序公开公共 API，就从编写 API 测试开始。如果它是一个后端“数据处理”系统，尝试提出可能的测试/预期数据，等等。通常你应该寻找一些我喜欢称之为**的最不模糊的黑盒**。它是一个功能已知但实现未知的组件。

> 为什么重要？

没有这种分析，你不会取得很大的成功。机械地测试一些东西可能不会发现实现中的问题，因为你可能以测试错误的实现而告终。如果很清楚，你应该总是使用场景。

## [](#putting-it-all-together)把所有的东西放在一起

根据您的结果，您应该能够得出这些孤立的案例:

*   要测试的功能(制定为任务)
*   当前测试覆盖率(生成的报告)
*   实现中可能出现的错误(从静态和单个代码分析中总结)，这将有助于确定案例的优先级
*   个别备注，取决于可用的知识(重要性、使用频率、外部依赖性等)。)

准备好这些案例后，您就可以开始实现测试了。在接下来的文章中，我将针对具体的问题和可能的解决方案。