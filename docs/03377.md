# 一致性模型

> 原文:[https://dev.to/napicella/consistency-models-52l](https://dev.to/napicella/consistency-models-52l)

# [](#consistency-models)一致性模型

## [](#why-this-post)为什么发这个帖子？

我发现很难找到一个权威的来源来描述某个一致性模型与程序员定义的契约。此外，有些资源似乎相互矛盾。这篇文章的想法是记录我对一些最常见的一致性模型的发现，这些模型可以在我们与之交互的分布式系统中找到。可能的话，我会在找到定义的地方添加资源。

## [](#consistency-model-as-abstraction)作为抽象的一致性模型

在分布式系统中，一致性模型是系统和使用它的开发人员之间的契约。如果在内存上的操作遵守由模型定义的规则，则称系统支持某个一致性模型。它们是一种强大的抽象概念，有助于根据系统的可观察属性来描述系统。
从实践的角度来看，一致性模型回答了如下问题:如果客户端 1 在下午 1:00 向分布式数据存储添加一个对象，而客户端 2 试图在 1:01 下午读取相同的对象，客户端 2 能够获得新的对象吗？还是会因为找不到资源而得到 404？
答案是...看情况。回答这样的问题要考虑很多因素。其中之一是分布式数据存储所采用的一致性模型。

## [](#sequential-consistency)时序一致性

任何执行的结果都是一样的，就好像所有处理器的操作都是按某种顺序执行的，并且每个处理器的操作都是按其程序指定的顺序出现的。
[![memory model](../Images/8ab2b6556834a59b16aaf6575b53065a.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--ZmgtEZjG--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/199fsqnu4jfya4xnbip6.png) 
概念上有一个全局内存和一个开关，随时将任意处理器连接到内存。每个处理器按照程序顺序发出存储器操作，并且开关在所有处理器之间提供全局串行化。
**因此:**顺序一致性是不确定的，因为分布式程序的多次执行可能导致不同的操作顺序。
[![Example](../Images/c3714976539129f437186c9939d6da0b.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--TKSMIsG0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/e3jbo1cv2f76w5qzwb9f.png) 
在上例中，无论发出操作的实际顺序是什么，都有四种可能的执行顺序。
**重要:**无论操作的顺序是什么，都保证在所有处理器中是相同的。这也意味着每个进程将观察到相同的操作历史。例如，在第一种情况下，`b.1`将读取状态，该状态是在`b.1`之前完成的所有操作的结果:因此`b.1`将读取账户的值‘150’。

## [](#strict-consistency)严格的一致性

也叫**强一致性**或**线性化**。
类似于顺序一致性，但是处理器之间程序的执行顺序必须是那些操作发出的顺序。
打个比方，这和我们从多线程程序中得到的差不多，在多线程程序中，内核和主内存之间没有缓存，编译器和 CPU 都不允许重新排序指令。
**因此:**如果每个处理器中的每个程序都是确定性的，那么分布式程序就是确定性的。

## [](#causal-consistency)因果一致性

放宽顺序一致性，当操作不是“因果相关”时，还允许在相同的处理器中对操作进行重新排序。

## [](#pram-consistency)PRAM 一致性

每个处理器的写操作(并且只有写操作)按照程序指定的顺序出现。

## [](#serializability)可串行化

与上述模型不同，可串行化定义了对一组操作(称为事务)的保证。它保证在多个项目上执行一组事务(通常是读写操作)等同于事务的`some`串行执行。
与可线性化不同，可串行化并不强加确定的顺序，在这个意义上类似于顺序一致性，但对于一组操作。
相反，严格的可串行化保证了由可线性化表达的相同约束，但是对于事务:事务必须按照它们被发布的顺序执行。
这个定义看起来和上面的有些不同，因为它来自数据库人员，而顺序一致性等。来自分布式系统的人。

## [](#read-after-write)写后读

该模型保证了对所有客户端的项目更新的即时可见性。这个概念类似于现代处理器中的内存屏障。
**注:**有时候在某些系统中所谓的写后读，实际上是创建后读(比如在)。

## [](#read-after-create)创建后读取

该模型保证了新创建的数据对所有客户端的即时可见性。对现有对象的更新可能不会立即对所有客户端可见。

## [](#conclusions)结论

这些是我关于分布式系统的许多方面中的一个方面的意见。我会继续在列表中添加更多内容。当然，任何反馈都将不胜感激！

### [](#additional-resources)附加资源

*   [顺序一致性](https://en.wikipedia.org/wiki/Sequential_consistency)
*   [线性化](https://aphyr.com/posts/333-serializability-linearizability-and-locality)