# 沙希

> 原文：<https://dev.to/horia141/sdhash-4iaj>

本文讨论了 [SDHash](https://github.com/horia141/sdhash) 包，这是一个 Python 库，用于计算忽略感知差异的图像散列。

作为人类，很容易发现两个图像是否“相同”。不幸的是，计算机就不一样了。除了最简单的情况之外，诸如逐像素比较两幅图像的简单方法在所有情况下都会失败。即使是更复杂的方法，如计算图像之间的\mathcal{L}_1 或\mathcal{L}_2 平均距离，并取一个小值来暗示相似性，也不会好到哪里去。

例如，给定一个原始图像 A，下面应该产生等效的图像:

*   以相同的纵横比缩放。
*   以非常相似的纵横比缩放。
*   增加了高频噪声。
*   小模糊/高通滤波。
*   有损压缩和重建。

前一组转换可以说是自然的，也就是说，当图像被移动、编辑等时，它们肯定会在任何系统中发生。然而，还有一类更大的变换是**对抗性的**，也就是说，有人试图欺骗系统，让它相信一个图像是原始的，而事实上它不是。用户生成内容网站面临这个问题，不管内容的模式(文本、图像、音频、视频)。

以下逆向串行转换也应该产生等效的图像:

*   从边界移除一小块区域。
*   90 度，180 度，270 度旋转。
*   水平或垂直翻转。
*   添加或删除水印。
*   色彩平面的改变，但不改变亮度平面。
*   灰度转换。
*   限制在小范围内的大规模编辑(例如，用一个文本替换另一个文本)

SDHash 试图解决两个图像是否相同的问题，对第一组中的所有变换和第二组中的一些变换(去除边界和色彩平面变换)取模。

它公开的 API 很简单。`test_duplicate`方法接收两幅 PIL 图像作为输入，并根据它是否认为这两幅图像是等价的返回`True`或`False`。`hash_image`方法返回“稳定”图像内容的 base64 编码的 md5 散列。`test_duplicate`方法本质上是测试参数的哈希值是否相等。对于更高级的用法，第二种方法是首选工具。

例如，可以使用散列的数据库表，将`hash_image`的结果作为主键。每当需要添加新图像时，可以首先对照表格对其进行检查，并且只有在还没有找到新图像时才插入新图像。这允许对每次插入执行 O(1)次比较，而不是 O(n)次。类似地，MapReduce 作业可以在 map 阶段计算图像的哈希，这将导致所有相同的图像在 Reduce 阶段使用相同的关键字分组在一起。这允许使用 O(n)算法来复制大型数据集。

另外，SDHash 可以处理 GIF 动画。它将它们视为一系列帧。只有第一、第五、第十等。考虑框架。使用相同的基本方法，但是所有的帧同时被考虑。

# 用法

```
import sdhash
from PIL import Image

i1 = Image.open('test1.png')
i2 = Image.open('test1_noise.png')
i3 = Image.open('test2.png')

h = sdhash.Hash()

h.test_duplicate(i1, i2) # True
h.test_duplicate(i1, i3) # False
h.hash_image(i1) # [an md5 output] 
```

# 算法

核心算法很简单:

*   输入图像被转换成高精度灰度的单个平面。
*   这个平面被调整到标准宽度，同时保持长宽比。
*   DCT 是在平面上计算的。
*   MD5 散列是从一个流中计算出来的，该流从图像的宽度和高度开始，接着是左上角最重要的 DCT 系数，按行主顺序，固定到一个间隔和精度。

这个过程的所有细节都可以通过 hasher 对象构造函数的参数来控制，尽管它们的效果有些神秘。已经提供了良好的默认值。

# 安装

主要依赖于 Python 图像库和 NumPy/SciPy 等。因此，依赖 SDHash 会带来很多负担。理想情况下，因为它只依赖于非常小的一部分功能，所以库应该直接包含 DCT 代码。请随意贡献一个经过良好测试的实现。

安装很简单，通过`pip` :

```
pip install sdhash 
```