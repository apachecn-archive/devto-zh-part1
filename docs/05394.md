# 优点(！)的脏代码

> 原文:[https://dev.to/d4ttatraya/advantages-of-dirty-code](https://dev.to/d4ttatraya/advantages-of-dirty-code)

*最初发布于[我的博客网站](https://d4ttatraya.github.io/Dirty-Code/)* 。

对我来说，首要的优势是我不需要定义它。ðŸ˜Š!几乎所有编写过任何程序的人都知道什么是脏代码；是否每个人都意识到这是另一个故事。

互联网上充斥着编写代码的原则、规则、技术、最佳实践和操作步骤。现在，几乎每个程序员都在谈论用各自的编程语言编写代码时要遵循的某种技术。在使用这种技术编写代码时，我们必须遵循许多规则和最佳实践。最终，它给自由编写代码带来了许多限制，减慢了我们的速度，使我们无法按时交付，并且比任何真正的程序员所能想象的要痛苦得多。

以下是遵循这些实践副作用的高度概括:

*   给事物命名需要很多时间
*   模块之间需要不必要的分隔
*   让我们编写许多额外的代码，这些代码永远不会出现在产品版本中
*   不允许添加评论
*   先强迫犯故意的错误，然后解决它们让我们更详细地了解这些副作用，看看它们有多痛苦。

## [](#naming-things)命名事物

互联网上的许多人都在谈论给变量、函数、类、模块及其必要性赋予*有意义的名字*。但是为什么它如此必要呢？如果你给一个变量命名为`d`而不是`numberOfDaysInTrailPeriod`，会发生什么？

```
int d = 10;
int numberOfDaysInTrailPeriod = 10; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

编译器不会产生错误，也不会中断运行时间。
同理此

```
int rdsTrail(){//code}
int remainingDaysInTrailPeriod(){//code} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

来吧，让我们不要浪费时间为事物想合适而有意义的名字。

如果我们自己或其他人将来会在这个代码上工作，我们会调试并理解`int d`和`int rdsTrail()`代表什么。

## [](#decoupling-of-modules)模块的解耦

这是在编写包含许多相互交互的模块的大型项目时，在某些技术下讨论最多的另一个话题。在为模块编写接口时也会出现这种情况。我不明白是什么让他们想到在这些接口后面隐藏实现？他们称之为某种抽象概念。
没有人会干扰这一实施。在这里，我们已经厌倦了实现新功能和修复错误；我们为什么要去改变别人的实现。如果模块之间的交互如此强烈和频繁，我们为什么要在它们之间保持精细的分离呢？我们已经为我们的项目编写了模块，如果我们删除任何模块，我们的项目将毫无用处。那么为什么要认为我们要分开独立地使用每个模块。

如果将来我们需要替换任何模块，那么只需根据新模块修改相应的代码，或者如果需要在任何其他项目中重用它，只需重写它。

## [](#unit-tests)单元测试

然而，程序员的另一个神话是，花费越来越多的努力和时间来编写简单的代码，而这不超过一分钟。单元测试的主要目的是看看我们的代码是否如预期的那样工作，但是如果有 QA 和测试人员坐在我们旁边，我们为什么要自己费心去测试代码呢？单元测试不必要地迫使我们将大而好的 fat 函数分割成更小的块。限制函数的行数也限制了我们写函数的速度。还有，为什么我们总是遵循函数调用的*单一责任*和*自顶向下流*的规则？这当然会让我们慢下来。

如果任何人想在做了一些改变或添加了更多代码后测试代码的可使用性，那么他/她应该把程序交给测试人员。

## [](#readability)可读性

人们还说*代码应该以一种不仅计算机而且人类也能理解的方式编写*。同样，如果我们试图遵循这个规则，那么我们就需要浪费时间去写那些其他程序员仅仅通过阅读就能理解的代码。但是，简单地说，如果我们有如此漂亮和强大的 ide，为什么程序员需要直接读取代码而不是运行它并观察输出。
他们放在这里的另一个约束是*代码中没有更多注释*。所有的 ide 都支持在代码中添加注释。不要仅仅通过阅读代码来让它变得容易理解，让我们在需要解释的地方加上注释。在上面的例子中，我们可以添加类似
的注释

```
int d = 10; //number of days in trail period 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这没有错，编译器不会抛出错误，编译后的版本也不会包含这些注释。

如果我们担心通过阅读来理解我们的代码，让他们通过调试或者通过阅读控制台日志或者仅仅通过阅读注释来理解它。

## [](#tdd)TDD

现在我可以用这个词了，噩梦！对于所有程序员来说，TDD 只不过是一场噩梦，尤其是对于那些真正遵循它的人来说。*犯了错误，改正它；再做一个，纠正一下...*这有多傻？相信我，这个流程创建了另一个比实际程序更大的并行程序，也花费了两倍多的时间。这是为了迫使我们**遵守所有上述规则**。
即使是非常小的修改，我们也需要首先修改各自的测试，或者添加小代码，我们需要首先编写测试。也就是说，我们必须首先考虑测试，然后再考虑实现；不是很费时间吗？

与其让测试驱动我们的开发，为什么我们不能直截了当地开始，不犯任何错误。

## [](#at-the-end)结束

我想说的是，不要听信别人的话，忽略我们代码的以下特性:

*   易于阅读，理解
*   易于更换的模块、算法
*   易于调试和修复错误
*   易于修改和重复使用
*   易于添加新功能我们可以在将来需要时随时想到这些功能。所以只要冷静下来，然后*写一个能正常工作的代码！*

你知道我这篇博文是什么意思吗...！！！
[![](../Images/c5efc19484dfe58286650b06affe12c3.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--Iv1wUCMU--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/ti3290ndh03xu0vasd39.jpg) (图片提供:[rathod.milan053@gmail.com](mailto:rathod.milan053@gmail.com))
如果你站在编码的任何一方，肮脏的一方或者不管另一方，请留下评论，给个ðÿ'！

*参考资料:鲍勃大叔的干净代码*