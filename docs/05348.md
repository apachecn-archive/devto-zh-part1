# 关于代码的推理

> 原文:[https://dev.to/ericnormand/reasoning-about-code](https://dev.to/ericnormand/reasoning-about-code)

很多人谈论“关于代码的推理”。我当然知道。这是我想当我还是一个面向对象程序员的时候从来没有听说过的事情。**这是什么意思？**

这是一个棘手的问题，因为它不是那些有技术定义的术语之一。这只是人们在谈论函数式编程的好处时所说的话。但既然我也这么说了，我不妨给**说说我对术语**的理解。

对我来说，“关于代码的推理”就是关于人类思维的局限性。如果我们是超级天才，我们可以阅读任意数量的代码并理解它。但我们不是也不能。随着程序变得越来越大，我们会情不自禁地忘记程序中发生了什么。

人们习惯于与现实世界互动，在现实世界中**效应往往是局部的**。例如，如果我被锁在家里，十英里外的人就不能攻击我。当我们晚上走在街上时，我们知道在世界的某个地方有人可能会伤害我们。但我们担心的是他们是否就在附近。我们不是从所有攻击者的位置开始，计算他们每个人能够伤害我们的概率，而是环顾我们所在的地方，评估我们看到的人。**人类在本地思考，因为那是行动的地方。**

我们在函数式编程语言中发现的就是这种位置感。当您查看功能代码时，有几件事可以帮助您定位自己:

*   范围正在本地化。定义不能从别处“漏进来”。
*   纯粹的功能是本地化。纯函数无论什么时候调用，调用多少次，行为都是一样的。
*   不可变的值正在本地化。不用担心代码的其他部分修改它。
*   **孤立的和巩固的副作用。至少它们发生在同一个地方。**

因为一切都是相对局部的，所以你需要阅读和理解的东西更少，从而能够推断它将要做什么。编程语言中有一些**常见的东西是非本地化的**。

*   **全局可变状态。**任何东西，在代码的任何部分，都可以随时更改。本地的反义词。
*   **范围泄漏。**变量经常可以在它们的作用域之外被修改，或者一个作用域中的突变在该作用域之外是可见的。
*   **易变的物体。**您正在引用一个正在从您下方变化的对象。
*   **副作用。**好吧，一旦你通过电线发送信息，或者接收信息，它就不再是本地的了。

**那么我们该怎么办呢？**将状态从全局下推到局部。尽可能使它地方化。从代码中分离出纯函数，这样可以隔离状态变化。尽可能使用不可变的值。隔离并巩固你的副作用(这样至少你知道它们发生在哪里)。

### 结论

人们经常谈论“关于代码的推理”，但不清楚它是否有意义。但是我确实使用了这个术语，当我这样做的时候，我的意思是“事情更本地化，所以我可以把它们保存在我的脑海里”。这是一个很适合我的想法。例如，它的行为就像代码的味道。如果我记不住什么东西，是时候让它变得更有用了。

如果你喜欢这个话题，或者你想进入函数式编程，你可能想试试 [PurelyFunctional.tv 时事通讯](https://purelyfunctional.tv/newsletter/)。这是一封关于 Clojure、函数式编程以及它们与技术历史的关系的每周邮件。