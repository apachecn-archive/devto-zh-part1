# 请重新发明轮子

> 原文:[https://dev.to/codemouse92/please-reinvent-the-wheel-4fm2](https://dev.to/codemouse92/please-reinvent-the-wheel-4fm2)

> 不要多此一举。

我将上述内容提交给“可怕的民间智慧名人堂”我们把这句话当作圣经一样随意使用，但是仔细想想...

在世界历史上，我们*确切地说*发明了多少次轮子？

[![Different types of wheel](img/23fd317d6029a2dc718bc460a5906ef7.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--yVWlKotD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/6fjxej3ewgzjkqwlankp.jpg)

如果历史上没有太多的发明家和工程师寻找各种方法来改进和适应车轮的各种用途，我们都会像弗雷德·燧石族一样开车。

[![The Flintstone family car](img/2f903f80ac9ac895e07282d71f19d587.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--TKO8qK0m--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/j4ea3ccbicxzel5vi9iy.gif)

编程也是如此。有许多人会说，通常是非常激烈地说，你不应该浪费时间写现有模式或算法的原始实现；事实上，有些人会说你甚至不应该费心去开发新的模式和算法。“我们有所有这些伟大的图书馆，所以为什么要浪费你的时间？你永远也写不出这么好的东西！”

那些模式、算法和库的作者没有一个听从他们同时代的诽谤者，难道我们不高兴吗？

现在，在你们一大群人第一万次把这当成重新实现泡沫排序的许可证之前，让我断言**我们不是纯粹为了重新发明而重新发明轮子**。你必须知道适当的情况。

* * *

# 【再】发明原因 0:学习

我先来说说第一个原因，因为从技术上来说，这与其说是*重新发明*的动机，不如说是*重新实现*的动机。**学习一个算法或模式的最有效的方法之一就是自己实现它。**

你会注意到我把这个列为原因`0`，这是有意的。为此目的而编写的实现很少出现，除非它们最终成长为其他类别之一。

为原因 0 编写的实现通常...

*   实现精确的算法，没有任何改进，

*   比他们的主流同行慢，而且

*   不如同时代的同类产品稳定和可维护。

因此，即使您为学习编写了一个新的实现，在您将其用于生产(或分发给其他人)之前，您也应该再三考虑。

# (再)发明理由 1:更好

重新发明轮子的一个原因是如果你能改进它的设计。车轮已经增加了辐条、轮胎、内胎、轮辋、胎面、轮毂盖和各种改进。这些使车轮在特定环境下表现更好。

同样，如果你能改进现有的设计，重新发明也是合理的。例如，我开发了 IOChannel 作为 [PawLIB](https://mousepawmedia.com/pawlib) 的一部分。我的库在`std::cout`和`fprint`的基础上增加了很多功能，允许更容易地打印和格式化多种类型的信息，包括[内存转储](https://dev.to/codemouse92/3-cool-things-to-do-with-pawlib)。

然而，有一句话要提醒你:警惕堆积在*钟、哨子和锣*！不要为了功能而添加功能。“YAGNI”(你不会需要它)是一个很好的缩写词:只添加你或你的目标用户有特定用例(或用户故事)的特性。

换句话说，除非是烤面包机，否则你的发明不应该烤面包。

# (再)发明理由二:更快

另一个重新发明轮子的常见原因是对速度的需求。赛车不能用马车的轮子比赛；它需要一种专为在赛道上高速行驶而设计的车轮。

许多库被设计成通用工具，牺牲了许多特定的优化来保持对尽可能多的用户有用。然而，一旦您知道您的具体用例是什么，您通常会通过创建算法、模式或数据结构的自定义实现来实现卓越的性能。

编写高性能代码不是你可以随便接近的。这是一项严肃的投资，需要大量的时间、细心的关注、广泛的测试以及大量的研究和资料阅读！

除此之外，有时编码人员可以开发新的优化来改进一般的实现。有时，人们可能会将这些改进贡献给一个主流库，而其他时候则需要一个全新的新库。这个决定不能掉以轻心。

就我个人而言，一些反对者劝阻我尝试超越主流实现的性能，但事实是，**我已经做到了**。时间在前进，每天都有新的创新和改进。我们的行业*需要*愿意挑战经实践检验的真理的人。

这里的失败并不是什么可耻的事情。性能优化是一门艺术。在更快的实现中，每一次失败的尝试都会让你学到新的东西。如果你真的需要速度，那就继续吧！

我将用另一句警告来结束这个理由...

> "过早优化是万恶之源."*——唐纳德·克努特*

在你开始微调你的赛车成为最快的赛车之前，你需要先*造一辆功能性的车*。让它工作，然后在你开始全面优化之前，让*工作得很好*。再说一次，这不是一个可以掉以轻心的努力。优化本身就是一个特性。

# 【再】发明原因三:清洁工

有时候，一个新的实现不需要新的特性或更快的速度就值得；有时它仅仅需要清理、重构和维护！

抽象是棘手的事情。对于我们使用的每一种语言、库和工具，我们都在增加另一个抽象层次，正如 Joel Spolsky 指出的...

> “抽象是失败的。有时一点点，有时很多。有渗漏。事情出了差错。当你有抽象概念时，这种情况随处可见。”

事实是，我们必须维护这些东西，有时维护工作落在了*用户*身上，而不是*作者*身上。

考虑到这一点，您更愿意跳入哪个代码库呢？

A)一个流行的库，它有 10 年的代码基础，部分符合 1998 年的标准；完全没有注释，很少记录，有数百个公开的问题，许多可以追溯到 21 世纪初。

b)具有完全相同特性的新库，严格遵循最新标准编写；记录良好，有意向评论，有相对较少的未决问题。

现在让我们做出更简单的决定:

A)使用库 A 中的特征 X(如上)。

b)写一个新的特性 X 的实现，完全跳过库 A 的使用。

通常，编写一个新的实现比解开一盘十年前的意大利面条更容易。

反对者可能会再次对你大喊:“你凭什么认为你能比图书馆 A 做得更好，你这个自大的自以为是的小家伙？”

你的回应应该是“你凭什么觉得我*不能*？”

与第一和第二个原因一样，这不是轻率从事的事情。你必须准备好编写代码来实现与旧实现完全相同的目标，但是更干净，错误更少。你*不想要的是创建另一个其他编码人员不得不忍受的更糟糕的实现。*

顺便说一下，对于这方面的一个真实例子，比较一下 GCC 编译器和标准库与 LLVM/Clang 的编译器和标准库。我的公司使用后者主要是因为代码库的原因！

# 发明(再发明)的其他理由

还有一些其他原因可能需要重新发明轮子:

*   **许可原因。也许现有的实现都是专有的，或者根据合同，都是 GPL 许可的。有时你需要重新发明轮子的唯一原因是你可以*使用它*，这没关系。**

*   现有的实现被放弃。当然，你可以尝试派生这个库并进一步开发它，但这将取决于这是否更实用。(见原因 3)。

*   **因为依赖=痛苦。有时将*再多一个依赖*带入你的项目是不切实际的。如果在仔细考虑了您的选择之后，您发现编写自己的实现比依赖库或以其他方式将第三方代码注入到您的源代码中更快或更好，那么就去做吧。**

# 不(再)发明的理由

现在我们已经讨论了“重新发明轮子”的主要原因，让我们来谈谈你绝对不应该做的几个原因:

*   **因为我能(除非理由 0)。**除非你有具体的理由重新发明，否则请不要。我们已经有太多糟糕的*和另一个*实现了，阻塞了 GitHub 和 Sourceforge。

*   **因为 NIH【不是这里发明的】。**信不信由你，有才华的程序员并不为你的组织工作。在你决定重新发明轮子之前，彻底探索你所有的选择。

*   **就因为我个人不喜欢开发商。**对不起，自己过吧。如果你写一个新的实现的唯一原因是展示另一个开发者，你只是在满足你的自我。在这种情况下，没有人会赢。

*   因为一只手绑在背后我可以做得更好。是啊，你大概不能。总是假设多此一举是*难*。

*   因为只需要几分钟。哈哈哈哈，*没有*。每当我发现自己在想“我要花几分钟时间，然后……”我知道我在给自己设置失败。

*   因为我没有做调查。没有任何借口可以不做现有实施的功课！

# 不要唱反调！

如果你只记得这篇文章中的一件事，那就让它成为:

**出于对数字万物的热爱，请立即从你的白话中划掉“不要重新发明轮子”！**

这个短语包含了所有阻碍进步的悲观主义。我们没有想法，也永远不会。每次你告诉别人不要发明轮子，你可能会关掉下一个吉多·范·罗苏姆、艾伦·凯、蒂姆·彼得斯或唐纳德·克努特。你可能*字面上的*是阻止某人创造语言处理的下一个突破、下一个最快的排序算法或下一个分水岭编程语言的声音。

相反，鼓励人们带着清晰、谨慎的意图去重新发明。*鼓励*是这里的关键词！你可能正在点燃下一个让世界变得更好的火花。