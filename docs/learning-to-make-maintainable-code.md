# 学习编写可维护的代码

> 原文：<https://dev.to/pbeekums/learning-to-make-maintainable-code>

程序员希望写出好的代码。有道理。各行各业的人都以自己的工作为荣，并希望确保工作的最高质量。高质量的软件包括很多东西，其中之一就是使代码易于修改/维护。

软件永远不会真正“完成”。总是有新的版本有新的特性，这显然意味着需要编写更多的代码。这些代码通常是在现有功能的基础上编写的。现有代码的编写方式会严重影响编写新功能的难度。

比如亚马逊以前只卖书。现在他们什么都卖。假设你花了 6 个月的时间来建立一个卖书的网站。你愿意再花 6 个月的时间让你的网站能够销售服装吗？再花 6 个月时间增加销售电子产品的能力？

大概不会。理想情况下，增加一种新的销售项目应该很快。所有的基础设施都是为了卖书而建立的。大部分应该是可重复使用的。添加衣服或电子产品需要的时间会减少，可能是一个月或一周。这只有在卖书的代码易于修改的情况下才会发生。

问题是:**如何定义代码是否容易修改？**

当编写可维护的代码时，几乎没有即时的反馈。写完之后，你可能几个月或几年都不需要修改它。即使这样，你可能也没有足够的次数来看看你之前的决定是好是坏。

更重要的是，如果一个新的程序员直到几年后才得到正确的反馈，他怎么知道如何做出这些决定呢？做这些决定没有基础，因为没有足够的时间来看到早期尝试的结果。初学编程的人只能做他们觉得**好的事情。**

听起来最好的事情通常是确保代码不会重复。以亚马逊为例，如果他们有代码将书籍添加到购物车中，他们会想要编写全新的代码将电子产品添加到购物车中吗？大概不会。他们会想重用购物车代码来买书。

像所有好东西一样，程序员可能会把这种想法带得太远。许多初学编程的人，包括几年前的我，开始在没有重复的地方看到重复。更具体地说，我们看到了重复的可能性，并试图阻止它通过。

[这篇中帖](https://medium.com/@webseanhickey/the-evolution-of-a-software-engineer-db854689243#.u7g1saunt)就是一个完美的例证。这个程序非常简单。随着时间的推移，程序员开始想象程序的更多用途。他们创建更多的代码，以确保他们总是能够重用他们编写的代码。

因为程序员无法获得反馈或体验他们决策的后果，他们只能假设他们走在正确的道路上。这意味着考虑更多可能的方法来重用他们的代码。随着时间的推移，这自然会增加，他们最终会编写超过 100 行的代码，这样他们就可以重用开始时只有几行代码的东西。

如果 100 多行代码最终得到了大量重用，那么也许是值得的？

问题是程序员已经考虑了重用代码的可能方式，但不一定是可能的方式。为了涵盖所有可能的可能性，程序员创造了一个复杂的系统，对于团队的其他成员来说，这个系统更加难以理解。还有一个事实是，你写的代码越多，代码中的某些部分就越有可能被破坏。所以一个可能没有错误的简单程序现在是一个更有可能有错误的复杂程序。

在某一点上，希望在那篇文章中列出的 10 年之前，程序员已经有了足够的经验，他们开始意识到可能和不可能的可能性之间的差异。他们学会了将最有可能被重用的、需要更健壮地构建的代码与最好保持简单的代码分开。

获得这种能力没有灵丹妙药。它需要在早期就做出这些决定，看看哪些是对的，哪些是错的。毕竟熟能生巧。而且并不意味着程序员最终会学会做出完美的决策。他们只是逐渐做出更好的选择。

*本帖最初发表于[blog.professorbeekums.com](https://blog.professorbeekums.com/learning-to-make-maintainable-code/)T3】*