# 请不要打扰仓库的人

> 原文：<https://dev.to/codemouse92/please-dont-annoy-the-warehouse-guy>

*最初发布于[indeliblebluepen.com](http://www.indeliblebluepen.com/?p=817)。*

古老的格言是正确的——当你有一把锤子时，一切看起来都像钉子。过去十多年的编程行业已经以最不幸的方式证明了这一点。我们动态分配*一切*。

在我开始之前，有一个免责声明:**动态分配是一个极其重要的工具**，没有它，大多数编程技术往好里说是不切实际的，往坏里说是不可能的。不要把婴儿和洗澡水一起倒掉。如果你正在编写任何一种严肃的软件，你将不得不在某个时候动态地分配一些东西。关键是**知道，不是*如果*，而是*什么时候*要用动态分配**。

那么，问题就像我开头的谚语所说的那样:我们已经不再辨别什么时候应该使用这个非常强大的工具，我们已经开始在任何事情上使用它。这有点像编程世界的 Vicks Vapo-Rub——一些人认真地认为它可以治愈一切，但误用会导致相当大的痛苦、眼泪和苦难。

这是一个相当大胆的声明，因为我基本上只是对一些主要软件公司的编程哲学、几种高级编程语言和 C++标准库的一个很好的部分泼水。如果你不是站在那里，双臂交叉，等待一个坚实的情况下，两次包裹在钢和石棉，我会非常失望。

为了让你明白这一点，我需要从解释什么是动态分配开始。另一个免责声明——我真的不能完全相信这个类比。我第一次从罗伯特·奈斯特罗姆(Robert Nystrom)的书《游戏编程模式》(Game Programming Patterns)中了解到这一点，他的书非常幽默，我坚信这本书应该被每一个有激情的程序员所拥有和阅读。

在解释高速缓存未命中的整个问题时，Nystrom 描绘了下面的画面。

> “想象你是一个小办公室里的会计。你的工作是要一箱文件，然后用它们做一些会计工作…你可以在一分钟内完成一整箱。不过，有个小问题。所有这些箱子都存放在另一栋大楼的仓库里。要得到一个盒子，你必须让仓库的家伙带给你。他去拿了一辆铲车，在过道里转来转去，直到找到你想要的盒子。说真的，他花了一整天来做这件事。–罗伯特·尼斯特罗姆，*游戏编程模式*，第。270

这一小段很难与两页纸的类比相提并论，所以你只能自己去看了。作者在上面的链接上免费阅读了整本书，尽管我强烈建议为你的书架买一本。

如果你认识我有一段时间了，你就会知道我是一个绝对善于类比的人，这一个立刻成为了我的列表。我最终改变了一个不满意的仓库伙计的想法，来解释 RAM 管理的许多问题，尤其是动态分配。

当然，那个仓库是 RAM，有很多人需要在里面存储东西。为了保持正常，仓库管理员给所有的货架都编了号。每个需要仓库空间的人都被分配了一些货架，他们可以随意使用。那是堆栈。

然而，经常有人需要储存超过那些架子所能容纳的东西。也许这个办公室人员不知道他们在工作日开始时需要多少空间。当然，仓库管理员需要知道到底要给你留多少货架。仓库的这一大片区域就是堆，很多人都需要使用它。你不能给他一些无限制的数字。

所以，你开始工作，你意识到你需要三个调色板的空间。你召集仓库人员，要求三个货架。仓库管理员上了他的铲车，开着车四处转悠，发现了三个连续的空货架。然后，他给你货架号码。世界又恢复正常了。

你继续工作，决定在那三个架子旁边再加五个架子。你向仓库的伙计要这些东西，但是当他回到仓库时，他发现在你的三个货架旁边还有别的东西。因此，会找到八个连续的开放架，并为您移动调色板。然后，他给你新的货架号。太好了，问题解决了。

十分钟之内，您决定该批中还需要四个托架。回到仓库，可怜的仓库伙计走了，有点被你不断的要求激怒了。

再来两个架子。哎呀，不需要四个了。现在你还需要七个。还有六个。还有九个。再来两杯。再来一个！嗯，也许还有五个。还有 12 个？十六更？再来九个？再来四杯？

在这一点上，仓库的家伙想告诉你，采取一个永久的假期到温暖的土地，没有人说，但他太喘不过气来。你不仅浪费了他的时间，而且他对其他人的要求也反应迟钝。毕竟，只有他和另外三个人来照看仓库！(如果各位螺旋桨头还没想通，这是四核机。)大多数其他人都和你一样要求苛刻，现在他的老板(指电脑用户)对他大喊:“你为什么这么慢？”

荒谬的场景？一点也不——我刚刚描述了许多标准库数据结构的正常行为。当然，要将我的故事等同于一台普通的计算机，我们必须将这些数字乘以几百万，但原理是一样的。动态分配实际上占用了相当多的 CPU 周期(一个周期大致相当于一条指令。)

仓库伙计现在后悔了几个职业选择，并想知道“为什么他们不能提前要一百个货架，然后就完事了呢？”

事实上，他的建议是一个非常聪明的设计选择，也是许多专业程序员所提倡的，包括索尼顽皮狗工作室的开发人员 [Jason Gregory](https://twitter.com/jqgregory) ，以及《T2】 [游戏引擎架构](http://gameenginebook.com/) 的作者。在其极端形式下，这种策略需要定制内存分配器、对象池和其他出色的设计模式，这些模式吓跑了不太认真的程序员。

但在其更常见的形式中，仓库伙计的建议执行起来很简单。在 C++中，如果我们需要存储 15 到 200 个整数，很少有更多的机会，通常的习惯是认为“嗯，我不想创建一个 200 个对象的数组。我可能会用完空间，或者浪费空间。我就用 std::vector 吧。这就是错误所在。我们已经跳过了思考我们可能会使用多少空间的整个过程，相反，我们正在虐待仓库伙计，好像他没有什么更好的事情可做。

在许多情况下，更明智的方法是动态分配一个数组，比如说 50 个整数。最坏的情况是，无论数组存在多久，我们都有 15 个整数和 35 个未使用的字节。即使在一个拥有 256 MB(2.56 亿字节)内存的系统上，这也不算什么。(这不是懒惰使用内存的借口；然而，这完全是另一篇文章的主题。)

如果我们最终需要存储超过 50 个整数，我们会向仓库管理员再要 50 个架子。好吧，是的，他必须移动 50 个调色板，但他没有抱怨——如果我们每次都要求更多的货架空间，到现在为止，他至少已经将一个调色板移动到一个新的货架 50 次了。通过这样安排请求的时间，我们为他节省了很多工作，现在在我们需要更多空间之前，我们可以多存储 50 个整数。即使我们发疯，在完成数组时存储了 3000 个整数，我们也只打扰了 Warehouse Guy 60 次，而不是 3000 次。

是的，这个设计模式需要我们额外的时间和精力。我们必须预测我们需要的元素的最常见数量，以及我们需要更多的可能性。然而，对于所有这些额外的工作，我们实际上使我们的程序运行得更快。

这对性能有多大影响，尤其是对我们的现代机器？“我有一个 3.75 GHz 的四核处理器！你乌鸦。”我动态分配多少次都没关系！"

真的吗？我保证你这个星期至少有一次因为你的电脑太慢而感到烦恼。一些东西滞后，花了太长时间加载，或冻结了一段时间。如果您打开系统监视器，您会看到一个或多个 CPU 达到最大值。

让我们把它翻译成英语——3.75 GHz 意味着你的 CPU 每秒处理 37.5 亿条指令！如果一个程序导致 CPU 在仅仅 5 秒钟内从 5%到 100%，这意味着它已经使用(和/或浪费)了大约 35.625 亿条指令！如果程序设置为使用所有四个处理器，那么实际上你必须将这个数乘以四。

鉴于事实上我们并没有比十年前做的有太多新的东西(图形是一个巨大的例外)，这张图片有严重的问题。十年前，我们的处理器速度在 MHz(每秒百万条指令)左右。好极了。

你有没有想过为什么 Windows 98 可以在不到一分钟的时间内启动到可用状态(你可以点击某个东西，让它做出反应)，而 Windows 8.1 需要 10 分钟？这不全是膨胀软件——我自己的机器也出现了这个问题，它只有三个常见的启动应用程序，没有恶意软件。我维修过的绝大多数 Windows 机器(介于 XP 和 8.1 之间)都表现出同样的症状。

我不明白为什么当我们比较相同软件的两个版本时，它们具有基本相同的功能和设计，我们会发现旧版本在 10 年前的个人电脑上运行很快，而新版本在装有最新操作系统的 3 天前的电脑上运行缓慢。

问题是，太多的程序员，甚至是大办公室里的一些程序员，为了节省自己的精力，放弃了好的设计。是的，动态分配只是拼图的一部分，但是我断言它可能是非常大的一块。我们还没有收获摩尔定律的好处，因为我们正在集体束缚我们的计算机！

现在，我也必须离题了。我并不是说我们应该抛弃标准的库数据结构和工具。它们有许多重要的用途，我经常使用它们，尽管是明智的。它非常适合那些需要每隔几分钟*存储一堆大对象(从 1 到无穷大)的情况。*

我也不是说我们应该放弃我们的高级语言，在这些语言中，几乎所有的东西都是动态分配的。我热爱 Python，习惯性地试图寻找使用它的理由。一般来说，用 C++这样的低级语言编写代码，可以用高级语言高效优雅地构建，这是浪费时间。

然而，我们应该后退一步，重新评估我们的编码习惯中有多少是好的设计，有多少只是因为我们太懒了，没有找到更好的方法。

我的软件公司运行在一个非常简单的设计原则上:如果我们的软件能在一台普通的 Windows 98 机器上负责而有效地运行，它将会击败市场上的任何现代软件。这实际上并不是一个新颖的想法。

所以，我要在这里请愿。拜托，看在所有数字事物的份上，不要惹恼仓库的家伙！他工作努力，有很多事情要做。

在任何人抗议之前，是的，我知道一些标准的数据结构不会一次分配一个元素。这是一个了解你的抽象概念的论点。您应该了解您使用的数据结构是如何分配内存的——许多数据结构的表现确实像我描述的那样糟糕。

*封面照片致谢:[【40+216 张脸】由树皮](https://www.flickr.com/photos/barkbud/4663269309/) |授权于 [CC-BY 2.0](http://creativecommons.org/licenses/by/2.0/) 。*