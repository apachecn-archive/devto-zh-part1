# 石头，布，剪刀- Scala

> 原文:[https://dev.to/darbyo/rock-paper-scissors-斯卡拉-b37](https://dev.to/darbyo/rock-paper-scissors---scala-b37)

我最近开始创造一个石头、剪刀、布、炸药、水炸弹机器人(RPSDW)。RPS 的传统规则是适用的，除了炸药能打败除了水弹之外的任何东西，而水弹输给了除了炸药之外的任何东西。在这篇文章中，我将会讲述这个形的场景，接下来的过程以及机器人战斗的结果。

# [](#the-scenario)场景

在我们的开发社区会议上，我们通常会想出一个小的形，人们可以在几个小时内完成。这一次，我们决定要做一些更大的事情。每个小组的任务是离开并制作一个机器人，与其他机器人一起玩 RPSDW 我们打算几周后回来，让所有的机器人在一场比赛中互相较量。

比赛的规则是每个队互相比赛一次，比赛的结果是赢 3 分，平 1 分，输 0 分。机器人需要完全自动化，一旦启动，就应该根据需要尽可能多地相互比赛，首先赢得 1000 手牌并得分。最后，每个小组将收到 100 个炸药，可以随意使用。

# [](#the-process)流程

这个项目有趣的部分是我们用整个团队来创造这个机器人；我们的开发人员、测试人员、业务分析师和 scrum master 都陷入了代码中。在整个项目中，我们每周五下午会聚在一起一个小时，然后打开大屏幕开始工作。两把椅子放在前面，其余的人在旁边观察，一个人写一个单元测试，下一个人修改它，然后再写一个。然后我们会轮换。这意味着团队中的每个人，无论他们的角色或经验如何，都能平等地分享这个项目。

### [](#getting-started)入门

在创建机器人时，我们决定使用与我们的工作角色最相关的技术栈。我们使用 [Scala](https://www.scala-lang.org) 和 [Play 框架](https://www.playframework.com/)，Git 用于版本控制，而 [Heroku](https://www.heroku.com/) 用于部署。这对所有人来说都是一个很好的学习曲线，因为我们能够在公共环境中将整个项目从无到有变成一个工作应用程序；不是每个人都经历过的事情。

### [](#building-the-bot)构建 bot

我们从建立我们的项目开始，考虑实现 AI 和机器学习；我们很快意识到这有点乐观。然而，我们仍然在机器人中实现了某种智能。我们提出了“猜测者”的概念，它将使用不同的方法来尝试和预测对手机器人手中的游戏模式。我们的猜测方法有不同的深度。从一个简单的方法开始，计算游戏中所有以前的手牌，找到最常见的手牌，并玩出击败它的手牌。我们还实现了一种方法，将使用[博弈论](https://en.wikipedia.org/wiki/Game_theory)来尝试击败我们的对手。显然，我们制定了一个博弈论的防御方法来对付任何可能试图实施这种普通 RPS 技术的对手。

虽然，在最初听起来非常混乱，并采取了很多令人困惑的可能性之后，博弈论的辩护归结为简单地返回对手的前一步棋。

```
def predict(play: Play) = {
    if(play.result.contains(Result.DRAW)) random.getGuess else play.opponentMove.get
  } 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

为了让我们的猜测器工作，我们制作了一些模式来决定它何时会改变将要使用的方法。我们决定检查 losingAll、losingMost 和 draws 这意味着我们将不断检查游戏的状态，如果在最后 5 手牌中输了 5 手，在最后 10 手牌中输了 6 手，或者在最后 14 手牌中输了 7 手，我们将改变方法。这意味着赢的方法会被使用更长时间，输的方法在仅仅 5 手之后就会改变。

### [](#finishing-touches)点睛之笔

完成我们的机器人后，我们需要在某个地方托管它，以便 rps-frontend 应用程序可以向我们的机器人发出请求，并为比赛提供 GUI。为此我们选择了 Heroku 一个我们都没有经验的工具。这是一个伟大的决定；两个命令，Heroku 应用程序就创建并部署好了。

# [](#the-results)结果

在比赛日，我们在联赛中取得了一个良好的开端，轻松赢得了前 3 场比赛。我们坐在第一位，与每个人都有巨大的积分差距；即使比最接近的对手少打一场比赛。还剩两场比赛，我们很自信。然后我们和联赛最后一名的球队比赛(没有得分),结果惨败。当天的决赛恰好是决胜局。在第二场比赛中，我们是第一名，胜者为王。我们启动了前端，看着进度条在两个团队之间来回移动。直到最后，双方还是不分上下，对方以大约 20/30 手牌的优势获胜(差距很小，超过 2000 手)。

他们以如此小的差距击败了我们，我们渴望知道自己的错误。事实证明，我们错过了一条至关重要的规则；如果是和棋，那么下一手牌的赢家为这手牌和上一手牌赢得一分。另一队只实施了一种随机方法来检测听牌，因此在接下来的一手牌中玩了一个炸弹，而我们的猜牌大师却无法察觉。当选择 5 手牌中的 1 手时，很可能会有一些听牌。我相信这足以让他们获胜。

在我们的下一次迭代中，我们将考虑这一点...

你可以看到我们完成的机器人@ [RPS 机器人](https://github.com/sufferforyourart/rps-bot)