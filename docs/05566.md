# 在给定平均故障时间的情况下，数据中心内机器故障的平均数量

> 原文：<https://dev.to/horia141/average-number-of-machine-failures-in-a-datacenter-given-just-the-mean-time-to-failure-20m8>

我目前正在阅读[设计数据密集型应用](https://martin.kleppmann.com/2014/09/15/writing-a-book.html)。在这本书的开头，基本概率论的一个有趣的应用出现了。作者说*“据报道，硬盘的平均故障时间(MTTF)约为 10 到 50 年。因此，在拥有 10，000 个磁盘的存储集群上，我们预计平均每天会有一个磁盘死亡"*。他们试图说明的一点是，即使有一个相当可靠的组件，你也会在规模上看到很多问题。因此，大规模分布式系统*需要*承认这一事实，并对失败有抵抗力。我认为这种说法本身背后有一些简单的数学计算，不考虑它对工程师的严肃影响。让我们看看如何推导它。

首先要做的是为问题建模打下一些基础。假设我们有 N 台电脑。计算机可以处于*工作*或*故障*状态。所有计算机启动时都工作正常，但稍后可能会出现故障。然而，故障是暂时的，发生故障的机器会很快被修复。我们感兴趣的是这些计算机随着时间的推移在故障方面的行为。我们认为时间在离散的步骤中流动，就像《T4》回合制游戏一样。如果一台计算机在给定的时间 t 发生故障，我们可以假设它会在时间 t+1 被修复(当然，它可能会再次发生故障)。

失败是一种随机现象。在单个计算机层面上，我们可以说给定的机器在给定的一天会以一定的概率 p 发生故障。那么整个计算机群就有了一个概率行为。然而，这要复杂得多，这部分行为将在后面详细研究。

我们需要做一系列简化的假设。首先，我们认为所有计算机的故障概率是相等的。第二，这个概率独立于任何外部参数，如时间、以前的故障或计算机在集合中的顺序等。因此，单个参数 p 可以描述整个系综的行为。请注意，这不是一个完全现实的期望。有些失败是相互关联的。如果数据中心的整个机架断电，那么该机架中的所有机器都将发生故障。机器共享一些属性(在同一个机架中)的事实意味着它们的故障是相关的，或者说不是独立的。其他机器只是有隐藏的故障，在某一点后导致异常高的故障率。如果你从中看到了失败，你很可能很快就会看到另一个失败。然而，这个模型很不错，足以捕捉到一些好的见解。

考虑到这一点，我们可以说，计算机 I 在时间 t 的故障可以建模为具有[伯努利分布](https://en.wikipedia.org/wiki/Bernoulli_distribution)的随机变量 X_{i，t}，其单个参数设置为 p。对于所有 I 和 t，我们得到相同的模型，并且这些随机变量是[独立且同分布的](https://stats.stackexchange.com/questions/17391/what-are-i-i-d-random-variables)。

在这一点上，一开始的问题可以表述为*“假设一台机器发生故障的概率为 p，那么在某一天 t 内的预期故障次数是多少？”*。为了弄清楚这一点，我们需要看一下 T_{t} -当天的失败次数。T_{t}对于 T 的所有值都是相同的。我们可以写出 T_{t} = X_{1，t} + X_{2，t} + \cdots + X_{N，t}，因为无论机器是处于故障状态还是工作状态，每个 X_{i，t}都会产生 1 或 0。T_{t}的最终模型是参数为 N 和 p 的[二项式分布](https://en.wikipedia.org/wiki/Binomial_distribution)。给定一天机器故障的预期或平均数量正好是 Np。

因此，对于 10000 台机器和任意选择的低 p=0.0001，我们预计每天会出现一次故障。我们可以使用 [Wolfram Alpha](https://www.wolframalpha.com/input/?i=binomial+distribution+n%3D10000+p%3D0.0001) 来获得更多的见解。不幸的是，图表非常糟糕，但也有一些好东西。例如，至少一台机器发生故障(通常称为“成功”)的概率是 63.21 \大约 2/3。或者，一段时间内失败次数的一个示例为 1 | 1 | 0 | 1 | 0 | 2 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0。因此，在某些日子里，我们甚至会看到两次失败，而在另一些日子里，一次也没有。

最后一步是从 MTTF 获得 p。我们将关注单个机器 I，但是要跨时间来看它。机器在正常运行状态下启动，鉴于其相对较高的可靠性，可以连续运行几天 F_{i}。然而，在 F_{i}+1 时，它第一次停止工作。既然这是一个随机过程，F_{i}本身就是一个随机变量。一个很好的模型是参数设置为 p 的几何分布，即*“获得一次成功所需的伯努利试验次数 X 的概率分布”*。这个东西的平均值是 1/p，但如果用天来表示，它也是我们自己的 MTTF。所以我们可以计算 p = 1 / \text{days}(MTTF)。

因此，对于我们 10 年的初始 MTTF，我们得到 p = 1 / 3650 = 0.00027，这是我们最初测试值 0.0001 的三倍。因此，根据我们的模型和数据，我们实际上预计每天会发生 2.7 次故障。 [Wolfram Alpha](https://www.wolframalpha.com/input/?i=geometric+distribution+p%3D0.00027) 对这些参数的几何分布行为有更深入的了解。故障时间的一个例子是 2259 | 8792 | 2066 | 3770 | 1166 | 1179 | 1428 | 1720。所以，我们可以再次看到有一些差异。一些失败发生在 4 年内，而另一些则在 20 年内。

这里需要特别注意。如果你注意失败次数的样本，你会注意到有些相当大。这应该会让人惊讶。事实上，由于我们早期关于时间独立性的假设，我们错过了这些计算机故障行为中的许多额外的复杂性。故障建模和[可靠性工程](https://en.wikipedia.org/wiki/Reliability_engineering)是一个更复杂的课题，可以得到更精确的结果。

最后，让我们把东西放在一起，得到一个很好的公式。从制造商提供的给定的 MTTF 年数开始，我们可以计算出某一天的故障概率，在我们的所有模型假设下，p = 1/\text{days}(MTTF)。由此，我们可以计算出一天中的平均失败次数为 T = Np = N/\text{days}(MTTF)。这很简洁，希望容易记住。