# 编程与布鲁姆分类法

> 原文:[https://dev . to/mttaggart/programming-and-blooms-taxonomy-85g](https://dev.to/mttaggart/programming-and-blooms-taxonomy-85g)

*最初出现在[我的博客](https://theforeverstudent.com/cs-ed-week-part-3-programming-and-blooms-taxonomy-151cfc0d550f)上*

如果没有本杰明·布鲁姆对认知活动的分类，你就无法接近 21 世纪的教育理论。是的，有情感和精神运动活动的分类，但现在，我把重点放在认知集。让我们一起来背诵它们:

*   记住
*   理解
*   应用
*   分析
*   合成
*   评价

阿门。这些是按照认知复杂性排序的，而且碰巧的是，它们非常好地映射到学习计算机编程技能的过程中。或许这是显而易见的:一个描述学习的框架描述了你是如何学习的。不过，我认为这种一致性是值得注意的。一些科目同时涉及许多层面，要求学生同时进行分析、综合和评估。在编程中，在掌握下面的梯队之前，很难接近更高的梯队。

我用自己学习这些技巧的经历来解释一下。

## [](#remembering)回忆往事

在某些方面，学习编程就像学习一门语言——每种编程语言的符号和语法都是独一无二的，需要花费时间来充分记忆这些内容，以生成没有错误的代码。

下面是我的第一语言 Python 中的一段代码，它检查一个数字是偶数还是奇数:

```
def is_even(n):
    if n % 2 == 0:
        return True
    elif n % 2 != 0:
        return False 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我敢打赌，即使你以前从未读过 Python，你也能理解它。模数(`%`)返回整数除法的余数，所以本质上我在说:

> 如果，当`n`除以 2，我得到零，`n`真的*是*偶数。
> 
> 否则，如果我得到的任何东西*不是*零，`n`就是一个冒牌货，一个赝品。一部电影。

这段 Python 在语法上非常完美。当然，我花了几天时间才能够在不经常查看参考文档的情况下快速完成这样的东西。但是语法，符号，是我必须学习的第一件事。我必须*记住*Python 应该是什么样子。

但是你知道吗？这段代码部分是无意义的。有点像[乔姆斯基的一句话](https://en.wikipedia.org/wiki/Colorless_green_ideas_sleep_furiously):结构上合理，但功能上没用。为了修复它，我不得不*理解*更多关于任务的东西。在这种情况下，关于函数的性质，以及 if/else 语句的性质。

## [](#comprehending)领悟

“如果天气晴朗，那我就去海滩。否则，我就去看电影。”

```
if sunny == True:
    go_to_beach()
else:
    go_to_movies() 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

也许这是一个人为的例子，但这就是条件句的工作方式。我们对信息进行测试，然后相应地执行不同的命令。您可以看到相同的结构在英语中是如何存在的，并且很好地映射到 Python 的语法上。但是您也会注意到代码的第二部分是一个`else`，而不是上面的`elif`。条件句，如果有多个选项，*必须*以`else`结尾；这是默认行为。我不明白为什么当我写了上面这个语法正确的版本时，它对我大喊大叫。

一旦我*理解了*中条件句必须以`else`结尾的规则，我就把它改写成:

```
def is_even(n):
    if n % 2 == 0:
        return True
    else:
        return False 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

但是我仍然有更多的东西需要理解。这一次，关于函数。

上面那行是一个函数的开始。像在数学中一样，函数接受信息，并把一些东西吐出来。这就是`return`符号的意义所在:根据数字是否为偶数，吐出`True`或`False`。函数只能返回一个东西——在返回之后，它们会停止，直到被“再次调用”因此，如果我的`is_even`函数有`4`，它将测试`4`是否被`2`整除，如果是，则返回`True`。在这种情况下，代码的`elif`(“else if”)部分甚至没有被触及。

原来，我连*都不需要*这个`else`！只需一个`if`就可以了，因为如果测试通过，`return`会确保其余的函数不会运行。所以我的最终形式看起来像:

```
def is_even(n):
    if n % 2 == 0:
        return True
    return False 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

更优雅一点，不是吗？简洁不一定是程序员的目标(可读性才是)，但它往往来自于对自己所使用的工具的深刻理解。

**更新:** [鲍勃](https://dev.to/courier10pt)准确地指出:

```
def is_even(n):
    return n % 2 == 0 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

...就更优雅了。我经常在编写教学代码时，将优雅的最后一步留给清晰。尽管如此，上述内容仍值得理解为一种改进。

## [](#applying)应用

当然，编写一个函数来区分偶数和奇数有点做作。然而，我在这个练习中学到的模式将成为我继续编写的无数函数的无价之宝。

如果我们从均匀性/奇怪性的细节上缩小，这个函数在做什么？它决定了一个物体的性质，将它分为两类。当然，在人类生活中，二元状态是罕见的；生活是灰色的阴影。但是在纯粹的理性中，经常的情况是我们必须确定某个东西*是*还是*不是*。每次我们这样做，这种模式就会出现。由于对这种推理的形式及其模式有了坚定的理解，我能够把它应用到其他问题上。

## [](#analyzing)分析

作为一名作家和英语教师，我为自己的校对能力感到自豪。我会找到那个丢失的牛津逗号，那个误用的“its”反思这种能力，我确信它来自充分的实践，是的，但也来自充分的阅读，以至于我对语言“规则”的理解使违反规则变得很明显。

打字错误或语法错误可能会令人恼火。一个程序因为逻辑缺陷*或*一个打字错误(很难区分两者)而无法运行，这是令人恼火的。

这是我告诉我所有学生的一句话:编程是一门特别令人沮丧的学科，因为你花在解决一个问题上的大部分时间，感觉就像你失败了。一旦成功了，你就停下来继续下一步。当你做错的时候，你马上就会知道。没有一门手艺如此无情地暴露自己的逻辑缺陷。

被诱惑了吗？

好的，所以要正确地分析自己的代码或其他人的代码，分类法的前两层必须掌握得很好。

啊，但是编程领域的分析也指问题领域。程序员必须理解操作参数并在其中求解。要建桥，首先要读懂地形，丈量峡谷，精心规划。正是在分析中，编程的思维过程开始类似于工程。

## [](#synthesizing)合成

到目前为止，这些例子都相当简单，部分原因是它们能够做到这一点。甚至在大多数编程课程中，给学生布置的任务都是一维或二维的，直到综合的程度:写一个函数，取 X 并返回 Y；实现函数 A 来集成函数 b 的输出。你会在编程课程的早期章节中发现大量的支架。为了给初学者一种真实的体验，给他们的任务必须与他们在以后的旅程中会遇到的情况相类似。真正的软件应用程序有很多活动的部分。那里有台鲁布·戈德堡机器。

因此，当学生到达综合阶段时，他们可以编写一个多维项目。真正的应用。

或者，你知道，指导一个 [OK Go](https://www.youtube.com/watch?v=qybUFnY7Y8w) 视频。

## [](#evaluating)评估

在布鲁姆稀薄的空气中，我们有评估。在编程中——也许在写作中——这是风格出现的地方。程序员有足够坚实的技术基础，可以开始选择如何解决一个给定的问题。我们应该使用面向对象模式还是函数模式？堆栈或队列数据结构更有意义吗？我应该尝试递归算法吗？

对于给定的问题领域，选择甚至可以扩展到编程语言中。丰富的经验带来了广泛的选择，而编程语言只是工具。

但是一个程序员没有经历过扩展到完全完成的项目，怎么能做出这样的选择呢？换句话说，程序员必须在提升到评估之前完成一个综合。

## [](#beyond-bloom)超越绽放

就目前而言，Bloom 的分类法非常适合程序员的旅程。然而，对分类学的一个批评是它的极端个人主义。这是一个奇怪的模型，考虑到人类的社会性，当然也包括学习。任何 Harkness 老师都会告诉你，深度学习是一项社会事业，然而 Bloom 在功能上超越了分类学中的话语和辩证法。有人可能会争辩说，分类学的情感成分说明了这一点，但情感活动与认知活动是截然不同的，然而智力讨论在定义上是认知的。

所以我对 Bloom 有意见，尤其是在编程方面，因为程序员不再独自工作。为了完全掌握这门手艺，程序员必须加入一个其他人的社区，在一个开放的思想市场中分享经验和代码。

### [](#sharing)共享

将自己的代码发布到互联网上，接受他人的审查，这需要勇气。然而，每天仍有数百万人这样做。我们明天将更多地讨论开源，但是加入程序员社区是精通的不可或缺的一部分。学习如何讨论问题，在项目中做出有益的贡献，并作为团队的一部分对分配的工作负责，将编程从工艺转变为专业。

### [](#communitybuilding)社区建设

最后，年轻的程序员将有希望开始他们自己的开源项目，围绕这个项目开发一个贡献者社区。在这里，程序员现在也是人们的连接器，负责围绕项目的共同目标发展的公共纽带。这里的成功不再取决于程序员的手艺，而是我们希望传授给所有学生的更全面的人类技能。

简而言之，程序员的完整道路与其他技能或学科并没有太大的不同:通过一路上的努力，精通使一个人成为一个好人。