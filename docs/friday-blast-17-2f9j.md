# 星期五爆炸#17

> 原文：<https://dev.to/horia141/friday-blast-17-2f9j>

问 HN:我应该读哪些与语言无关的编程书籍？(2017) -黑客新闻讨论，有很多好标题。我甚至可以说*大多数好的科技书籍都是独立于科技本身的，并且提供了永恒的知识。*

[艰难地调试 PostgreSQL 性能(2016)](https://www.justwatch.com/blog/post/debugging-postgresql-performance-the-hard-way/) -对任何 SQL 调试会话都是很好的建议。从“显而易见”的东西开始，比如系统级的指标，然后一步步深入到单个的慢速查询。

[使用有限状态机的健壮用户界面(2017)](https://css-tricks.com/robust-react-user-interfaces-with-finite-state-machines/)——这真的是一篇精彩的文章，也是一个很好的例子，说明了了解一点理论如何让构建*的东西变得更加容易*。这个想法是，你应该明确你的 UI 的状态结构，因为这将导致更容易推理代码。我可以从自己的经历中证明事实就是如此。像 Angular、Vue 和 React 以及 Android 和 iOS 平台这样的现代 web 框架使得从这些角度考虑 UI 比“旧”时代的 web 或过时的 Win32 编程要容易得多。

[软件 2.0 (2017)](https://medium.com/@karpathy/software-2-0-a64152b37c35) -一篇关于机器学习和神经网络的文章，特别是关于它们在软件开发大计划中的位置。我认为将它们命名为软件 2.0 还为时过早。也许是软件 1.1 或者 1.5。目前，它们只是解决特定子问题的好工具，比如图像识别或音频合成。但是在你能通过神经网络编写文本处理器之前，还有很长的路要走。

[Hash chain (2017)](https://en.m.wikipedia.org/wiki/Hash_chain) -维基百科条目，一个简洁的认证想法，无需每次尝试都通过网络发送密码。要点是客户机和服务器同意一个共同的计数 k，并且服务器存储散列 k 次的密码。对于第一次认证，客户端发送 k-1 次散列密码，服务器计算第 k 次，并将其与自己的值进行比较，以允许或不允许认证。在下一次尝试时，计数减 1，服务器存储它从客户端接收的散列，供以后的用户使用。网络上不发送密码，如果任何人发现*发送了什么信息，他们就没有用了，因为它不会被第二次使用。客户机不需要存储 k，因为它可以在 auth 会话开始时从服务器接收 k，所以不需要同步复杂的状态。*

[统计错误和如何避免它们(2016)](http://www.cs.cornell.edu/~asampson/blog/statsmistakes.html) -这更多的是呼吁在报告计算机科学中任何类型的结果时使用统计工具，如标量描述性统计和测试，而不是其他任何东西。你*应该*尽管去做。