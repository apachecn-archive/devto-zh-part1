# 承担技术债务

> 原文:[https://dev.to/pbeekums/taking-on-technical-debt-6ga](https://dev.to/pbeekums/taking-on-technical-debt-6ga)

技术债务是一个有争议的话题。快速构建产品最初是一个非常理想的目标，但是这通常意味着承担技术债务，这会减缓团队在未来构建产品的能力。在短期内快速构建和长期内快速构建之间找到正确的平衡是非常具有挑战性的。

[![](../Images/04da36bedbe221d42fce3a9c676c62f0.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--u7QAEskz--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://blog.professorbeekums.com/img/2017/11/loan.jpg)

基本原理是简单的 ROI 计算。对于金融债务，当你相信你可以用债务赚到的钱超过你支付利息的成本时，你就去借。比方说，我可以借 1000 美元，一年付 200 美元的利息，赚 5000 美元。这是一个巨大的回报！我会尽我所能抓住这个机会。

不幸的是，技术债务没有明确的条款。你不知道要支付多少利息，甚至不知道债务的本金是多少。事情变得更加复杂，因为技术债务会增加软件错误的风险。有些虫子相对无害。一些 bug 可以终结公司。在这些情况下，没有办法准确计算风险。

出于这个原因，我认为没有人能提供一个公式，让你知道什么时候应该或不应该承担技术债务。这几乎总是带有某种程度不确定性的判断。我们能做的是解释我们是如何打这些电话的。我将尽最大努力解释我在当前项目中围绕技术债务所做决策的理由。

一些重要的背景:我仍在努力寻找产品/市场的契合度，所以代码可能会发生巨大的变化，因为产品将会发生巨大的变化。从现在起的 6 个月内，为了开发速度而优化我的代码是没有意义的，而实际上，很多代码甚至可能在 3 个月后才出现。

另一方面，找到适合市场的产品并不是一个周末黑客马拉松就能完成的任务。这需要几个月的努力。我可以做一些级别的优化，以确保我不会在每次产品更改时丢弃我所有的代码。

这就是第二十二条军规。理想情况下，我将代码分割成可以最大化重用的部分，但是我不知道哪些部分会被重用，因为我还不知道产品会如何变化。如果我的第一个构建是正确的方向，那就太好了，但是寻找产品市场适应性的全部要点是理解为一个产品找到正确的方向需要时间。

有一个经典的软件设计原则，你要确保系统的各个部分都被分割成逻辑块。一个例子是，在电子商务网站中，推荐引擎的代码和结帐过程的代码是完全分离的。即使推荐显示在结账页面上，后端系统也被隔离成结账页面使用的可重用“服务”。这允许将来自推荐引擎的结果复制到任意数量的页面上，只需编写最少的代码。

马利加的某些部分不那么清晰。推荐引擎和结账页面是非常不同的概念。我正在构建一个电子邮件产品，我决定重用许多其他产品流行的线程概念。虽然我无法想象在这一点上偏离这条道路，但我也不能排除这种可能性。这意味着我需要在我的系统中将电子邮件和线程的概念分开，即使它们是非常密切相关的概念。我可以使用另一段代码来组合这两个概念，因为它们在产品的这个版本中是相关的。如果产品发生变化，需要重写的就是这段代码。电子邮件和线程的代码可以保持不变，随时可以重用或丢弃。

这说起来容易做起来难。挑战不是技术性的。编写代码来做到这一点很容易。挑战在于程序员被训练成担心效率，而这样做违背了这种训练。

这方面的一个例子是在 Mysql 中使用连接。通过使用一个数据库查询来检索一个线程和该线程中的大量电子邮件，可以获得很高的效率。把它想象成给一个朋友送一系列礼物。发送一个大包裹可以节省包装每个包裹和跟踪每个包裹递送的时间。寄许多小包裹费用更高。

但是，在大型数据库查询中做所有事情的成本是它打破了这种分离。用包裹类比，你可能不会把珠宝和一堆书放在同一个包裹里。但有时效率的提高太诱人了，不容忽视。有一个例外。

然后又是一个例外。然后另一个。迟早你会发现代码在某一点上是分离的。所有的东西都融合成了一个巨大的斑点。代码可能被“组织”到不同的文件中，但它的功能仍然像一个 blob。

保持代码清晰分离的成本依赖于接受维护代码的低效率需求。幸运的是，这通常是可以的。这在早期带来的低效率几乎不明显。数据库每秒可以处理数百个查询。当系统中只有几个用户时，从 1 个查询到 2-5 个查询是不相关的。没有 Mysql 的加入我也能活下去。

如果您足够幸运，有足够多的用户，这就成了一个问题，您还必须考虑让所有用户都在一个数据库上。通过在代码中保持这种分离，每个孤立的块都可以被替换。也许会变成微服务。也许它被转换到一个不同的数据库。也许它会被第三方取代。开发成本被隔离到那个块。整个系统不需要重写。

现在，如果你在想“这听起来一点也不像承担技术债务！”，你说对了一半。没有承担技术债务的部分是高层次的系统设计。虽然当产品改变时，块可能被重新安排，但是大部分块应该仍然是可重用的。

技术债务的一部分就是这些大块。

例如，我想在今年夏天尽快发布 Maleega 的 alpha 版本。在 4-6 周内发布阿尔法意味着要走很多弯路。一个是关于数据存储。Mysql 数据库不适合存储电子邮件内容。它能很好地处理元数据，但不是大块的文本。技术上有一种方法可以做到这一点，但它不能很好地扩展到数百万封电子邮件。虽然 Alpha 版本不需要担心规模，但是我想尽快发布 alpha 版本。

我构建 alpha 版本的一个方法是将电子邮件内容和元数据放在一个列中。这将两部分数据联系在一起。我所有的代码都是在假设这些数据被捆绑在一起的情况下编写的。这将使得用数据存储交换数据变得更加复杂，尤其是在连接与线程等其他概念一起使用的情况下。

另一种方法是用一个单独的表来存储数据，而我的电子邮件表只是将它作为一个 id 来引用。这增加了看似不必要的开销，但也只花了大约 10 分钟的编码时间。它让我推迟了对可扩展数据存储的数小时研究、规划和编码。通过给新表起一个像“temporary_data_store”这样愚蠢的名字，它不断提醒我应该考虑替换它(在准备测试版时我就这么做了)。我允许自己通过花 10 分钟来推迟几个月的工作时间。技术债务的成本并不低。

另一个例子是我的净化代码。所有这些都被隔离在我系统的一个隔离部分。这是件好事，因为它效率极低。以至于我敢打赌，如果我把它作为面试问题的答案，我会在面试中失败。然而，这种低效率对于用户来说又是难以察觉的。网页加载预计不到 100 毫秒，但即使 gmail 发送一封电子邮件也需要几百毫秒。为清理增加 100 毫秒的处理时间并不是什么大事。

会不会是 10 ms？大概吧。我现在在乎吗？一点也不。通过隔离代码，我给了自己一个选择，在重要的时候重新构建它。成本将仅仅是我将花费的时间来构建它。浪费的时间应该是构建一个蹩脚的解决方案的时间。我花了几个小时来让自己推迟几个月(甚至几年)更多的工作时间。

看起来很傻，但是很多时候这个决定是做不出来的。所有的代码将被混合在一起，并建立在超过 100 年的基础上.替换的成本不仅仅是重写系统的一个部分所花费的时间(在这种情况下是净化)。替换的成本将是重写*年*的代码以提取杀毒代码，并确保在替换时不会破坏其他任何东西。通常情况下，这不是一个有意识的决定。事实上，这实际上是缺乏一个被考虑的决定。

技术债务通常是不可避免的，但有时做出有意识的决定来承担更多的技术债务是可取的。关键是确保技术债务的收益大于成本。这意味着要确保清理成本要么是固定的，要么增长非常非常缓慢。

在我看来，最有效的方法是花时间在高层次上思考问题。思考比编写代码并确保它能工作要快得多。通过在这个思考过程中避免走捷径并做出好的决策，一个人实际上能够承担更多的技术债务，而不会严重影响未来的开发速度。那笔债务只是碰巧被计划好了，而不是偶然发生的。