# “测试指导下的面向对象软件成长”笔记

> 原文:[https://dev . to/barryo sull/notes-from-growing-object-oriented-software-guided-by-tests](https://dev.to/barryosull/notes-from-growing-object-orientated-software-guided-by-tests)

下面是我在阅读了由测试引导的[面向对象软件后所做的笔记。我强烈推荐开发人员阅读这本书。编写测试很难，使用测试来编写好的代码更难。在你能把事情做对之前，要花很多时间和犯很多错误。](http://www.growing-object-oriented-software.com/)

嗯，上面的书解释了如何一步一步地做，我肯定是一个更好的开发人员，因为读过它。非常感谢代码向导借给我，你知道你是谁。

我把这些笔记贴在网上，因为它对我自己是一个有用的参考，希望对其他人也是。我试着把建议组合在一起，以便于阅读(对你和我来说)。

### [](#three-types-of-test)三种测试类型:

*   验收:端到端
*   集成:测试我们的代码可以与我们不控制的代码交互，例如外部 API 或库
*   单元:测试我们的对象做了正确的事情(它们容易使用吗)

### [](#starting-a-new-project)开始一个新项目

总是从零迭代开始，即行走的骨架。使用真实代码、库、数据存储、服务等获得端到端工作的单一特性..证明您的概念是可行的，它是可构建的、可测试的、可部署的，并且它提前强调了集成的痛点。

### [](#adding-features)添加功能:

从失败的验收测试开始，然后进入 TDD 循环，直到验收测试通过。重复一遍。

从最简单的成功案例开始你的验收测试。记录下未来的失败案例、重构和其他任务，让你专注于通过最简单的验收测试

写“a”失败测试，不要一次写完所有测试用例(适用于所有测试类型)。

### [](#testing-objects)检测对象

难以测试的对象很可能有糟糕的设计。这意味着它们很难理解和使用。

### [](#uncover-uncertainty)揭开不确定性

总是有端到端的测试，他们尽早暴露不确定性。

### [](#brownfield-projects-legacy-codebases)棕色地带项目(遗留代码库)

*   自动化构建和部署
*   为要更改的零件添加端到端测试
*   当你更新/修复代码库时，慢慢地构建测试覆盖范围(3 种类型，在适当的地方)

### TDD 循环

1.  编写失败的单元测试
2.  通过测试
3.  重构
4.  重复一遍。

### [](#a-better-tdd-loop)更好的 TDD 环路

1.  编写失败的单元测试
2.  清楚地报告错误
3.  通过测试
4.  重构
5.  重复一遍。

### [](#reporting-errors)报告错误

测试应该失败的信息。如果一次失败的测试不能帮助你找出问题所在，那么它只能帮助你一半。

### [](#oop-practices)OOP 实践

对象通过消息进行通信。消息/值应该是不可变的，对象可以有状态。

“封装数据”是“隐藏数据”的另一种说法。如果一个对象“隐藏数据”,它最好有一个好的理由。常数在错误的类中

不要用字符串，用域类型代替(ValueObjects)。

### [](#writing-tests)写作测试

将您的测试放在与代码不同的包中，这可以确保您测试的是外部 API。

测试行为，而不是方法。这意味着编写测试来显示你的对象是做什么的，而不是它的方法做什么。我们需要知道如何使用对象来实现一个目标，而不是如何孤立地使用对象方法。测试名应该描述特性，而不是方法。

在测试中，当一个论点无关紧要时，使用`null`。不过，让它成为一个命名的常量，这样代码更容易阅读。

保持代码编译。改变代码库(破坏它)和修复它之间的时间应该是最短的。你打开和运行的代码越多，你就有越多的东西需要保存在你的大脑中，这会减慢你的速度。

工作并不等同于完成。一定要在写完通过测试后马上重构你的代码，这是最好的时机，你已经有了所有的背景知识。

区分测试设置和行为断言，保持清晰。

设置代码应该清晰易懂，说明它在做什么，而不是怎么做。混乱的设置代码使得测试难以阅读，并且可能隐藏脆弱性。专注于表达你想做什么，而不是你计划如何去做

测试代码应该和它所测试的代码质量相同。

在测试中，不要模仿数值，而要使用真实的数值。如果它们构建起来很复杂，那么使用许多对象创建模式中的一种(例如，factory，builder ),并将其添加到您的测试代码库中。

当编写测试时，指定应该发生什么，不要更多。尝试删除对预期行为不重要的代码。

构建器非常适合创建对象，尤其是在测试中。使代码更容易阅读，并且可以重复使用。

构建器可以是构建器的参数，使得在保持代码整洁的同时更容易构建复杂的对象。

模拟对象可以被视为跟踪对象，当它们没有按预期使用时，它们会告诉您。

测试可读性和弹性最终往往会结合在一起。如果你的测试很难读懂，那么很有可能它们是脆弱的。

如果您在集成或验收测试中使用数据存储，请确保在安装时清空数据，而不是在拆卸时。如果测试中途出现崩溃，那么 teardown 永远不会被调用，并且您的系统处于不一致的状态。空白在安装期间，你永远不会有这个问题。

### [](#writing-a-test-what-order-should-i-do-it-in)写一个测试，应该按照什么顺序来做？

1.  编写测试名称
2.  编写对目标代码的调用
3.  写下主张/期望
4.  编写安装和拆卸程序

### 处理臃肿的构造函数:三种选择

1.  将依赖项打包到一个新概念中(将参数包装在一个对象中)
2.  将班级分成多个班级
3.  使用默认值(如果大多数构造函数参数都是值)

### [](#software-architecture)软件架构

没有什么比尝试实现一个设计更好的了。预先设计很好，但它永远不会一次就做好。

## [](#helpful-tips)有用的提示

使用`DefectException` s，这些是异常的一个子类型，只有当开发者做错事情时才会抛出。忘记设置环境变量。对于捕捉这种类型的错误非常方便，一旦你知道你在处理什么，它们通常很容易修复。

不要使用文字，给值取有意义的名字

命令会改变状态，而查询不会。永远记住 CQS(和 CQRS)。

就是这样，如果以上看起来有用或听起来真实，那么我会推荐你阅读整本书，因为只有我的笔记，它们并没有公正地对待这本书。说真的，去读吧，嘘。