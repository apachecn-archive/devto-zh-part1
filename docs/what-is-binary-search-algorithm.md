# 什么是二分搜索法算法？

> 原文：<https://dev.to/pablocortez/what-is-binary-search-algorithm>

二分搜索法是那些你会在每堂(好的)计算机科学导论课上遇到的算法之一。这是在有序列表中查找项目的有效算法。为了这个例子，我们假设这是一个数组。二分搜索法的目标是能够在每次迭代中丢弃数组的一半，最大限度地减少我们必须经历的元素数量，并给我们留下一个最终值。

以下面的整数数组为例:

```
int array[] = 
{ 
    1, 3, 4, 6, 7, 8, 10, 13, 14, 18, 19, 21, 24, 37, 40, 45, 71 
}; 
```

假设我们试图在这个数组中找到数字 7 的索引值。总共有 17 项，所以索引值从 0 到 16。从视觉上看，7 的索引值显然是 4，因为它是数组中的第五个元素。

但是对于计算机来说，找到我们要找的数字的索引值的最好方法是什么呢？首先，我们存储最小值和最大值，即 0 和 16。

```
int min = 0;
int max = 16; 
```

现在我们必须想出一个猜测。最聪明的做法是猜测数组中间的索引值。这个数组中有 17 项，所以索引值从 0 到 16。这个数组的中间索引值是 8，它包含数字 14。这个数字是第一个猜测。

```
// This will round down if the quotient is not an integer
int guess = (min + max) / 2; 
```

我们的猜测现在等于 8，也就是数组中的 14，因为数组[8]等于 14。

如果我们要找的数字是 14，我们就完了！由于情况并非如此，我们现在将丢弃数组的一半(14 之后的所有数字，即索引值 8，因为我们知道 14 大于 7，并且我们的猜测过高)。
第一次迭代后，我们现在的搜索范围是:1，3，4，6，7，8，10，13
我们不必在原数组的后半部分猜测，因为我们知道所有那些值都太大了。这就是为什么我们将二分搜索法应用于有序列表很重要。
由于我们最初猜测的 14 大于 7，我们现在将它减 1 并存储到 max:

```
max = guess - 1; // max is now equal to 7, which is 13 in the array 
```

现在搜索看起来像这样:

```
 1, 3, 4, 6, 7, 8, 10, 13

min = 0
max = 7
guess = 3 
```

因为我们的猜测太低，我们通过增加 min 来丢弃数组的下半部分，与我们之前对 max 所做的相反:

```
min = guess + 1; // min is now 4 
```

到下一次迭代时，我们只剩下:

```
 7, 8, 10, 13
min = 4
max = 7
guess = 5 
```

因为索引值 5 返回 8，我们现在比目标值多一个，所以我们再次重复这个过程，我们得到:

```
 7
min = 4
max = 4
guess = 4 
```

我们只剩下一个值，4，作为我们要寻找的目标数的索引，也就是 7。二分搜索法的目的是在每次迭代中去掉数组的一半，所以我们只处理那些继续猜测有意义的值。

该算法的伪代码如下所示:

*   设 min = 0，max = n(其中 n 是可能的最高索引值)
*   求最小值和最大值的平均值，向下舍入为整数。这是我们的猜测
*   如果我们猜对了号码，停，我们猜对了！
*   如果 guess 太低，将 min 设置为比 guess 多 1
*   如果猜测值太高，请将最大值设置为比猜测值小 1
*   回到第二步。