# 为什么我不喜欢特质

> 原文:[https://dev.to/barryosull/why-i-dont-like-traits](https://dev.to/barryosull/why-i-dont-like-traits)

PHP 中的特征是狗屎。在最好的情况下，它们是一种向类添加功能的无效方式，在最坏的情况下，它们是一种反模式。它们经常被用作内部功能的开关(参见 Laravel 的验收测试),或者作为一种在不使用另一种模式的情况下跨一堆类共享公共功能的懒惰方式。

# [](#why-are-they-shite)他们为什么是 shite？

## [](#reading)阅读:

它们很难读懂。如果你看到一个类使用了一个特征，你必须打开这个特征来看看它给这个类添加了什么。

通常 trait 使用类的受保护属性，这意味着您必须在 trait 和父类之间切换，以弄清楚属性的类型及其用途。

它也可以向另一个方向发展，你可以使用 traits 在一个类中添加或覆盖受保护的方法，然后从那个类中调用它们。现在你有了双向耦合，而不是单向耦合，这使得事情更加混乱。

## [](#extending)延伸:

在 traits 中使用受保护的属性/方法的另一个问题。您已经将类的内部耦合到了另一个很可能在别处使用的对象(trait)。这意味着一个类的内部是与另一个类的内部绑定在一起的，如果一个类改变了，另一个类也必须改变。

像这样的耦合问题是不可避免的，但是其他模式使这种耦合显式化(例如工厂/策略模式)，而在 traits 中这是隐式的。

简而言之，它鼓励一种懒惰的设计，这种设计暴露并依赖于瞬态内部，打破了封装的概念。

## [](#cant-test-in-isolation)不能孤立地测试:

我的一只大虫熊，通常你不能孤立地测试特征。如果你想单独测试这个特性，你必须创建一个使用它的类。

根据定义，这不是孤立。如果 trait 只用于添加受保护的方法，那么您真的没有办法确保它的行为符合预期(在这种情况下，您应该使用 factory/strategy 模式，而不是 trait)。

## [](#not-using-private-or-protected-properties)不使用私有或受保护的财产:

以上假设您通过访问受保护的属性或添加受保护的方法来添加行为。如果你两样都没做呢？

在这种情况下，您只使用对象的公共接口，这意味着您可以通过创建一个函数/对象并将该对象作为参数传递来获得相同的行为。好看又简单，更有表现力，更容易理解。

# [](#how-to-work-around-it)如何解决？

好吧，如果你使用带有受保护属性/方法的特征，很明显还有另一个中间对象没有被表达出来。我举个例子。

我们使用一个特征向两个类添加两个受保护的方法。这意味着这两个类都引用了两个它们没有实现的受保护的方法，而 trait 实现了。

trait 函数也使用父类的受保护属性(服务)来完成它们的工作。我对此并不满意，因为这使得代码更难阅读，并且迫使特征和它的所有用户之间存在紧密的双向耦合。

因此，我们将每个受保护的函数转换成自己的类，将服务作为构造函数参数。受保护的函数没有改变状态，它们只是创建了一个对象，所以类变成了工厂。

然后，这些工厂类被注入到每个对象的构造函数中并在内部使用，它们的服务依赖关系在过程中被自动注入。然后，该类在所有使用原始受保护方法的地方都使用这些对象。

结果相当不错(双关语)，我们的代码更容易阅读、扩展和单独测试。

因此，总之，特征打破了 OOP 的原则，它们将内部耦合到不同的对象上，使得理解到底发生了什么和改变你的代码变得更加困难。

**TL；特征是狗屎，用其他模式代替。**