# IG 公共宣传短片-经验教训

> 原文:[https://dev.to/rmorschel/ig-public-api——吸取的教训](https://dev.to/rmorschel/ig-public-api---lessons-learned)

我们中的一些人在大约 6 个月的时间里构建了 IG 公共 API，这是一个我们都非常自豪的壮举。

但是犯了错误，吸取了教训，但不幸的是为时已晚。

这是我希望我们做的不同。

## [](#to-gateway-or-not)要网关还是不要？

我们评估了许多 API 网关产品(Apigee、Layer7 和 WS02)，但决定构建自己的产品。理由是:

1.  我们的交易 API 对延迟很敏感。最快的产品(WSO2)增加了 3ms，这听起来可能不多，但在交易中，即使是在线交易，也是如此。
2.  我们的后端 API 已经是 REST，所以网关提供的所有漂亮的 ESB 类型的集成功能我们都不感兴趣。
3.  我们已经解决了安全问题，所以不需要 OAuth(无论如何，OAuth 打开时，延迟增加到 50 毫秒左右！)
4.  门户网站的规范性太强，不符合我们的喜好——我们希望我们的门户网站有很强的 IG 品牌和定制化，而不仅仅是“贴着白色标签”。

因此，我们在现有的内部 REST APIs 的基础上构建了一个瘦 API 适配器框架，除了从源代码添加基本的 API 密钥安全性、转换和文档生成之外，没有做更多的工作。

事实证明，我们的安全解决方案是不充分的，我们确实需要 OAuth。我们最终使用了 OpenAM(顺便说一下，这是一个优秀的免费开源安全平台)。

我们在自己的门户网站上投入了太多的时间，但在我看来，最终的结果是提供了不合标准的服务。最好是对 80%的第三方产品感到满意，并最终得到一个更加完美的整体产品。

我们当时使用 IG 的 RESTdoclet 来生成我们的 API 文档，但是应该使用 Swagger(我们随后在内部使用了它)。许多网关支持 Swagger。

话虽如此，但在生成文档之前要仔细考虑。如果您将文档放在源代码中，请确保它被清楚地标记为将在 web 上可见的内容，并接受熟练的内容作者的严格审查。不要假设开发人员知道如何编写内容。他们通常不会。

我们现在正在考虑将适配器层移到一个单独的，我们该怎么说呢...呃...盖特。不，我不能说。

## [](#not-so-restful)不安宁

我喜欢休息。它提供了一个非常简单的 API 模型，普通玩家很容易掌握。在犯下以下错误之前，我们做了大量的研究:

#### [](#modeling-using-uri)使用 URI 建模

在这里，我们试图变得更聪明，并对反映我们的域资源分类的 URI 层次结构进行建模。不幸的是，这个模型对于一个简单的资源树来说太复杂了，在某些情况下，我们最终得到了一个丑陋的 URIs 集。

#### [](#using-http-delete)使用 HTTP 删除

在财务系统中，真正删除东西的机会通常很少——最多是将东西标记为已删除。所以这更像是更新(上传)而不是删除。但是我们坚持了下来，并且发现了两种可以使用 DELETE 的情况:

*   logout: DELETE /session(参数是登录只是创建(POST)一个会话，注销是删除会话。)直观如砖。

*   平仓:这里的问题是，仓位也可以部分平仓。所以我们想，没问题，只要把数据放在请求体中就行了。这是一个坏消息，没有得到广泛的支持，所以我们最终使用了 PUT(正如我们应该做的那样)。

我们仍然有 DELETE /session 来注销，但是没有人使用它。这很痛。

#### [](#using-http-status-codes)使用 HTTP 状态码

这在当时看起来非常简单。200 代表成功。400 错误范围意味着客户端需要修复一些东西。500 错误范围意味着服务器必须修复某些东西。

对此的许多反对意见是宗教性的，有些人认为 HTTP 状态码从来就不是为 API 设计的，应该只使用 200。好吧，好吧，但是你必须处理 401 和 403 安全错误，那么为什么不用 404(未找到)处理查找错误，用 400(错误请求)处理验证错误呢？和 500 范围的系统误差？

当您试图在响应正文中返回错误细节时，这一切都不攻自破。例如，我们的 CDN (Akamai)很高兴地用自己的错误信息替换了我们的自定义 500 错误信息。

所以最后我们停止使用 500 个消息响应体，这是一个遗憾。这里的一个好模式是为记录的系统错误生成一个内部 GUID，然后将它返回给调用者，这样他们在给支持人员打电话时就有话可说了。

#### [](#using-headers-to-version)使用标题来版本

我们不想让我们漂亮的 URIs 与版本混杂在一起，所以我们把 API 版本放在头中，并在“操作”级别应用它，即 URI + HTTP 方法。

我可以详细讨论版本控制，但是我会把它留到以后的文章中。总之，我认为 API 版本应该如下:

URI 开头的版本号。

*   非重大变更(无版本号变更)
*   重大变更(版本号变更)

## [](#to-b2c-or-b2b)要 B2C 还是 B2B？

“敏捷”意味着我们有时会忘记在开始削减代码之前彻底考虑事情。我们没有考虑清楚谁会使用我们的 API。我们认为:休息是容易的，所以我们的客户将最终能够自动化他们的交易。他们会来交易的...刻线！

许多人做了，但许多人挣扎着，许多人甚至没有交易:他们只是得到了我们的免费(即没有刻线！)市场价格。但是我们接到了很多支持电话，从 bug(这很酷)到“你能告诉我如何写一个程序吗？”(这可以理解，但令人恼火。我很想发一个我大学学位课程的链接)。

在某种意义上，我不后悔向大众开放 API，因为这确实考验了我们的 API，但 API 的超级用户最终构建了应用程序(在他们雇佣的开发人员的帮助下)——这正是我们的 B2B 模式，也是我的拙见。

但是我们花了这么多时间来支持投注者，这是不划算的。

我们犯了“建造它并希望他们来”的错误，没有考虑谁会来，谁应该来。