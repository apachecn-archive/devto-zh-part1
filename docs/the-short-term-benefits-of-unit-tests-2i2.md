# 单元测试的短期好处

> 原文：<https://dev.to/pbeekums/the-short-term-benefits-of-unit-tests-2i2>

许多开发人员对单元测试有两种看法:他们认为 100%的代码必须被单元测试覆盖，或者他们认为 100%的代码必须被单元测试覆盖，但是他们有理由不写任何代码。

[![](img/dd1a29d30fce00114bb604b98f6777b8.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--MKNbwZwT--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://blog.professorbeekums.com/img/2017/12/code.jpg)

发现有人不喜欢单元测试的想法并不常见。进行单元测试的主要成本是花费时间来编写它们。好处是突出的。假设我花了 5 个小时为一段代码编写了 50 个单元测试，而手工测试需要 1 个小时。花 5 个小时省下 1 个小时的工作，好像不太好。

然而，这些单元测试将在几秒钟内运行。编写它们的前期成本有点高，但是每次开发人员不得不重新编写代码时，他们可以节省一个小时。时间投资的收支平衡是必须返回代码 5 次，这在很长一段时间内是相当低的。

还有一个好处是，代码库中的新开发人员要么不知道如何正确地测试它，要么会在知识转移中耗费其他开发人员的大量时间。要么是新开发人员很有可能在修复代码中的旧错误的同时制造新的错误。单元测试防止这种情况发生。

问题是这些好处通常是长期的。很难说从长远来看单元测试不会节省时间，但是由于短期内的时间压力，许多开发人员会选择不编写单元测试。我已经记不清有多少次我说过“我们将在这个版本之后编写单元测试……”然而在每个版本开始下一个版本的开发之后。很少有停机时间回去写单元测试。

尽管我发现单元测试确实有一些短期的好处。诀窍是识别什么时候使用单元测试比不使用单元测试更快地完成一项任务。最好的例子就是数学难题。任何类似推荐引擎、物理公式或图像处理的东西都可以放在这里。还有其他例子，如处理电子表格、净化 HTML 内容、管理复杂的用户权限等。

所有这些例子的共同点是它们都有很多测试用例。要手动测试它们中的任何一个，都需要执行十几个或更多的操作来捕获每个案例。一些人甚至可能有比一个人能够立刻记住的更多的测试用例。结果是测试用例很可能在开发人员的测试中被遗漏。也许那个 bug 是在 QA 中发现的，这浪费了一点时间。也许那个 bug 被发布了，用户发现了它。那就差多了。

开发人员可以通过写下每个测试用例来解决这个问题。但是花了多少时间去浏览它们呢？一个开发者会经历多少次呢？我们经常在开发完成后对软件中的 bug 给予很多关注，但是有很多 bug 是在开发过程中出现的。对于复杂的东西，开发人员可能需要调整他们的代码几十次。即使只需要花 5 分钟来完成列表中的每个测试用例，这也会增加初始开发的时间。数小时冗长乏味的测试。

从长远来看，我们现在没有考虑节省大量时间。今天我们来看看如何节省时间。

一些开发人员将开始编写小脚本来自动完成一些测试。我以前做过很多次了。但是单元测试只是这些脚本的另一种形式。一个更可靠的。如果我们要花时间写我们要扔掉的脚本，为什么不花时间做单元测试呢？

单元测试的另一个短期好处是技术债务。通常没有单元测试被认为是技术债务。然而，单元测试可以让你承担更多的技术债务。

为了理解这一点，我们应该看看时间花在软件开发的什么地方。对于任何复杂的东西，实际上只有很少一部分用于输入代码。大部分是:

1.  提前弄清楚代码应该如何工作
2.  找出测试代码的所有方法
3.  用代码修复所有(初始开发)错误

当开发人员时间紧迫时，他们会使用 Chunk 1 作为捷径。他们把一些东西拼凑在一起，然后让它工作。它可能并不漂亮或有效，但它确实有效。判断它是否有效的唯一方法是不要走第 2 和第 3 块的捷径。

组块 2 和 3 的很大一部分可以通过单元测试来加速。如果开发人员在代码的初始开发中走捷径，单元测试可以显著减少清理这些捷径所花费的时间，因为他们不必重复第 2 和第 3 部分中所做的所有工作。

这听起来像是一个长期的好处，但是有了单元测试的安全网意味着可以有意地、安全地走捷径。由于单元测试，清理技术债务的成本将显著降低，因此可以承担更多的技术债务。这在短期内是一个巨大的福音。