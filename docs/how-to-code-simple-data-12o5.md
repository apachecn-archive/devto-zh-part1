# 如何编码:简单数据

> 原文：<https://dev.to/monicaleep/how-to-code-simple-data-12o5>

嗯，我一直有点懒的更新，但在过去的两个星期里，我已经完成了 edx 上的 HtC: SD 的全部。

<figure>[![](img/98c95f3f3c9473bec50cabe35fbf48fb.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--DKRhqjBW--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/374/1%2AyUq5MZGEfMybrHqcxhtxGA.png) 

<figcaption>入侵！</figcaption>

</figure>

我将从上一篇文章中停止的地方继续:第 4 周集中在自我参照和参照上。自引用意味着当一个数据定义引用它自己时，那么这个函数的模板必须包含一个“自然递归”我们使用的自引用数据的主要类型是列表(记住 car 和 cdr)，其中列表可以是空的，也可以是一对条目，第二个条目是另一个列表。因此，自然地，为了处理这种类型的数据，我们需要一些递归函数。我学过一点递归(非常小的一点)，但是我喜欢用这种方法来教它。用递归解决问题可能有点棘手，这就是为什么“格式良好的”测试将有助于您的开发。

引用(与自引用相对)是指当一种数据类型包含另一种非原语数据类型时。例如，一个熊的列表，每个项目可以是一个熊(也可以是一些其他的结构)。关键是，如果我们引用一个非原始数据类型，我们需要在新模板中包含对该数据类型模板的引用。这并没有听起来那么令人困惑。如果你有一个 x，y 对的列表，并且你想调整列表中的每一个点，你需要一个对单个点本身起作用的函数。这有助于 Helpers 模块。

简单地说，一个助手函数只完成函数的一小部分。可以使用 helpers 进行函数合成(还记得 JS 阿朗奇吗？)或者“知识领域”发生变化的时候。对于大型或复杂的问题，可能需要很多很多的助手。助手函数使得调试和跟踪信息流更加容易。

该课程还涉及到二分搜索法树，这是模模糊糊熟悉的形式 CS50(虽然我相信这只是二分搜索法，搜索树/尝试是分开的)。老实说，我在这些问题上有些纠结，问题集中的一些问题欺骗了我(部分原因是误解了问题陈述)

《太空入侵者》课程的最后一个项目是一个结合我所学一切的有趣机会。很多辅助功能，测试驱动的设计，把一个问题分解成子问题。我为我的小小成绩感到骄傲。代码在 github 的某个地方，但是我不打算贴出来，因为可能你还没有完成课程！

我强烈推荐这门课，它不是最有挑战性的(就像 CS50 对我来说一样)，但是它教授了很多在 CS 中广泛适用的课程。后续的《HtC:复杂数据》应该会更难！我们走吧！