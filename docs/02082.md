# mruby 的 JIT ver2 的构想

> 原文:[https://dev.to/miura1729/mrubyjit-ver2-7fi](https://dev.to/miura1729/mrubyjit-ver2-7fi)

# 前言

[制作的是 mruby 的 JIT](https://github.com/miura1729/mruby/) 。 这是在[mruby](https://github.com/mruby/mruby) 中添加了 JIT 编译器。 [虽然取得了一定的成果](https://qiita.com/miura1729/items/a1828849ec8fec596e74)，但也出现了各种各样的问题。 本来，工作是第一目标，选择了尽可能安全的安装，所以再扩大下去也感觉很困难。

有这样的问题。 考虑解决这种问题的新版本。

## 多线程

当然，我完全没有考虑多线程。 虽然没有违背 mruby 的设计思想而使用全局变量，但是生成的代码区域不是全局排他控制的，所以不支持多线程。 因此，实际上不可能在 H2O 上使用。

## 内存效率

为了保存编译时的类型信息和返回 VM 时的寄存器信息等 mruby 的 JIT 所需的数据，使用了存储器，但这是不加考虑就设计在 ad-hoc 上的，因此浪费非常多。 读了 luajit 的代码，我意识到可以设计更高效的数据结构。

## [](#%E7%A7%BB%E6%A4%8D%E6%80%A7)portability

最初，mruby 的 JIT 开发为只在 x86 32bit 下工作。 之后，虽然也变更为在 x64 上工作，但是完全没有考虑在 arm 上的动作等。

## 浪费代码区域

mruby 的 JIT 可能通过代码的自我改写来应对方法的重新定义等动态性质。 但是，由于自我改写而无效的代码区域就这样什么都不使用，就这样。 希望对代码区域进行 GC，但以目前的结构是不可能的。

# 多线程

这里所说的多线程有三种含义。 一个是 mruby 的实例通过准备多个 mrb 而存在多个，各自进行多线程工作的情况。 由于 H2O 在该状态下运行，因此为了应对 H2O，需要能够以该形式运行。 第二，在编译器中并行工作。 例如，在后台进行编译就属于这种情况。 第三，编译的代码可以多线程或并行工作。 虽然 mruby 标准上不支持多线程，但存在可以编译为多线程或并行执行的表达式。