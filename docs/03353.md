# 伐木的艺术

> 原文:[https://dev.to/jvz/the-art-of-logging-1dh1](https://dev.to/jvz/the-art-of-logging-1dh1)

所有开发人员都试图通过将生命周期和状态信息打印到控制台来调试他们的程序。这个概念，有时被称为 *printf debugging* ，可能是一个比人们最初预期的更强大的工具。这种调试技术的本质是*日志*的概念，开发人员将关于运行程序状态的相关信息添加到日志中。日志记录的使用对于开发人员和操作人员来说都是至关重要的，从这两个角度理解如何以及为什么使用日志记录是非常重要的。

## 测井基础知识

然而，日志不仅仅是打印到`stderr`。典型的日志记录系统分为一组日志记录级别，这些级别通常定义日志事件的受众和语义。例如，在 [Apache Log4j 2](https://logging.apache.org/log4j/2.x/) 中，日志记录级别分为以下几组:

*   *Fatal* :错误信息，表示某个子系统或整个程序无法继续执行，将终止。
*   *错误*:关于应该由人工处理的问题的错误消息。这些通常有助于操作员提高警惕。
*   *Warn* :关于潜在问题的警告消息，可能需要人工处理。结果，这个级别经常被误用和忽略。
*   *Info* :关于程序状态的信息性消息。这些类型的消息往往与程序的生命周期相关，并且可以被视为调试程序的宏状态的一种方式。
*   *Debug* :程序内部状态的调试信息。这些消息通常只对维护程序的开发人员有帮助。
*   *Trace* :跟踪程序执行流程的消息。这些消息通常级别很低，只是反映了程序的微观状态，通常不会比调试器提供更多的信息。

一些日志记录系统定义了其他级别，但是大多数日志记录系统将其日志消息分类到具有类似用例的类似桶中。每个级别都可以有选择地启用或禁用，尽管通常禁用一个级别也会禁用其下的所有级别。例如，如果我们使用设置为`WARN`的日志配置作为它的级别，那么只有警告、错误和致命消息会被显示。

通过简单地将严重性信息添加到日志消息中，我们已经超越了`printf`所提供的功能，但是我们仅仅触及了表面。任何给定的程序通常都足够大，可以由某种模块或子系统的概念组成，因此将这种可配置的灵活性扩展到子系统似乎也是有用的。在 Java 程序中，这些往往被包和类分开，尽管这里使用的重要概念是命名日志记录器。通过命名程序中使用的日志程序，每个子系统都可以独立配置为只输出所需的日志。例如，假设第三方库误用了警告级别，导致操作人员担心应用程序的健康状况。在验证了记录器名称前缀`com.example.subsystem`下的每个警告日志消息都不是真正的警告之后，我们可以专门为该组记录器使用更高级别的阈值，而不必全局禁用警告或修改第三方库的源代码。这也与记录器名称形成层次结构的想法有关；`com.example`是`com.example.subsystem`的母公司。这允许以更简单的方式在一个设置中配置整个子系统。

在这一点上，我们使用级别和名称对日志事件过滤进行了相当强大的抽象，但是我们可以做得更好！日志事件可以附加一个额外的元数据:*标记*。标记是一个简单的文本字符串，用来标记特定日志消息的某种横切关注点。这可以用来帮助将特定的日志消息路由到不同的日志记录系统。例如，假设日志消息用`ALERT`标记。日志配置可以有一个针对该标记的过滤器，该过滤器会将这些消息路由到特定的目的地，而不管级别或记录器名称。这可能是 Slack 中的提醒频道或提醒邮件列表。

在一些编程语言(如 Java)中，字符串操作被认为是一种低级操作，因此这里没有提供某些对日志记录有用的字符串模板特性。例如，记录包含来自某些局部变量的值的消息通常需要字符串连接，如果该日志消息从未显示，则所述连接是浪费 CPU 工作。像这样的小事随着时间的推移会累积起来，形成显著的性能开销，因此我们肯定可以做得更好！输入参数化的日志消息，这在本质上与参数化的 SQL 查询非常相似。在 Log4j 和许多其他日志记录系统中，参数由日志消息中的`{}`占位符指定，并作为附加参数提供给日志记录方法。比如:

```
logger.debug("User {} logged in", user.getName()); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

占位符仅在启用调试日志记录时填充，因此除非绝对必要，否则不会计算完整的字符串。这项技术主要与 Java 等语言相关。例如，在 Log4j 的 Scala 版本中，字符串模板是该语言的一个内置特性，当日志记录被禁用时，在后台使用宏来避免模板渲染。示例:

```
logger.debug(s"User ${user.getName} logged in") 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

另一个相关的 API 是可以提供一个 lambda 函数来代替一个字符串，以便在启用时推迟一些组装日志消息所需的代码。例如，假设我们希望为一些调试日志消息从数据库中获取一些额外的元数据。这种开销在大多数情况下可能是不可接受的，但是我们可能希望偶尔有选择地启用它。函数的整个主体可以封装到一个 lambda 函数中，并传递给记录器。这通常比用`if`检查相关的日志级别或其他嘈杂的技术包围代码更干净。

从开发人员的角度来看，关于如何使用日志 API，还有更多的特性，但是这些特性大多是关于重复性内容的便利特性，比如总是包含在日志消息中的线程本地信息，或者结构化日志消息、通用事件日志等等。关于这些特性的更多信息可以在 [Log4j 手册](https://logging.apache.org/log4j/2.x/manual/api.html)中找到。

## 日志事件去哪了？

现在我们已经建立了一个编写和过滤日志事件的通用框架，我们可以用它们做什么呢？处理日志事件的最简单的实现是将每个日志消息打印到控制台，用新行分隔。因为这样做会丢失相当多的上下文，所以我们通常包括来自日志事件的附加信息，例如时间戳、日志级别、标记(如果定义了的话)、记录器名称和多线程程序的线程名称。我们希望输出的所有字段都应该是可配置的，事实上，我们可以添加几个不同的字段来提供关于日志消息的上下文。输出格式也可以使用结构化格式，比如 JSON，它比面向行的日志消息更容易解析，尽管所有日志聚合和搜索工具都有强大的工具可以从各种格式中提取日志事件信息。

在某些用例中，将日志事件写入`stderr`是可以接受的。例如，在程序开发期间，开发人员可能希望在控制台中运行程序的同时查看日志事件。另一方面，也许你正在使用一个编排框架，比如 [Apache Mesos](https://mesos.apache.org/) 来执行你所有的应用程序。这样一个框架可以被配置为监视所有正在运行的应用程序的`stderr`流，以便将日志消息收集到一个中心位置。

然而，对于许多用例来说，简单地打印到没人看的控制台不是有效的策略。任何需要合理的 SLA 并且拥有几百个以上用户的网站，通常需要多台服务器来分配负载。随着节点数量的增加，监视控制台变得不可行。事实上，每个节点可能执行多个应用程序，所以如果没有像 [tmux](https://github.com/tmux/tmux/wiki) 这样的程序，我们无论如何都必须将每个程序的`stderr`重定向到一个文件。考虑到这一点，我们可以直接配置日志框架，将日志事件输出到一个文件中，而不是输出到`stderr`中。可以使用诸如`tail`之类的程序来监控每个文件，以持续观察添加到文件中的新日志事件。这种日志风格在典型的 GNU/Linux 和 BSD 系统中非常普遍，在这些系统中，许多正在运行的服务会将日志信息输出到`/var/log/`目录中。但是，如果没有配置为定期轮换日志文件并删除旧文件，那么服务器的磁盘空间最终会被日志信息填满！这项工作通常由诸如 [logrotate](https://github.com/logrotate/logrotate) 之类的程序来完成，尽管 Log4j 有一个[滚动文件附加器](https://logging.apache.org/log4j/2.x/manual/appenders.html#RollingRandomAccessFileAppender)提供类似的功能。

简单地输出到日志文件对于仍然停留在“手工操作”思维模式的操作员来说是一个好策略，但是我们可以做得更好！我们在这里的主要目标应该是将所有服务器上的日志收集到一个集中的、可搜索的位置。实现这一点的一种方法是使用诸如[麋鹿](https://www.elastic.co/)、[弗鲁恩德](https://www.fluentd.org/)或[格雷洛](https://www.graylog.org/)这样的产品。这些工具不仅仅提供日志聚合；它们提供了基于日志内容的过滤、排序、搜索和警报方法。然而，通过依赖日志文件，我们也依赖于单个服务器的稳定性。在灾难场景中获取日志通常更困难，但也更重要，因此让我们改进这一点。

Apache Flume 是一个在分布式计算环境中收集和聚合大量日志事件的项目。这在集群场景中非常有用，例如运行数十或数百个 Apache Hadoop 或 Apache Spark 节点。单个节点可以将日志事件传递给 Flume 代理，每个代理负责将日志事件可靠地传递到其他地方。与 [Flume appender](https://logging.apache.org/log4j/2.x/manual/appenders.html#FlumeAppender) 结合使用，可以在分布式环境中轻松地将所有日志事件收集到一个中央日志聚合器中。所述聚合器可能是复杂的，比如 Logstash 或 Graylog，或者可能是简单的，比如单个主日志文件。

现在，我们将日志都放在一个地方，我们可以真正加快操作游戏了。我们可以根据日志级别阈值、消息数量、消息频率以及其中包含的任何元数据来设置警报。如果我们想变得真正有趣，我们可以通过 [Spark](https://spark.apache.org/mllib/) 或 [Apache Mahout](https://mahout.apache.org/) 结合任何其他导出的度量数据来训练一些机器学习模型，以尝试预测我们服务的失败。这种技术也可以用于集群和微服务的各种可观测性。通过与脚本相结合来自动扩展或重启服务，运营部门可以更加主动地维护他们的系统。

还有许多框架、库和工具可以在这里介绍。日志记录是所有开发人员都要做的事情，不管他们是否使用了合适的工具，所以熟悉这些工具和概念是一个很好的主意，这样可以改进应用程序创建的元数据。开发人员应该与操作人员(devops)密切合作，以便在日志冗长性和可观察性之间找到一个良好的平衡。管理日志是一个复杂的话题，很多人都容易忽略，但是拥有一个好的日志架构可以帮助在生产问题期间化险为夷。最后，对于使用 Java 平台的人来说，Apache Log4j 2 是 Java、Scala、Groovy、Kotlin 和任何其他 JVM 语言的首要日志库。日志记录给应用程序增加明显的开销是很常见的，典型的解决方案是简单地禁用日志记录，但是这首先就消除了日志记录的所有优点！相反，看一看[数字](https://logging.apache.org/log4j/2.x/performance.html)，看看 Log4j 是如何以非常小的开销使用的，即使是在高频交易应用中。