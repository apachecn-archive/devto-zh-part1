# 未初始化的变量 anathema:不确定的 C++

> 原文:[https://dev . to/mortoray/the-initialized-variable-anathema-non-deterministic-c-71a](https://dev.to/mortoray/the-uninitialized-variable-anathema-non-deterministic-c-71a)

具有未定义值的变量是可怕的语言错误。尤其是当程序无论如何都会工作的时候。允许这种容易创建而难以检测的情况是 C++的一个重大错误。我最近因为我的 [Leaf](http://leaflang.org/) 项目而被如此疯狂地对待。各种未初始化的结构值使我的程序在不同的平台上失败。没有必要这样做:所有变量都应该有保证的初始值。

## [](#the-problem)问题

局部变量、成员变量和某些结构分配会导致未初始化的值。C++有未初始化、默认初始化和零初始化的规则。这是一个过于复杂的烂摊子。

考虑到变量在 C++中不初始化的频率，这似乎很容易发现。它不是。虽然语言声明它们是未初始化的，但是大量的变量最终都是零值。考虑下面的程序。

```
#include <iostream>

int main() {
    bool a;
    if( a ) {
        std::cout << "True" << std::endl;
    } else {
        std::cout << "False" << std::endl;
    }

    int b;
    std::cout << b << std::endl;
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

对我来说，它总是打印出`False`和`0`。它在 [ideone](http://ideone.com/FykcMq) 上打印相同的内容。然而根据标准，它可以打印`True`和任何它想要的整数值。`a`和`b`都没有初始化。像`valgrind`这样的工具可以在这种情况下指出问题。

这是因为这样的程序往往会工作，使问题变得阴险。在展开时，误差可能不会出现，因为零恰好是所需的初始值。一个测试套件只有在不同的平台上运行时才能发现这个错误。在一些项目中，我已经将`valgrind`作为常规测试的一部分，但我认为这很少见，即使这样我也没有将其作为自动化测试套件的一部分(太多的误报)。

> 令人困惑的是，尽管所有类型都是缺省初始化的，但这对于基础来说毫无意义。至少一个类会调用默认的构造函数，从而产生一个可用的实例。一个基本面的“默认初始值设定项”什么都不是，而不是明智的“零初始值设定项”。这种二分法造成了一种情况，即对于某种类型的`T`，无法判断`T a;`是已初始化的变量还是未初始化的变量。快速浏览代码总是“看起来”正确，即使有时是错误的。

## [](#why-zero)为什么为零

但是为什么总是趋向于零呢？不初始化内存有点讽刺，因为操作系统不会给程序未初始化的内存。这是一种安全机制。系统上的底层内存是共享的受保护资源。程序 A 写入一个页面，释放它，然后程序 B 碰巧被分配了同一个页面。程序 B 应该不能读取程序 A 写入内存的内容。为了防止信息泄露，内核初始化所有内存。在 Linux 上，它恰好用零来做这件事。

没有理由非得这样做。我相信 OpenBSD 使用了不同的初始值。显然，运行在 VirtualBox 中的 ArchLinux 也做了一些不同的事情(这是 Leaf 失败的地方)。它甚至可能不是操作系统；该程序还可以获得它以前分配的内存。在这种情况下，没有什么会使这个内存归零，因为它在同一个程序中。

> 显然，OpenBSD 的基本 free/malloc 会在每次分配时重新初始化数据。这是一种安全特性，可以减轻缓冲区溢出的负面影响。奇怪的是，它[可能已经防止了心脏出血缺陷](http://www.tedunangst.com/flak/post/heartbleed-vs-mallocconf)，但是 OpenSSL 无论如何都绕过了那个机制。

## [](#the-solution)解

一种语言不应该允许未初始化的变量。我并不是说一定要给出一个明确的值，但是语言应该保证这个值。C++应该声明所有的变量都是缺省初始化的，这反过来意味着基本面初始化为零。我是如何创建变量的，它驻留在哪个范围内，或者它是否是一个成员变量，这些都不重要。

可能会有一些性能或低级数据操作的例外。然而，这些都是外围情况。大多数情况下，优化器可以处理未使用值的基本情况，并消除它们。如果我们想要一个未初始化的内存块，我们总是可以自己分配它，在这种情况下，我不希望数据被初始化，因此不会陷入陷阱。

为了完整起见，一种语言可能会提供一个特殊的`noinit`关键字来表示一个变量不应该被初始化。

我甚至觉得这个现在应该用 C++修改了。因为这些值以前是未定义的，现在定义它们不会改变任何现有程序的正确性。它是完全向后兼容的，并将显著提高 C++的质量。