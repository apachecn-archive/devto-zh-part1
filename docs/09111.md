# 记录事物的重要性

> 原文:[https://dev . to/mikulskibartosz/the-importance-of-documentation-things](https://dev.to/mikulskibartosz/the-importance-of-documenting-things)

几周前，一位同事问我写的一段代码。

不幸的是，我无法回答他的任何问题。

## 什么问题？

代码是可用的，我们可以称之为“自记录代码”,有有意义的函数和变量名，我没有使用任何聪明的技巧，有测试。我认为断言和测试名是可读的，可以用来判断我写代码是为了完成什么。

但这还不够。

## 代码

有问题的代码是一个 actor(如果您不知道它是什么，请阅读关于 [actor 系统](https://en.wikipedia.org/wiki/Actor_model))。

让我解释一下为什么会有问题。

*   我在演员名字中用了“同步”这个词，演员是同步的。一个演员从不同时表演两个动作。您可以创建同一个 actor 的多个实例，或者使用 actor 在不同的线程中开始处理一些事情，但是一个 actor 一次只能做一件事情。那么，我为什么称之为“同步”呢？

*   演员正在创建一个 JSON 对象并发送一个 HTTP 请求，没什么特别的
    为什么我需要一个单独的演员实现来做这样的事情？它有什么特别之处？

*   它使用的是非阻塞 HTTP 客户端
    它不需要等待响应。即使上一个请求尚未完成，参与者也可以开始发送另一个请求。

*   actor 的行为依赖于之前处理的消息
    在 Akka(可能还有其他 actor 系统)中，有一些成为/不成为方法，允许你根据接收到的消息改变 actor 的实现。

我的演员表现出两种不同的方式:

*   当它接收到一个消息时，它发送一个 HTTP 请求，并切换到一种状态，在这种状态下，它只等待 HTTP 响应，而不能处理新的消息。
*   当它收到 HTTP 响应(或错误)时，会处理响应并返回到接受新消息的状态。

## 为什么这是个问题？

没有什么能解释它的原因。没有解释我为什么写代码的注释。文档中没有提到。当同事问我这件事时，我无法解释，因为我已经忘记了一切。

似乎我无缘无故地严重过度设计了代码。我试图阻止 actor 同时向服务器发送太多的请求。在这种情况下,“太多”意味着不止一个。这是显而易见的部分。

## 为什么？

为什么服务器不能处理更多的消息？是有真正的原因还是我太小心了？
我不知道。

## 打破事物

我们可以假设有一个合理的理由来保存代码，并且不去碰它。我们可能害怕移除它，因为“某些东西可能会刹车，而这将是我们的错”。幸运的是，我们知道只需点击一个按钮就可以恢复服务的先前版本。

没有理由保留代码，没有人知道它为什么在那里，因此我们删除了它，什么也没发生。

我绝对相信在我写这段代码的时候，是有原因的。现在我知道我们不再需要它了。或者，也许我们有？也许有一天某样东西会因为那个改变而失败。

如果发生这种情况，我们将恢复旧的解决方案并适当地记录下来。就目前而言，我们没有理由保留它，也没有理由在每次阅读不必要的代码时浪费我们的时间。

## 为什么需要注释？

它不应该发生，我不应该需要用软件来实验，以检查为什么代码存在。决策应记录在案。我们可以开始写评论了吗？

注释不应该解释你的代码在做什么或者它是如何做的。你有相关的代码和测试。

我在评论中需要的是为什么我不应该删除这段代码的解释。如果你做了一个影响应用程序架构的决定，请在评论中告诉我。如果你在写代码之前尝试了一些不同的方法，请告诉我。所以我不会浪费时间去想“也许我们应该用不同的方式去做”。

我希望我会记得这件事

这篇文章是从 [mikulskibartosz.name](https://mikulskibartosz.name/the-importance-of-documenting-things-5d989b2797ba#.nu8yoavjn) 交叉发布的