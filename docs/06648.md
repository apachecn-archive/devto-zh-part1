# 什么是抽象？

> 原文:[https://dev.to/ericnormand/what-is-an-abstraction](https://dev.to/ericnormand/what-is-an-abstraction)

对于我们在这个领域中经常使用的一个术语来说，很少有关于抽象的定义。当我给我的演讲叫做 [*构建可组合抽象*](https://www.youtube.com/watch?v=jJIUoaIvD20) 时，那是一个持续的问题:我所说的*抽象*是什么意思？我将会在这个网站和口头讨论中大量谈论抽象概念。我想知道我在说什么*关于*。我不想寻找一个精确的定义，我想扩展一下使它难以定义的背景思想。

我认为抽象有两种用法可以很好地开始这个讨论。首先是来自我最喜欢的一本编程书籍， [*艾贝尔森和苏斯曼的《计算机程序*](http://mitpress.mit.edu/sicp/) 的结构与解释》([1.1 节](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1))。

> **抽象手段**，通过它可以将复合元素命名并作为单元进行操作。

在他们的“定义”中，抽象是关于*命名*。命名是一件有趣的事情。它被用来表示身份——如一个人的名字——也用来表达一种意思——如给一个想法命名。作为人类，我们有创造新术语的倾向。它们是新的名字，也许有新的含义。这是我们天生语言能力的一部分。当我们编程时，我们总是这样做。每当我们创建一个变量或命名一个函数时，我们都在发明一个新的术语并赋予它一个意义。

它的意义，在我们的程序中，就是它的行为。这东西是做什么的？我应该什么时候使用它？我如何使用它？函数根据其参数计算返回值。您可以通过调用该函数或将它作为参数传递给调用它的对象来使用它。在 Clojure 中，通过将函数名放在 parens 中的第一个位置来调用函数。在 Clojure 中，函数也可以有效果。

编程语言理论家称枚举所有这些含义为语言的*语义*。但这只是意义的另一种说法。给一个事物起一个描述性的名字就是给它一个清晰的含义。

编译器是如何实现 Clojure 函数的？我们大多不在乎。我们编写函数并调用它们，而不太关心它们编译成什么。只要我们可以忽略那些实现细节，我们就称抽象*为健壮*。当实现变得很重要，而我们不能相信抽象会像预期的那样工作时，我们称抽象为*泄漏*。一个健壮的抽象能够对我们隐藏细节，并给我们一个新的基础来建立其他的抽象。

这让我想到了第二个“定义”，这一个是由 Edsger Dijkstra 提出的。

> 抽象的目的不是含糊不清，而是创造一个新的语义层次，在这个层次上，一个人可以绝对精确。

Dijkstra 的引用直接指向了它的目的，我们还没有深入研究。我们想要创建一个新的语义层次(再次表示意思)，在这里我们可以做到精确。我对*这个词的理解是，我们需要能够准确地说出我们的意思，仅此而已。我们希望我们的复合元素完全适合它们的用途。*

我相信这是我们经常谈论的编程的难点。我们同时在发明一个新的目的和应该适合它的东西。然后，我们必须给它命名，以使目的明确。我们同时在做三件事。这是一个很大的自由度，会把我们引向一个不精确的抽象。

在我们的行业中有很多对抽象的不信任，我认为这是正确的。我们一次又一次地被为抽象而抽象和隐藏问题的抽象所灼伤。这些抽象不符合他们的目的，不应该被信任。但是我们不应该不信任所有的抽象概念。我们工作的一部分是学习什么是好的。

这是不信任抽象的一个很好的例子。互联网企业家乔尔·斯波尔斯基(Joel Spolsky)创造了一句格言，他称之为“[漏抽象法则](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/)”:

> 在某种程度上，所有非平凡的抽象都是有漏洞的。

他举了 TCP 的例子:抽象就是“建立 TCP 连接并可靠地发送数据，尽管会有数据包丢失和网络的其他变化”。这是一个很好的抽象，除了它有一个漏洞:如果你拉网线呢？什么都不会通过！根据法律，该机制最终总是会“泄露”出去。这提醒我，隐喻只能延伸到这里，有些真实的事情我们无法证明。

我认为这条法律有很多道理，但他的例子有点牵强。为什么？嗯，套接字为您处理了很多事情，而且它们也有定义明确的错误。如果连接被切断，您的套接字将引发一个错误。因此，套接字抽象实际上并没有对您隐藏网络电缆问题。相反，它把它融入了它的结构。也许真正的问题是，在我们的编程语言中，错误很容易被忽略。所以我喜欢思考我所谓的“逆斯波克西定律”:

> 在某种程度上，所有过于琐碎的抽象都是有漏洞的。

这个想法是，泄漏的抽象是那些不精确的 Dijkstra 指定的方式。他们隐瞒了一些他们无法隐瞒的事情。为了使它更精确，你需要提升到更高的抽象层次，比你理想中想要的要多。这是我在抽象中发现的头号罪恶:它们隐藏了太多。

抽象也是我们在代数中看到的东西。我们给一个值一个名字，尽管我们不知道这个值可能是什么。我们在代数中称这些*变量为*。我们可以像处理数值一样处理这些名字，并得出合理的答案。这显示了机械符号操作、意义表征和机械计算之间的一种非常美丽的关系。抽象本身就有规律。因此，我可以用代数的方法操作一个程序，并讨论它的性质，而不需要运行它。抽象变成了一件值得谈论的事情。

这里面有些东西指向了智力的根源，许多书都是关于这方面的。之所以难以启齿，是因为我们没有很好地反省自己的思维方式。经过几千年的努力，我们仍在理解它。我们更擅长*做*，而不是*知道我们在做什么*。

我喜欢编程的一点是，我们可以像艺术家或哲学家那样直接处理意义。我们知道，最终，我们正在建立一种机制来控制计算机中的电子流。然而，我们在思想的世界里工作。我的大脑只想逃离世俗的逻辑门，建造思想雕塑。

### [](#conclusions)结论

作为程序员，我们每天都在处理抽象概念。我们要么使用它们，创建它们，要么调试它们。抽象是我们语言能力的自然延伸。他们让我们给概念命名，这样我们就可以用它们来形成更大的想法。许多语言设计和行业编程书籍都是关于如何准确地进行这些抽象。我们如何着手制造这些东西？有更好更差的方法吗？随着软件越来越多地占据我们的生活，这些是我们必须更好地理解的一些事情。

如果你对计算机科学的伟大思想和编程的哲学问题感兴趣，你应该看看 [PurelyFunctional.tv 时事通讯](https://purelyfunctional.tv/newsletter)。这是一个关于 Clojure 和函数式编程的理论和实践的每周游戏。