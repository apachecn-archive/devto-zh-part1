# AMQP 与 HTTP

> [https://dev . to/coverage/am qp-vs http](https://dev.to/fedejsoren/amqp-vs-http)的缩写形式

*这篇* *的帖子* *是* *写的* *为*[www . liveanddev . de](http://www.liveanddev.de)*博客*

## [](#introduction)简介

当我想到写“AMQP vs HTTP”时，我想到了写两种协议之间的区别，描述每一个报头和它为什么在那里，它是如何在每种协议中发送每一个消息/包的，等等，等等...但后来我意识到，所有的灰色信息都在那里，任何想阅读协议本身的人都可以“谷歌一下”，并拥有关于每个协议的大量信息。如果你想在这里寻找信息，只要“让我用谷歌搜索一下”就可以了: [AMQP](http://lmgtfy.com/?q=AMQP+protocol) ， [HTTP](http://lmgtfy.com/?q=HTTP+protocol) 。如果您正在寻找一个真实的用例，以及关于何时使用每种协议以及为什么使用的讨论，那么您就找对了地方。

## [](#case-of-discussion)案例讨论

一段时间以前，当我们开始对巨大的巨石进行去中心化时，我们需要一种方法来同步核心和区域之间的数据。核心是我们给中央数据库和电子商务部分所在的地方起的名字，区域是我们设置组件的世界的一部分(欧洲、美洲、亚洲...).[发布-订阅](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)模式非常适合我们的项目，因为所有需要同步的数据总是单向的。此外，该模式允许您将它反转过来，使订阅者成为新信息的发布者，并且在将来需要时可以进行双向同步。

当时我们面临的事实是，我们必须建立一个全球范围的发布-订阅模式，其中核心必须与我们可能不知道它们是否已启动和运行的服务进行对话，而且最重要的事情是要可靠，因为我们预计流量很大(不仅是核心到区域的流量，还有该区域产生的流量)。我们需要一种特定的排队机制，在接收方太忙而无法响应的情况下保持通信，但同时，我们也不想阻塞生成方(通过一次又一次地重试请求)。我们不能失去任何通信，也不能失去任何数据同步。在那一刻，我们想到了使用消息队列的想法。消息队列允许您拥有一个[中间件](https://en.wikipedia.org/wiki/Middleware)，它将保存所有的通信，并且根据您构建它们的方式，您可以添加您可能需要的可靠性，强制每个包的确认，并在通信中使用信任链。

所以我们知道该做什么，但不知道怎么做。当然，我们每个人都有一个好主意！您总是可以构建一个非常基本的“在某个地方编写未被确认的通信，稍后再试，直到它工作为止”，我们甚至尝试使用 Redis 作为消息队列(它工作得很好，但不可靠)。然后，我们发现了 RabbitMQ 和 AMQP 协议。在此之前，我不得不说，团队中的大多数人根本不知道这项技术。我们对消息队列没有任何经验，所以我们必须学习很多东西。我们经历了一个试错阶段，直到我们将这项技术驯服成我们的意志，剩下的就是历史了。对于必须以异步方式进行的内部通信，我们使用 RabbitMQ。我们在每个区域都有一个代理，在核心区域也有一个代理，我们使用铲来传递核心区域之间的消息。

## [](#discussion)讨论

但是，尽管我们已经积累了几乎一整年的经验，在生产中使用这种技术，毫无疑问，性能非常好，并且有 RabbitMQ 代理作为我们组件之间通信的核心，“AMQP vs HTTP”是我们办公室每天(也许每周)的讨论话题。人们有时甚至会因为这个话题而互相生气，我们会就为什么使用 RabbitMQ 和 AMQP 更好还是不使用更好进行长时间无意义的讨论。关于这个话题(组件间内部同步通信)，有四种观点(至少我是这样发现/听到的):

1.  我更喜欢用 HTTP。
2.  我更喜欢用 AMQP。
3.  我对它们没有偏好，我只是在它们已经被使用的地方使用它们。
4.  我不在乎为什么使用这样或那样的协议，我只想同步数据。

第三种和第四种观点我将把它们放在本文的评论部分(如果你愿意，我们可以讨论它，但这将偏离主题)，所以我将把文章的其余部分集中在另外两种观点上。

现在，我想到了这篇文章中棘手的部分，因为“更喜欢”可能是个错误的词。我们(作为开发人员)应该有“关于技术问题的观点”吗？或者我们应该更好地分析事实，并在每个案例中使用方便的方法？我们的职业不在于直觉，而更在于事实(尽管直觉也很重要！).所以让我们来看看事实:

1.  这两种协议都允许您在组件之间进行通信。
2.  两个协议都是可追踪的。
3.  两个协议都有很好的记录
4.  AMQP 是异步的。
5.  HTTP 是同步的。
6.  HTTP 很容易调试。
7.  人们对 HTTP 很熟悉。
8.  HTTP 很好地映射到一个接口。
9.  AMQP 易于维护和扩展。
10.  AMQP 保证了消息的传递。
11.  对于 HTTP，您需要某种服务发现。
12.  AMQP 需要知道代理才能到达读/写队列。
13.  RabbitMQ 提供了扇出机制，队列的铲入和联合(“开箱即用”)。
14.  如果 RabbitMQ 在处理一个消息时被重新启动，而它还没有完成，它将自动重新排队，其他后端服务将获得它并处理它。
15.  几乎每种编程语言都支持 HTTP。
16.  RabbitMQ(因此，AMQP) [在几种编程语言](https://www.rabbitmq.com/devtools.html) (JAVA、.NET、RUBY、Python、PHP、Objective-C、Scala、Groovy 和 Grails、Clojure、Jruby、Javascript、C、C++、GO、Erlang、Haskell、OCaml、Unity 3D、Perl、Common Lisp、COBOL)。
17.  ...

事实清单至少可以增长几页，但我认为有足够的关键事实可以根据你的情况选择一个或另一个。

## [](#facts-prohttp)事实亲 HTTP

调试一个 HTTP 请求真的很容易且可重复，然而 AMQP 消息很难调试(你需要连接到队列、库，可能还有脚本等等...).HTTP 是开发人员熟悉的技术，因此不需要对项目中的新开发人员进行额外培训。
HTTP 是互联网中最受支持的协议，因此将您的 API 共享为 HTTP API 是一个很好的做法。

## [](#facts-proamqp)事实亲 AMQP

用 AMQP 传递消息给你带来了可靠性，异步让你完全不用担心传递。知道 AMQP 代理集群的主机/IP 就足以发送/接收消息，而对于 HTTP，根据地区的不同，您可能有不同的主机和 IP。
您可以使用扇出，这意味着一条消息足以通知几个不同的组件，从而减少通信量。

## [](#considerations-when-using-amqp)使用 AMQP 时的注意事项

为了传递和接收 AMQP 消息，你需要一个代理。代理只不过是接收、存储和传递消息的服务器。根据您的成本和基础设施，这可能会增加项目的复杂性，必须配置和维护一个/几个/联合/...经纪人。

在我们的例子中，我们使用 [CloudAMQP](https://www.cloudamqp.com/) 将这部分外部化。这使我们不必担心维护问题，但却给最终解决方案增加了额外的成本。

## [](#preconclusion)预结论

我想说，如果你想与世界交流(提供一个第三方使用的 API)，HTTP 可以满足你的所有需求。它得到了支持、众所周知并被广泛使用。此外，您“不必关心通信中是否有问题，因为如果出现问题，再次执行请求是 API 的客户端的职责。

如果你想进行内部交流，控制每一个请求，我会使用 AMQP，因为它易于使用，被当今使用的大多数语言支持，可靠，可伸缩，快速。

我认为两个协议都很棒，这一点毋庸置疑。但其中只有一个增加了“开箱即用”通信的可靠性，这一点很关键，此外，其中只有一个几乎是开箱即用可扩展的，并且通信不会阻塞服务的事实允许您继续将资源用于其他进程。此外，为什么要“仅仅因为”重新发明 weel 来创建我们自己的可靠性流程？为什么要添加额外的代码来维护，仅仅是因为“我们可以”吗？我说得很清楚，如果是异步的，就用 AMQP 和 RabbitMQ。

## [](#conclusion)结论

或许你已经意识到整个讨论毫无意义，不是吗？我们在这里将鞋子与 t 恤进行比较，这是我们长期以来一直在犯的一个错误。

我们应该关注什么是真正重要的:我们为什么决定采用一种或另一种技术，我们所做的选择有哪些优点和缺点，一旦我们这样做了，我们就要尽全力做到最好。

当然，审查所选择的基础设施总是好的，但是我们必须考虑什么时候和为什么。