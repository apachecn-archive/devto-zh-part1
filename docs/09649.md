# 为什么在设计 REST APIs 时应该使用标准的 HTTP 方法

> 原文:[https://dev . to/suhas _ chatekar/why-should-you-use-standard-http-methods-while-designing-rest-API](https://dev.to/suhas_chatekar/why-should-you-use-standard-http-methods-while-designing-rest-apis)

一个好的 REST API 的特征之一是它以一种它们应该被使用的方式使用标准的 HTTP 方法。我们一直听到这句话，这是休息的最基本准则。众所周知，我们在设计 REST APIs 时使用了以下 HTTP 方法

*   **`GET`**–用于归还资源
*   **`POST`**–用于创建新资源
*   **`PUT`**–用于更新资源
*   **`PATCH`**–用于更新资源
*   **`DELETE`**–用于删除资源

但是除了基本的，为什么会这样呢？在更新操作中使用两种方法`PUT`和`PATCH`难道不令人困惑吗？

# [](#what-do-the-specs-say)说明书怎么说？

让我们首先弄清楚显而易见的事情。让我们看看说明书是怎么说的

### [](#get)[得到](http://httpwg.org/specs/rfc7231.html#GET)

> `GET`方法请求传输目标资源的当前选择的表示。`GET`是信息检索的主要机制

这实际上意味着您应该将`GET`用于一个 API 方法，该方法返回由 API URL 标识的资源的最新版本。

### [](#post)[岗位](http://httpwg.org/specs/rfc7231.html#POST)

> `POST`方法请求目标资源根据资源自己的特定语义处理请求中包含的表示。
> 这有点令人困惑，但那是因为`POST`可以用来做不止一件事——其中之一是创建一个新资源。

这是令人困惑的，因为如果服务器可以执行多个操作来响应一个请求，那么消费者如何发现到底发生了什么？该规范规定，服务器应该使用 2xx 系列状态代码中的一个向客户端指示服务器上发生了什么。

### [](#put)[放](http://httpwg.org/specs/rfc7231.html#PUT)

> `PUT`方法请求创建目标资源的状态，或者用包含在请求消息有效负载中的表示所定义的状态来替换。

所以`PUT`既可以用来更新资源，也可以用来创建新资源。起初这听起来可能很奇怪，但是现在让我们保持事情简单，相信我们应该使用`PUT`作为 API 方法，让消费者更新由 API URL 标识的资源。

### [](#delete)[删除](http://httpwg.org/specs/rfc7231.html#DELETE)

> DELETE 方法请求源服务器移除目标资源与其当前功能之间的关联。

同样，像`POST`，`DELETE`可以用于不止一个最终导致某些东西被删除的操作。让我们相信，我们应该对一个 API 方法使用`DELETE`,让消费者删除由 API URL 标识的资源。

### [](#patch)[补丁](https://tools.ietf.org/html/rfc5789#page-3)

`PUT`和`PATCH`请求之间的区别反映在服务器处理被包含的实体以修改由请求 URI 标识的资源的方式上。在`PUT`请求中，被包含的实体被认为是存储在源服务器上的资源的修改版本，客户端请求替换存储的版本。然而，使用`PATCH`，封闭的实体包含一组指令，描述当前驻留在源服务器上的资源应该如何被修改以产生新版本。

`PATCH`和`PUT`一样，应该用于修改资源，但是，修改的语义略有不同。我们将在下一节讨论这种差异。

因此，我们最初对每个 HTTP 动词含义的理解与规范所说的意思是一致的。到目前为止一切顺利。规范告诉我们在什么情况下应该使用每个动词，但它仍然只是一个规范。我们的实现仍然可以忽略规范告诉我们要做的事情，在`GET`操作之后实现新资源的创建，在 POST 操作之后实现删除。然而，遵守规范有两大好处。

# [](#idempotence-is-not-limited-to-mathematics)幂等不仅限于数学

在数学中，幂等运算是指每次对相同的输入执行时都会产生相同的结果。计数器就是一个很好的例子。“将计数器设置为 6”的操作是等幂的，但是“将计数器增加 1”的操作不是等幂的。你看出区别了吗？在第一种情况下，无论你将计数器设置为 6 多少次，它最终仍然会设置为 6。然而，在第二种情况下，如果计数器的初始值为 4，那么每当您将它递增 1 时，计数器就会被设置为不同的值。

应用于 REST，幂等操作是不改变服务器的目标状态的操作。另一方面，非幂等操作总是会改变服务器的目标状态。请注意，我们在这里讨论的不是状态变化，而是服务器的目标状态。HTTP 规范声明`GET`、`PUT`和`DELETE`是幂等运算。`POST`和`PATCH`是非幂等运算。“像早先一样，这只是一个规范。为什么需要跟着走？”你可能会问。这是有原因的，而且是一个非常好的原因。

幂等运算向 API 的消费者保证，无论他们调用 API 多少次，服务器的状态都是相同的。这个保证很有用。假设服务器成功执行了消费者调用的 API 方法，但是在将响应发送回消费者时出现了错误。即使操作在服务器上成功完成，消费者最终也会得到一个错误。消费者应该怎么做？现在，如果服务器执行的操作被广告为幂等的，那么消费者可以发送请求来再次执行操作。只要它看到一个成功的响应，而不会导致服务器执行任何不必要的状态更改，它就可以继续这样做。另一方面，如果操作没有被广告为幂等的，那么消费者将知道它需要在再次执行操作之前检查服务器。

新资源的创建是一个操作，它在每次使用相同的输入运行时改变服务器的目标状态，在每次执行后导致不同的目标状态。根据实施情况，这同样适用于资源的删除。想象一下，如果我们把这些操作放在一个`GET`或一个`PUT`动词后面会发生什么？消费者最终可能会多次执行这些操作，从而对服务器的目标状态产生负面影响。另一方面，资源的返回值对服务器的目标状态没有影响，因此应该在幂等动词`GET`后面实现。

`PUT`和`PATCH`还是有区别的。两者都用于修改现有资源。如果你回到规范中关于`PUT`的描述，你会注意到它类似于说“将计数器设置为 6”。`PUT`是修改，其中消费者提供完整资源的目标状态，并指示服务器用消费者发送的新值替换资源当前具有的任何值。无论使用者执行这个操作多少次，资源的最终状态都不会改变。另一方面，`PATCH`类似于“将计数器加 1”。`PUT`对于大小较大且消耗大量带宽的资源来说，可能会很大。`PATCH`的引入是为了让消费者向服务器发出指令，告诉它如何改变资源的一部分。如果多次执行此指令，可能会导致不需要的结束状态。

最后，这一切都归结于实现，但是如果你的实现尊重规范，那么你的 API 客户端的生命将会容易得多。当我们谈论尊重规范时，还有另一个有趣的特性，规范说所有的 HTTP 服务器和代理在处理 HTTP 请求时都应该构建。遵守规范的 REST API 可以很好地利用这一点。

# [](#web-is-fast-because-of-caching)Web 快是因为缓存

web 可能是缓存的最大用户之一。它不仅使网站加载速度更快，而且运行可靠，如果我们不利用它，那将是愚蠢的。REST 使用 HTTP，因此应该尽可能利用它的缓存特性。HTTP 缓存规范非常详细地说明了 HTTP 服务器和代理应该如何实现它，但是我想从规范中挑选两件直接适用于 REST 的事情。

1.  在`GET`端点之后的操作不会改变服务器的目标状态，因此,`GET`端点的响应可以被缓存，导致对同一端点的进一步请求从缓存中更快地返回
2.  在`PUT`、`POST`、`PATCH`和`DELETE`之后的端点改变服务器的目标状态，因此，来自这些端点中的任何一个的成功响应可以被用来破坏先前缓存的响应。

我知道我过度简化了 HTTP 的缓存规范，但这是我遇到的最优雅的缓存规范之一。充分利用这一点所要做的就是遵守 HTTP 规范。

关于缓存的最后一点是，它对 API 的消费者的影响比对 API 的开发者的影响更大。只要消费者使用支持缓存的 HTTP 客户端库，遵循 HTTP 缓存规范的 API 对消费者来说就是最有用的。我确信每个领先的编程平台都至少有一个这样的库。所以鼓励你的消费者使用其中的一个库。尽管如此，API 开发人员仍然应该利用缓存，因为 HTTP 和代理服务器仍然会缓存响应。

# [](#in-closing)在关闭

HTTP API 的美妙之处(这里我有意避免使用 REST 这个词)在于它为 API 开发者提供了很大的灵活性。只要不被滥用，任何灵活性都是好东西。我见过许多 HTTP APIs，它们要么不使用推荐的 HTTP 方法，要么即使使用了，开发人员也不知道为什么要做出这些选择。我希望这篇文章对我们为什么应该使用推荐的 HTTP 方法有所启发。