# 利特尔定律

> 原文：<https://dev.to/horia141/littles-law-2o6l>

我最近在读[Java Concurrency In Practice](https://books.google.ro/books/about/Java_Concurrency_in_Practice.html)，发现了这个叫做[利特尔法则](https://en.m.wikipedia.org/wiki/Little%27s_law)的小定理。它非常直观，你可能已经用过很多次了。尽管陈述起来非常有用和简单，但我还是没有意识到这一点。

利特尔定律是[排队论](https://en.m.wikipedia.org/wiki/Queueing_theory)的数学弟子中的一个结果。这是对队列的研究(咄)。形式主义很简单。有一个处理工作单元的系统。这些在不同的时间到达，被处理，然后从系统中消失。工作项目到达的方式和处理它们的方式都有一些随机性，所以到达率和处理时间最好建模为随机变量。

许多事情可以被建模为队列。首先是和人一起排队，就像商店或电影院一样。还包括服务器的请求处理、消息队列中的消息以及其他与 IT 相关的主题。

利特尔法则将每单位时间内到达的平均工作单元数(平均到达率\λ)、平均处理持续时间(平均时间 T)和队列中活动元素的平均数量 N 联系在一起。这些只是 N = \λT。值得注意的是，这与到达时间和持续时间的分布无关。所要求的是系统要稳定，也就是说，所有的工作项最终都要被撤销，并且是非抢占式的，这意味着一旦一个工作项被启动，它就永远不会被放弃。

但是为什么是真的呢？嗯，直觉真好。让我们举一个离散的例子，我们的时间以分钟为单位演变。然后，平均每分钟有 20 名顾客到达，同样，他们平均停留 10 分钟。因此，第一分钟将有 20 人，接下来的 40 人，以此类推，直到第 10 分钟，系统中将有 200 人。在这之后，新的人会到来，但是一些人也会离开，因为他们已经完成了他们的工作。因此，如果平均有 20 人到达和 20 人离开，那么我们在任何给定的时间都处于 200 人的稳定状态，超过了“初始设置”。最终的数字只是到达人数和停留时间的乘积。

对于这样一个简单的结果，数学是复杂的。即使是发表的最直观的证明也远远超出了我努力去理解它的愿望。但是这个工具足够广泛和直观，它不需要所有这些就能有效。