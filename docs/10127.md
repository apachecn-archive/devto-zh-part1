# 揭开 OAuth2 流的神秘面纱

> 原文:[https://dev.to/grahamcox82/demystifying-oauth2-flows](https://dev.to/grahamcox82/demystifying-oauth2-flows)

下一个大困惑是各种各样的 OAuth2 流是什么。在某些方面，OAuth2 比 OAuth 1 更容易理解。在其他方面，它更复杂——这是其中之一。OAuth2 引入了许多不同的流，可用于获取访问令牌，选择正确的流并不总是容易的。

*   授权码授予。如果您的应用程序有服务器组件，请使用这个组件。本质上，这意味着用户被重定向到他们将登录的身份验证系统，如果成功，他们将被发送给您。当他们被送回时，他们将为您提供一个授权码，然后您可以用这个授权码与身份验证系统交换一个访问令牌。
*   隐性资助。如果你的应用程序没有服务器组件——例如，你是一个用纯 HTML/Javascript 编写的单页 web app——那么使用这个组件。这与上面的完全相同，除了返回到您的应用程序将直接包含访问令牌，而不包含任何授权代码。
*   授予资源所有者密码凭据。永远不要用这个。对他们来说这是一件非常奇怪的事情。基本上，这个要求你自己获取用户的用户名和密码，你没有权利要求这些细节。
*   授予客户端凭据。这种方法适用于您希望针对另一个系统对您的系统进行身份验证的情况，但不代表用户。您可能需要这个来获得一些后台管理任务的访问令牌，但是我发现这个用处不大。
*   刷新令牌授权。这是一个特例。一旦你获得了一个访问令牌，它就有一个生命周期。当生存期到期时，访问令牌就没有用了。您还可能获得一个刷新令牌，使用它您可以获得一个新的访问令牌，而无需用户在场。对于刷新令牌的有效期没有真正的标准，但是它应该比访问令牌长。

OAuth2 定义了流的两个不同部分，但并不是所有的流都使用这两个部分。有授权端点和令牌端点。授权端点是用户直接参与的部分，由授权代码授权和隐式授权流使用。令牌端点是系统代表用户请求访问令牌的部分，由除隐式授权流的之外的所有*使用。*

在 OAuth2 之上还有一个叫做 OpenID Connect 的东西。这巩固了使用 OAuth2 的一些方法，并增加了专门针对身份验证的额外功能——比如 ID 令牌的概念。OpenID Connect 是一个非常大的标准——实际上是 8 个规范一起工作——但如果做得好，它会非常有用。对于这篇文章，重要的是它介绍了一些处理响应类型的额外方法。

在 OAuth2 中，响应类型用于在授权码 Grant - response_type=code 或隐式 Grant - response_type=token 之间进行选择。在 OpenID Connect 中，添加了第三种响应类型——Response _ Type = id _ token——并且您可以根据自己想要实现的目标将它们组合在一起。因此，以下内容完全有效:

*   密码
*   代币
*   id_token
*   代码令牌
*   代码 id _ 令牌
*   id_token token
*   代码 id_token 令牌

每当请求的响应类型包含“code”时，您将获得一个授权码来交换访问令牌。每当它包含“令牌”时，您将直接获得一个访问令牌。只要它包含“id_token ”,就会向您提供 id 令牌。

那么，为什么你想要一个授权码*和一个访问令牌*？显而易见的原因是访问的持续时间。隐式授权——意味着您直接获得一个访问令牌——**不能**发布刷新令牌，因为您是通过一个潜在的不安全通道发布它。颁发的访问令牌也有可能寿命更短——可能只有几分钟。如果你申请一个授权码*和*一个访问令牌，那么你现在就可以得到你需要的任何东西的访问令牌，但是你也可以得到一个授权码来换取一个更长时间的访问令牌供服务器使用。