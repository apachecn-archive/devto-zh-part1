# 你应该知道的软件需求优先化技术

> 原文:[https://dev . to/Apium _ hub/software-requirements-prioritization-techniques-you-should-know-4kef](https://dev.to/apium_hub/software-requirements-prioritization-techniques-you-should-know-4kef)

软件开发项目就像任何其他项目一样，有多种需求、预算限制和紧迫的期限。因此，有必要对软件需求进行优先排序，因为一次完成所有事情是不可能的。因此，您需要决定哪组需求需要首先实现，哪组需求可以推迟到以后的版本。

通常，[敏捷项目经理](https://apiumhub.com/tech-blog-barcelona/benefits-of-agile-project-management/)希望开发高质量和高价值的软件，而开发高价值软件最简单的方法就是首先实现最高优先级的需求。这使他们能够最大化利益相关者的投资回报率。

由于通常需求经常变化，您需要一种简化的、灵活的方法来管理需求变化，例如产品 backlog ( [Scrum](https://apiumhub.com/tech-blog-barcelona/scrum-sprint-explanation/) )。因此，在敏捷开发中，软件需求优先级被认为是项目的重要部分。例如，为了区分[用户故事](https://apiumhub.com/tech-blog-barcelona/user-stories-affect-team-product/)的优先级，我们可以使用前 5 个优先级标准，例如用户对产品愿景、紧迫性、时间限制、技术复杂性和利益相关者偏好的重视程度。

此外，对于主要项目目标和将实现目标的特定任务，项目通常需要正确地划分优先级。所以我们在两个层次上处理优先级:产品层次和任务层次。特别是考虑到客户通常不理解他们不能在新软件产品的 1.0 版本中获得他们想要的所有特性。每一个项目都应该有所要求的特性、用例以及功能需求的优先级。软件需求优先级帮助项目经理解决冲突，计划分阶段交付，并做出必要的权衡决策。

繁荣的公司和失败的公司之间最大的区别之一是有效地划分优先级的能力，但是软件需求的优先级划分从来都不容易。它通常涉及痛苦的决定和艰难的权衡，对于早期和扩张阶段的公司来说，在有限的时间和有限的资源内完成大量工作会带来额外的压力。为了实现增长，一个团队应该只专注于真正重要的、将会产生最大影响的事情。

软件需求优先化是软件团队面临的最大挑战之一。实际上， [25%的技术领导者](https://codingsans.com/blog/prioritize-software-development-requirements)说优先软件开发是他们最大的挑战。

但是根据珍妮·罗斯和彼得·威尔为他们的书《IT 治理》所做的研究，“管理他们的 IT 投资的公司最成功地产生了比他们的竞争对手高出 40%的回报。”

总的来说，公司应该确保每个团队成员不只是在完成一系列任务。他们应该清楚地了解他们正在进行的任务的影响，看到他们对项目的直接贡献。他们还需要清楚产品的用途，不仅要了解客户的需求，还要了解企业的价值和目标。

有些东西像[后端架构](https://apiumhub.com/web-development-barcelona/)对客户来说是不可见的，但对开发者来说是不可见的，开发者可以指出任何可能影响产品未来性能的架构问题。这就是为什么确保团队中的每个工程师都了解产品的前前后后是如此重要。

软件需求优先化不一定是一个持续的痛苦来源。通过正确的方法，它可以增强您的决策能力，并引导您获得显著改善的结果。对于许多团队和公司来说，这是一个非常大的问题，因此已经开发了许多关于如何区分需求优先级的方法和技术。让我们看看最流行和最有效的方法:

## [](#most-popular-software-requirements-prioritization-techniques)最流行的软件需求优先级排序技术

#### [](#analyze-key-areas-that-are-taken-into-account-before-taking-an-important-decision)**在做出重要决定之前分析需要考虑的关键领域**

利益–企业从所需的实施中获得的优势。

惩罚——未实施要求的后果。

成本——实现需求所需的努力和资源。

风险——需求可能无法交付预期价值的概率。

依赖——需求之间的关系，例如当一个需求需要完成另一个需求才能实现。

时间敏感度——截止日期，紧急程度。

稳定性——需求保持静态的可能性。

政策合规性——为满足法规要求而必须实施的要求。

#### [](#dependency-map)依赖关系图

创建依赖关系图来更好地理解需求之间的依赖关系总是一个好主意。尤其是考虑到大多数需求是相互依赖的，你很难找到任何独立存在的需求。

你怎么做到的？让我给你举个例子:你有 8 个需求 X，Y，Z，P，Q，R，M，O 和 N，它们有优先级，分 5 级，1 级最关键，5 级最不关键，如 1，2，1，4，5，1，2，2，3。因此，有了这些优先级，从需求 X、Z 和 r 开始是合乎逻辑的。

现在，让我们转到依赖部分示例:我们需要在从 Y 开始之前完成 X，尽管 X 和 Y 具有相同的优先级。类似地，我们需要在开始 R 之前完成 O，尽管 R 比 O 具有更高的优先级。理解需求依赖与优先级一样重要。如果不理解需求依赖，您就很难达到需求实现的正确顺序。因此，在对需求进行优先级排序之前，准备好需求依赖图是一个好主意，尤其是当您从事软件项目时。

#### [](#moscow)**莫斯科**

莫斯科方法比数字评级系统效果更好，因为利益相关者更容易将要求评级为必须、应该、可以或将要。

首字母缩略词代表以下内容:

高优先级

的强制
必须
应该优先

必须
可以推迟并建议将来执行

#### [](#voting)**投票**

这是区分需求优先级的最简单的方法。当有太多的需求需要根据来自不同涉众的输入划分到不同的类别中时，投票是理清需求优先级的最佳方式之一。假设有 10 个特性正在讨论中，涉众有 10 个要点，他们需要将它们分散到这些特性中。例如，最不重要的 1，最重要的 10。

#### [](#bubble-sort-technique)**冒泡排序法**

非常类似于投票，但对于一些人来说，这种技术有助于他们更快地获得正确的优先级。要使用冒泡排序技术区分需求的优先级，您需要两个需求，并将它们相互比较。如果你发现一个需求比另一个更优先，你就相应地交换它们。然后继续这样做，直到最后一个需求被正确排序。结果是一个排列好的需求列表。

#### [](#hundred-dollar-method)百元法

这个简单的方法在任何多个涉众需要民主投票决定哪个需求是最重要的地方都是有用的。所有的涉众得到了概念上的 100 美元，他们可以在需求中分配。因此，涉众可能会选择把所有 100 美元都给一个需求，或者这个人可能会更平均地分配分数。分配给每个需求的金额越高，该需求的优先级就越高。最后，计算总数，并根据收到的分数对要求进行排序。

#### [](#five-whys)五个为什么

经常发生的情况是，利益相关者想要实现某个特性的原因并不是建立在逻辑论证或公司的商业利益上。有了“五个为什么”,分析师反复询问涉众(五次或更少)为什么需求是必要的，直到需求的重要性被确定。答案揭示了需求是否真的有必要，或者一旦确定了优先级，是否可以取消/推迟。

那么，哪种优先级技术是最好的呢？没有正确的答案，你可以把它们结合起来，你可以用一个做第一个项目，另一个做第二个项目。最重要的是你要分析影响业务的关键点。

**让我们看看软件需求优先化过程的例子:**

1.  首先，你要做的是创建一个列表，列出你希望在电子表格中优先考虑的所有需求、特性或用例。如果某些特征有逻辑联系，则在分析中只包括驱动特征。

2.  第二步是估计每个功能为客户和企业带来的相对收益，从 1 到 9，1 表示收益很小，9 表示最大可能收益。

3.  第三步是估计如果不包含该特性，客户或企业将遭受的相对损失。同样，使用从 1 到 9 的范围，其中 1 表示基本上没有惩罚，9 表示非常严重的负面影响。

4.  然后是总价值——它是相对收益和惩罚的总和。默认情况下，收益和惩罚的权重相等。

5.  下一步是什么？对实现每项功能的相对成本的估计，范围也是从 1 到 9。

6.  开发人员从 1 到 9 的范围内估计与每个特性相关的技术或其他风险的相对程度。

7.  一旦您将估计值输入到电子表格中，它会为每个功能计算一个优先级数，并给出考虑所有输入的结果。

8.  按照计算出的优先级以降序对要素列表进行排序。列表顶部的功能具有最有利的价值、成本和风险平衡，因此应该具有更高的实现优先级。

我希望这篇文章对你有用。如果你知道其他软件需求优先级排序技术，请在下面的评论区分享。

如果你对其他软件开发技巧感兴趣，我强烈推荐你订阅我们的每月简讯[这里](http://eepurl.com/cC96MY)。

## 如果你喜欢这篇关于软件需求优先级的文章，你可能会喜欢…

[2018 年要读的软件开发书籍](https://dev.to/apium_hub/20-essential-software-development-books-to-read)

[为什么是科特林语？谷歌为什么选择它？](https://dev.to/apium_hub/why-kotlin-language-android-why-did-google-choose-kotlin--639)

[iOS 与浪子持续整合&詹金斯](https://dev.to/apium_hub/ios-continuous-integration-with-fastlane--jenkins-19n)

[iOS 中的 MVP 模式](https://dev.to/apium_hub/mvp-pattern-in-ios-98f)

[今年要读的软件架构书籍](https://dev.to/apium_hub/top-19-software-architecture-books-blf)

[Scala 类型界限](https://dev.to/apium_hub/scala-generics-i--scala-type-bounds-38)

[在 Scala 的一般类型上的 F-bound](https://apiumhub.com/tech-blog-barcelona/f-bound-scala-generics/)

[安卓模拟器中的查尔斯代理](https://apiumhub.com/tech-blog-barcelona/charles-proxy-android-emulator/)

[顶级软件开发博客](https://apiumhub.com/tech-blog-barcelona/top-software-development-blogs-2017/)

[顶级软件测试技术&使用的工具](https://apiumhub.com/tech-blog-barcelona/top-software-testing-techniques/)

[将提高你工作效率的 Tmux 指南](https://apiumhub.com/tech-blog-barcelona/tmux-cheat-sheet-tips-tricks/)

[功能债务 vs 技术债务](https://apiumhub.com/tech-blog-barcelona/technical-debt/)

[BDD: UI 测试](https://apiumhub.com/tech-blog-barcelona/user-interface-testing/)

[微服务 vs 整体架构](https://apiumhub.com/tech-blog-barcelona/microservices-vs-monolithic-architecture/)

[面向对象设计中的 SRP](https://apiumhub.com/tech-blog-barcelona/single-responsibility-principle/)

[几乎无限的可扩展性](https://apiumhub.com/tech-blog-barcelona/almost-infinite-scalability/)

你应该知道的软件需求优先排序技术的帖子最早出现在 T2 的 Apiumhub 上。