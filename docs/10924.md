# 木卫一:是语言，不是月亮

> 原文：<https://dev.to/designfrontier/io-the-language-not-the-moon-2ibd>

这是七种语言系列文章的第一篇，涵盖了一种小型原型语言 [Io 语言](http://iolanguage.org/)。

让我们现在就解决这个问题。我爱`Io`。太神奇了。语法优雅、简洁，并且具有难以置信的可扩展性。你几乎可以把`Io`改写成你想要的样子，这真的很神奇。想解析 JSON？不要为解析器费心…只要扩展语言来处理花括号、方括号和冒号就行了。完成了。太牛逼了。

我真的很喜欢了解它，并且觉得理解它很简单，可能是因为我最熟悉的语言也是原型语言。在我们开始学习我认为有趣的语言之前，让我们开始学习不好的东西。那些痛苦的事和让生活变得艰难的事。

## 问题

### 你需要码头工人

目前，很多内部组件在 OS X 上并不工作。这似乎主要与安装程序和 OS X 管理 libevent 的方式有关，但我并没有深入研究去解决它。我从源代码编译，我使用安装程序，我 brew 安装…没有一个能让我访问像 Random 或 Socket(或它们的任何子对象)这样的东西。

这意味着至少没有 web 服务器会在 OS X 上启动，你也不能做一些关于随机数猜测的功课。

简单的解决方案是在 Docker 中运行所有的`Io`代码。这里有一个很好的码头工人形象:[https://hub.docker.com/r/nacyot/io-io/](https://hub.docker.com/r/nacyot/io-io/)，我一直把它作为一个基地，里面的一切都像冠军一样工作。如果我是你，我会直接使用这个解决方案，甚至不会担心直接安装在 OS X 上。

我遇到的主要症状是一条错误消息，其中包含:`"Library not loaded: /usr/local/lib/libevent-2.0.5.dylib"`。如果你碰到那个美女…就抓住 docker。

### 文件是…嗯…

当我第一次学习 Backbone 时，我对文档一窍不通。它是为那些理解主干的人而不是初学者写的。所以，一旦我熬过了最困难的阶段，大致理解了我在做什么，文档就变得令人惊讶。虽然这是一个与`Io`的文档稍有不同的问题，但它指出了文档是困难的。

`Io`文档的一个主要问题是它有点分散。有一个“指南”，一个“教程”和一个“参考”，但并不完全清楚什么是哪里。例如…如果你想知道数字类型是在什么之上实现的，你需要去参考。(number 是 double，通常实现为 64 位浮点数)但是如果你想理解 Number 的语法，那么你需要去看看指南，因为它不在参考中。你会习惯的…但是分散的自然对我来说似乎很复杂。

文件的另一个问题是它们有时完全不准确。例如，[关于范围的这一节](http://iolanguage.org/guide/guide.html#Primitives-Ranges)有一个在一个根本不起作用的数字上使用 to()的代码示例。永远不会。至少我试过了。

在实践中也很少真正使用协程/未来/角色。甚至不知道它们在文档中有什么用处。我发现的一些关于他们的最好的讨论在这个演讲中。

尽管如此，他们还是进行了试验，才意识到无论我做什么，程序在 CPU 上仍然是完全单线程的。不是节点意义上的单线程，它为长时间运行/异步任务提供线程，而是单线程。因为只有一个线程。

### 小社区很小

这个社区目前还很小。仍然偶尔会有发布，仍然会有针对 VM 的 github repo 的开发，但是很少。我发现的最好的讨论资源是旧的雅虎集团，这些年来已经基本上消失了。

据说史蒂夫·德科特在 twitter 和 github 上回答了几个很好的问题。我很确定，如果我真的开始写一些实质性的东西，他会是一个很好的信息来源。

也就是说，我对这个社区的总体印象是,`Io`是一种从未真正找到足够广阔的定位的语言。它仍在寻找它的杀手级应用程序，在那之前，它很可能仍是一门业余爱好语言。

## 我学到的东西

### 协程不是你想象的那样

或者至少不是我想的那样。它们不会纺出一个在完成时重新加入主线程的线程。这是我的一个简单的误解，因为我在 V8/nodejs 中有深入的经验，处理得非常好。

它们实际上是为了防止您的长时间运行的任务在其他事情可能正在处理的时候被阻塞。只有一个真正的线程，它处理一切。但是，如果您需要将控制权交还给主执行流，那么它们可以很好地工作。

哦，语法棒极了。把一个正常的功能变成一个演员/未来的能力是惊人的。

曾经有人讨论过改变语言的这一部分，让它们作为自己的线程分离出来……但这似乎从未发生过。

### 表演

在我的基准测试中，我使用了一个括号置换问题，在此之前我用 JS 写了这个问题，并在 Java、Ruby 和 c 中看到了它的实现。我会用我们处理的所有语言写一些类似的东西。

JS 处理 10 对括号的排列需要大约 140 毫秒。c 大约是那个的一半。`Io`递归执行计算大约需要 860 毫秒。所以这种计算并不适合这种语言。当我试图将每次迭代推进到一个 Actor 中时，对于相同数量的排列，性能下降到 40 多秒。

不过这完全是我的错，因为我部分误解了`Io`中协程的最佳位置。

### Web 服务器测试

我还在写这篇文章…一旦我写完了，我会公布细节的。我想把它完成，但我现在在 prolog 上，这太疯狂了，所以我需要把注意力从这里转移到那里。

### 括号排列

这是非常标准的…它看起来非常像任何其他递归实现。你可以去回购看看。不是很快。事实上，它真的真的很慢。但是，它和任何其他语言的递归解决方案一样有效。

### 方法参数和 Do 块

这实际上是这门语言非常棒的一部分。定义方法时，传入的最后一个参数总是 Do 块。这适用于循环，也适用于其他任何东西。因此，创建命名变量签名就像在方法声明中添加逗号分隔的名称列表一样简单。

例如:`method( var1, var2, var3, writeln(var1 .. var2 .. var3))`

这种一致性使得用这种语言写东西很容易记住。

### 一切都是有原型的物体

甚至语言。基本上。

您可以通过向 OperatorTable 添加插槽来轻松扩展该语言，从而为新类型的字符(例如:or []或{})创建处理程序。这是非常强大的，可以让你的语言比现在更有表现力。

### missing_method 处理程序！

自从我积极编写 ColdFusion 以来，我已经忘记了这些功能有多强大。CF 中有完整的框架使用缺失的方法处理程序来运行。拥有它们……它们可能非常棒。现在我在 JS 想念他们:-(

## 最后

我喜欢`Io`。我明天会在未来的下一个 web 应用程序中使用它吗？没有。大概不会。它有一个位置，但它不是我每天都想得到的东西。对于其他语言来说，这是一个很好的起点，而 Future/Actor 是需要明确的有用概念，因为其他语言也使用它们。

无论我说什么，我都无法忘记这种微小语言的简单之美。代码只是好看而已。和写作。