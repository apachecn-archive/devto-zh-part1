# CRUD 里没有 U

> 原文：<https://dev.to/jlhcoder/there-is-no-u-in-crud>

*这篇文章最初发表在[我的博客](http://jlhood.com/there-is-no-u-in-crud/)T3 上*

REST 是围绕资源的概念构建的，以 URIs 表示。发出指定 HTTP 谓词和资源 URI 的 HTTP 调用，对指定的资源执行操作。大多数 REST 框架都提供了生成器，您可以在其中指定一个资源名称，框架会围绕它生成脚手架。不幸的是，许多这样的生成器使用 CRUD 模型(创建、读取、更新、删除)作为默认的起点。资源被定义为一个属性包，使用类似 JSONSchema 或特定于语言的数据对象定义，然后生成方法存根来创建、读取、更新和删除该资源。

虽然给开发人员一个工作的起点是好的，但是我对于使用 CRUD 作为 API 的起点有一个很大的问题。CRUD 中的 U 是我最不喜欢的，尽管我不喜欢其他字母，这取决于用例。但是我们来谈谈 u .泛型更新方法允许客户端更新资源的任何字段，然后用新版本覆盖现有版本。然而，如果您允许客户端这样做，那么您的服务 API 在它所使用的底层数据存储之上提供的价值就很小。服务层的一个关键增值是在底层数据之上实施业务约束，资源*总是*最终受到业务约束。

但是我们不能在我们的更新方法中添加业务约束吗？让我们以一个简单的银行账户资源为例，看看会发生什么。首先，客户不应该能够调用一个 API，然后随意更新他们的账户余额。这个账户可能有最低余额。好，所以您向 update 方法添加了一些检查，这样，如果帐户余额值发生更改，它必须在指定的范围内。问题解决了？嗯，不，不是真的。任何平衡调整都应该被记录为某种交易，对吗？这是信用卡吗？借条？一次转移？如果客户试图更改账号怎么办？这是允许的吗？这会破坏其他数据关系吗？不难看出，我们问的问题越多，您的 update 方法实现就越快变成意大利面条式代码。我见过一些团队沿着这条路走下去，他们的代码试图从被更改的字段中推断出客户的意图是什么，而代码最终却一片混乱。

那么还有什么选择呢？就个人而言，我是[领域驱动设计(DDD)](https://en.wikipedia.org/wiki/Domain-driven_design) 的忠实粉丝，可以设计任何种类的 API。DDD 基于这样一个想法，即软件应该在现实世界的问题被解决后被建模。它创造了一种语言，用于根据被称为*实体*或*集合*的关键业务对象来描述软件。它还定义了一些术语，如*服务*、*值对象*和*存储库*，它们一起工作来解决特定业务领域中的问题，或者用 DDD 术语来说就是*有界上下文*。您不必使用 REST 来使用 DDD，然而，我发现它与 REST APIs 一起工作特别自然，因为 REST 资源非常好地映射到 DDD 实体。

那么这一切意味着什么呢？这意味着你的 API 应该以领域对象和它们提供的*业务操作*为中心。业务操作是通用更新方法及其所有缺陷的主要替代方法。让我们用前面的银行例子来说明。

对于银行 API，一个明显的域对象(或者用 DDD 术语来说是实体)是一个帐户，它模拟了一个银行帐户。我们不应该遵循帐户的 CRUD 模型，而应该定义对银行帐户有意义的特定业务操作。下面是一组很好的写操作:

1.  开-开一个新账户。
2.  关闭-关闭现有账户。
3.  借记-从账户中取钱。
4.  信用——将钱存入账户。

这些操作是特定的，可以强制实施某些业务约束。例如，我们可能不想允许贷记一个已关闭的帐户，我们可以强制执行最低余额检查作为借记操作的一部分。在读取方面，我们还可以提供与我们的客户端用例相匹配的特定查询:

1.  Load -通过帐户 id 加载单个帐户。
2.  交易历史-列出一个帐户的交易历史。
3.  客户帐户-列出给定客户 id 的帐户。

现在我们知道了我们的业务操作是什么，下面是一个将它们映射到 REST API 的例子:

1.  过账/开户-开一个新账户。
2.  PUT /account/ <accountid>/close -关闭现有账户。</accountid>
3.  PUT /account/ <accountid>/debit -从账户中取钱。</accountid>
4.  PUT /account/ <accountid>/credit -把钱加到账户上。</accountid>
5.  GET /account/ <acountid>-按账户 id 加载单个账户</acountid>
6.  GET /account/ <accountid>/transactions -列出一个账户的交易历史。</accountid>
7.  GET/accounts/query/customerId/<customerid>-列出给定客户 Id 的帐户。</customerid>

这看起来与基本的 CRUD API 有很大不同，但关键是允许的操作是特定的和定义良好的。这为服务实现者和客户都带来了更好的体验。服务实现不再需要根据更新的属性来猜测隐含的业务操作。相反，业务操作是显式的，这导致更简单、更易维护的代码。在客户端，什么操作可以执行，什么操作不可以执行，这一点要清楚得多。如果 API 被很好地文档化，例如，使用一个 [Swagger](https://swagger.io/) 定义，那么每个 API 的约束是什么也是非常清楚的。

以这种方式定义 API 比简单的 CRUD 生成器需要更多的预先思考，但我认为这是一件非常好的事情。如果你计划将你的 API 公开为一个公共端点，你将不得不在很长很长的时间内支持这个 API。基本上按软件标准把它想成永远。我总是鼓励团队在以后很难改变的事情上花时间，API 是我给出的第一个例子。

因此，抵制遵循服务 API 的 CRUD 模型(REST 或其他)的冲动。相反，使用 DDD 根据域对象和可以针对它们执行的业务操作来定义 API。

如果您想看更多根据域对象定义 API 的例子，我推荐查看 Amazon Web Services APIs。查找任何服务的开发人员指南，他们应该从“关键概念”或类似的部分开始。在那里，它们描述了服务的概念域对象。例如，S3 定义了像桶、对象和权限这样的对象。Kinesis 有流和碎片。一旦理解了服务的域对象，查看 API 参考并浏览该服务的 API 列表。您会注意到，API 是围绕这些域对象构建的，这使得理解和使用起来更加直观。

希望这有所帮助！