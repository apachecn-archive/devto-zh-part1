# 实践回顾中的 Java 并发

> 原文：<https://dev.to/horia141/java-concurrency-in-practice-review-me4>

这是 Brian Goetz，Tim Peierls，Joshua Bloch，Joseph Bowbeer，大卫·福尔摩斯和 Doug Lea 写的关于实践中的 Java 并发性的书评。作者是 Java 世界的名人录。*TL；这是一本非常好的书，你应该出去读一读。我在现代并发编程、过去的基本线程/进程和基于锁的并发性方面没有太多经验，读了这本书后，我觉得自己的见识和准备都好了很多。*

这是一本相对较短的书，大约 350 页，而且基本上是一本容易阅读的书。目标受众是希望更深入地研究并发性的 Java 程序员。这本书传递了。它既着眼于 Java 5.0 和 6.0 的并发工具——队列、锁、线程池等，也着眼于底层的并发原语——原子、等待/通知等。最后，还有关于并发性问题的标准讨论:竞争条件、数据竞争、安全性和活性问题等。

这本书有四个部分，长度大致相等，但从“初学者”到高级。

第一部分，“基础”，处理并发的标准问题，以及应用工程师应该如何看待它们。比如安全性和活性、原子性、问题发生的时间、Java 中的基本同步等等。都在这里处理。有一堆关于*坏*代码和*好*代码的例子。这是他们贯穿全书的东西，也是这本书真正的亮点。糟糕的代码特别适合作为一个小谜题，告诉你什么会出错。

第二部分“构建并发应用程序”是一个更高的层次，并引入了很多较新的 Java API，如`Executor`、对取消和中断方法的深入讨论、线程池和`ThreadPoolExecutor`。甚至还有关于图形用户界面应用的讨论。对于桌面 Java 来说，这已经不再那么相关了，但是对于 Android 来说，这可能是有用的。

第三部分“活性、性能和测试”，首先处理并发程序的祸根:死锁和其他并发活性问题。虽然第一部分关注的是安全——获得没有错误行为和没有数据竞争等的代码，但这一部分关注的是实际上设法做一些事情，而不是陷入等待它不能获得的锁等的代码。并发程序的性能和可伸缩性是它的自然延伸。最后，关于测试并发程序的一些问题结束了这一部分。

最后一部分，“高级主题”，涉及 Java 5/6 中新的显式锁- `Lock`、`ReentrantLock`、`ReadWriteLock`，锁选择的公平性问题(这是一个有趣的概念，尤其是对性能的影响)，构建像锁一样“同步”的定制对象等等。讨论了原子变量和一些漂亮的非阻塞算法，最后，简单介绍了 Java 内存模型。我喜欢它是如何根据分布式编程中的[“发生之前”关系](https://en.wikipedia.org/wiki/Happened-before)来定义的。

我喜欢这本书的一点是，它比 Java 有更广泛的适用性。所讨论的许多概念和问题都非常普遍，适用于任何并发程序，实际上，适用于任何分布式系统。但是，即使是对特定 Java APIs 的讨论也是可重用的，因为，例如，C#和 C++/Rust/C 在内存模型、相似的 API 等方面有非常相似的语义。

不管是谁，试试这本书，你不会后悔的。

* * *

[1]这主要是标准审查。真的不值得去读那些不适合“一般”主题的书，因为它们太多了。我敢打赌，如果我*有*去研究流形上的代数拓扑或其他一些深奥的领域，我会读完一本糟糕的书。但这里不是这样。