# Lumi4 - init()

> 原文:[https://dev.to/ladvien/lumi4-init-1fk1](https://dev.to/ladvien/lumi4-init-1fk1)

## Lumi4

这是三年项目的下一次迭代。以下是当前的迭代:

1.  Vorpal Hoff -尝试使用 HM-11 和 LPC1114 组合进行无线上传。用 C / C++编写(2014 年 5 月 22 日初始化)。
2.  HM-1X Aid -这个项目是 HM-1X 模块之上的一个 GUI，允许“容易”地编辑模块的行为。这是我第一次尝试 C#。(太糟糕了；尽管串行通信是异步的。)(2015 年 12 月 19 日初始化)
3.  这是第一个成功的 TinySafeBoot 上传程序。它是用 C#编写的，使用。NET WinForms。不幸的是，它是同步的。在我意识到 WinForm 的. NET 中没有简单的 BLE 支持之前，我已经完成了 USB 到 UART 的上传
4.  这是事情开始好转的地方。这是 TSB 无线引导程序的最新版本。它工作，是异步的，并且有 BLE 支持。不幸的是，代码变成了意大利面条。这很大程度上是因为我对面向对象设计的理解很差。它有上帝模块，一个可怕的串行事件响应协议，糟糕的封装，没有多态性。就是一团乱。(2016 年 3 月 21 日初始化)
5.  [lumi 3](https://github.com/Ladvien/Lumi3)——这个项目被提前叫停了。这是一个使用 Xamarin 表单构建多平台上传器的尝试。它将允许 iOS、Android 和 Windows 版本的应用程序。不幸的是，这是一个相当复杂的项目。理论上，上传程序的工作方式是允许用户从 Dropbox 中选择一个十六进制文件，使用 BLE 或 WifI 与 TinySafeBoot 握手，然后上传该十六进制文件。尽管这在理论上是可能的，但需要学习两个新的 API:xa marin Forms 和 Dropbox。我的重点是对语言惯例和面向对象程序设计的自由实践，而不是通过两个新的 API。最有可能的是，我会在 lumi 4(2017 年 1 月 13 日)之后回到这个项目

## 为什么？说真的，伙计

很重要的一点是，这个为期三年的项目的目标并不是生产一个有效的产品，尽管这是第二位的。这些反复尝试的目的是为了作为开发者的提升。

当然，我不相信如果我尝试足够多，吃我的小麦，我会成长为一个伟大的开发人员。但是每一次迭代，我都专注于开发一些新技能。这个学习策略来自安德斯·埃里克森的《巅峰》一书。持续的*和*故意练习被爱立信标记为“[故意练习](https://en.wikipedia.org/wiki/Practice_(learning_method)#Deliberate_practice)”带着*这种*心态，我着手这个迭代编码项目，希望每次迭代代码都有所改进，但更重要的是，我作为开发人员的技能有所提高。

## 聚焦

有意识的练习包括选择特定的缺陷来关注。这更有效，因为提高是在几个有意的领域，而不是试图一次练习一项技能的每一个重要的细微差别。这似乎很容易落后；尤其是在开发人员技能方面。太多了，无法一次尝试和完善。

遗憾的是，在本系列的前几个代码库中，我并不是有意专注于实践的。直到 Lumi3 和 Lumi4，它才在我发展技能的过程中变得至关重要。

## lumi 4 中的目标区域

我想在 Lumi4 中练习的领域

*   项目管理
*   项目日志
*   抽象
*   包装
*   物件的颗粒化(避免神物)
*   有意义的名字
*   C#约定(命名、格式、位置等。)
*   工厂设计模式
*   观察者设计模式
*   错误处理
*   单元测试

如果一切顺利，我可能会接手的一些领域:

*   集成测试
*   文档 API

## lumi 4 有什么计划？

Lumi4 将有三个基本组件:

1.  蓝牙和 WiFi 的通信处理(可扩展至蓝牙 Classic 和 USB 转 UART)
2.  智能串行显示(例如，识别 ASCII 范围之外的数据并打印为十六进制字符串)
3.  TinySafeBoot 上传器

## 学习主张

*   [编码块播客](https://www.codingblocks.net/)
*   导师(Bdk6)
*   [神话中的人月](https://en.wikipedia.org/wiki/The_Mythical_Man-Month)
*   [峰值](http://www.amazon.com/Peak-Secrets-New-Science-Expertise/dp/0544456238)
*   [单元测试入门- 1](https://channel9.msdn.com/Shows/Visual-Studio-Toolbox/Getting-Started-with-Unit-Testing-Part-1) (视频)
*   [单元测试入门- 2](https://channel9.msdn.com/Shows/Visual-Studio-Toolbox/Getting-Started-with-Unit-Testing-Part-2) (视频)
*   [CLR via C#](https://www.amazon.com/CLR-via-4th-Developer-Reference/dp/0735667454/ref=sr_1_1?ie=UTF8&qid=1489414165&sr=8-1&keywords=clr+via+c%23)

## 单元和集成测试

测试让我着迷。当我学习心理测量学的时候，有一系列测试来检验仪器是否如预期的那样工作。在心理学领域，这些是有效研究和实践的基础。为什么我们用了[彩管](https://en.wikipedia.org/wiki/Cognitive_processing_therapy)？因为它通过了各种测试来证明功效。在开发人员的世界里，测试仍然让我着迷。他们始终如一地证明产品能够完成其设计目标。

当然，我一直在项目中采用测试。这在很大程度上与不了解如何设计测试来达到目的有关。直到我听了关于编写单元测试的编码块(#54 - [编写令人惊奇的单元测试](http://www.codingblocks.net/podcast/how-to-write-amazing-unit-tests/))一集，我才更加适应测试。具体来说，当他们讨论单元测试和集成测试之间的差异时。

当我第一次尝试为一个项目编写测试时，那是单元测试。不幸的是，这个项目是我的米露上传程序的第二次迭代，测试导致了混乱。这是因为我试图测试依赖于其他系统输入的功能。

例如

```
 [TestMethod]
    public async Task<bool> shouldStartBLEWatcher()
    {
        // Arrange
        blueTestObject.init();
        await blueTestObject.startBLEWatcher(8);

        return true;
    } 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这是我在一个方法上编写单元测试时所做的，该方法旨在测试 StartBLEWatcher()方法是否工作正常。在单元测试中，该方法的输出应该有一个断言，但是 StartBLEWatcher()返回了发现的 BLE 设备(是的，我意识到该方法可以重写得更好，这就是本文的原因)。这就是我感到沮丧的地方。“我怎么能在与其他硬件交互的代码上编写单元测试呢！?"我的意思是，我明白，单元测试是专业程序员的饭碗。它有助于建设大型项目，否则这些项目会在规模之下崩溃。但是我该如何为依赖于外部系统的代码编写单元测试呢！？萨尔迪，我发现答案太晚了:你没有。

在编码块章节中，我们讨论了单元测试和集成测试之间的区别。单元测试意味着测试一小段代码，它不应该依赖于其他代码。集成测试检查一段代码是否按预期工作。然而，与单元测试不同，集成测试*根据其定义确实依赖于外部系统。*

当我听到这个讨论时，我找到了关于这个问题的第一个 StackOverflow 答案:

问题:“集成和单元测试的区别是什么？”

回答(由[内森·休斯](http://stackoverflow.com/a/5357837)

单元测试是由程序员编写的测试，用来验证一段相对较小的代码正在做它想要做的事情。它们的范围很窄，应该易于编写和执行，其有效性取决于程序员认为什么是有用的。这些测试是为程序员设计的，它们对其他人没有直接的用处，但是，如果它们完成了自己的工作，测试人员和下游的用户应该会从看到更少的错误中受益。

单元测试的一部分意味着被测试代码之外的东西会被嘲笑或剔除。单元测试不应该依赖于外部系统。他们测试内部的一致性，而不是证明他们可以很好地与一些外部系统合作。

进行集成测试是为了证明系统的不同部分可以协同工作。集成测试覆盖了整个应用程序，它们需要更多的努力才能组合在一起。它们通常需要为它们分配数据库实例和硬件等资源。与一组单元测试相比，集成测试在演示系统工作(特别是对非程序员)方面更有说服力，至少在集成测试环境类似于生产的程度上是如此。

实际上,“集成测试”有很多种用途，从针对模拟生产环境的全面系统测试，到任何使用非模拟资源(如数据库或队列)的测试。

嗯，暂时就这样了。