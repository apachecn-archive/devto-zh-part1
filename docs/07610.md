# 好的测试，坏的测试

> 原文:[https://dev.to/danlebrero/good-tests-bad-tests](https://dev.to/danlebrero/good-tests-bad-tests)

*本文原载于[我的博客](http://danlebrero.com/2016/11/06/good-test-vs-bad-tests/)T3】*

单元测试，如同任何实践一样，可能会变得荒谬。关于这件事我已经写过。

事实是，编写好的测试和编写好的产品代码一样困难。这需要实践，并且需要仔细的思考，但是我已经多次看到测试是如何被当作二等公民对待的，这通常意味着我们没有获得一个好的测试套件的全部好处，最终得到的套件更多的是负担而不是资产。

一个好的测试套件:

1.  给你信心。
2.  查找 bugs
3.  维护成本低廉。
4.  记录系统。
5.  鲁棒性。
6.  没有 bug。
7.  就是跑。

## [](#confidence)自信

做出更改后，运行您的测试是否足以提交代码？并部署到生产中？

我的经验告诉我，单元测试是不够的，需要某种类型的[全栈](http://martinfowler.com/bliki/BroadStackTest.html)、BDD 和集成测试来提高可信度。

请注意，如果两个测试给你相同领域/功能的信心，其中一个是多余的。

此外，如果你真的对你的测试很有信心，但是你仍然将 bug 发布到产品中，你的信心是错误的。

## [](#find-bugs)发现 bug

如果你有一个从来没有变红的测试套件，你的测试没有给你任何价值，因为它们没有捕捉到任何错误，这是它们存在的主要原因。

## [](#cheap-to-maintain)廉价维持

如果当你去重构你的代码时，你发现自己花费了大量的时间来修复或者重写你的测试，你的测试套件是没有回报的。我发现，如果你的单元是类，如果你使用了大量的模拟对象——在大多数情况下，你最终会得到[过度指定的软件](http://xunitpatterns.com/Fragile%20Test.html#Overspecified%20Software)，这一点尤其正确。

## [](#document)文档

测试应该告诉我们系统做了什么，以及为什么会这样做。

最少的一组测试也应该告诉我们它是如何做到的，但是当我们进行相当大的重构时，这些测试应该会被丢弃。

## [](#no-bugs)没有 bug

要知道一个测试正在测试它应该测试的东西，也就是说，测试没有错误，最好的方法是当您在生产代码中进行更改时，看到测试从红色变为绿色。

这就是为什么您应该在生产代码之前编写测试。

还要考虑[突变测试](http://pitest.org)来找到你的套件上的盲点。

## [](#robust)健壮

如果你的测试套件有一个古怪的测试，一个随机变红的测试，它将破坏整个测试套件，因为人们不再关心它。

最好把这些片状的测试拿走，而不是把它们留在身边。

## [](#run)运行

也许这听起来有点傻，但是我已经看到并编写了很多没有邀请运行的测试。其中包括:

*   注释掉或@忽略的测试。
*   非常慢的测试。
*   需要一些手动步骤的测试，如安装数据库、应用程序容器或消息代理。
*   无法从 IDE 中运行或调试的测试。

* * *

总之，一个好的测试套件将是允许我们发展和改变我们的系统的支柱。

测试必须支持变化，而不是抑制变化。

归根结底，正如迪夫·托马斯和安迪·亨特明智地指出的那样，我们总是在改变现有的系统。

> 所有的编程都是维护性编程，因为你很少编写原始代码。
> 
> 当你第一次输入时，只有前 10 分钟的代码是原始的。就是这样。