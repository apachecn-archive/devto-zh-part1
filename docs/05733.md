# 海运集装箱:采用 Docker 的经验教训

> 原文:[https://dev . to/kr 428/shipping-containers-lessons-learn-from-adopting-docker](https://dev.to/kr428/shipping-containers-lessons-learnt-from-adopting-docker)

我们在 2016 年第三季度开始与 Docker 合作，追求在现有系统基础设施中采用它的目标。到目前为止，我们已经部署了几个生产应用程序，并作为 Docker 容器运行。这是一个相当好的方法，可以帮助您将标准融入到您的环境中，并使生活变得更加轻松。虽然它有一个学习曲线，并且许多高级功能可能会让你很快偏离正轨，因为你甚至在不需要它们的时候(还没有)就试图去处理它们。不要试图一步到位地完成容器部署，而要尝试通过一小步一小步地改变您的环境。确保你对每一个增量都感到安全，在所有相关的事情上获得经验，以避免在一个大的改变后失去对你系统的控制。请继续阅读，了解更多…

## [](#what-about-it)那又怎么样？

容器无处不在，Docker 也是如此，它似乎是迄今为止这些技术中最重要和最广泛的。出于各种原因，我们一年前才开始调查此事。事情总是在变。我们的团队结构发生了变化，尤其是在开发和运营方面。技术组件的数量增加了，涉及的不同框架和堆栈也增加了。在另一边的部署应该更容易而不是更困难。战略方法也发生了变化，转向基于行业集团的 IT 基础设施，由中央托管和团队以共同的方式提供专用服务。与此同时，Docker 出现在我们的视线中，并一直呆在那里。

到目前为止，我们已经在 Docker 环境中构建、发布并运行了一系列应用程序模块(暂时避免使用“微服务”这个术语)。它工作得很好，在引入新的有趣问题来解决的同时，它确实减轻了一些事情。我们离完全自动化的连续交付环境还很远，在这样的环境中，每一段代码都自动投入生产。每个工具和每个技术支持的解决方案都有一个学习曲线，处理容器也不例外。然而，我们已经提出了一些见解，我认为这些见解值得注意…

## [](#know-your-problems)知道自己的问题

虽然这听起来显而易见，但是您应该非常非常专注于弄清楚您的环境中实际存在什么问题，以及容器或者更具体地说 Docker 可以如何帮助解决这些问题。这么说的原因很简单:有很多供应商、解决方案提供商和顾问都试图弄清楚他们的客户最终会有什么需求，还有很多工具提供商试图推销他们对基于容器的环境的想法。同样，也有大量的案例研究、白皮书、“最佳实践”等等，概述了要成功地将软件装入容器，你真正需要做的事情。

大部分根本没有错。但是最终你要选择他们的解决方案是否真正解决了你的挑战。如果您的环境运行得非常好，那很好。不要仅仅因为 Docker 这样的技术可以让事情变得“更好”，就爱上它。如果没坏，就别修。

也就是说，我们的问题范围相当清楚:我们希望(ed)稍微调整一下部署过程。随着从一个 Java EE 应用服务器转移到多个内嵌 HTTP 服务器的独立 JVM 应用程序，在某个时候，我们将一个成熟的大型服务器组件的复杂性与维护和运行多个独立应用程序的复杂性进行了交换。情况有所好转，但当然也留下了一些新老问题没有解决。乍一看，Docker 看起来相当不错，至少可以解决其中一些问题。这就是为什么我们开始首先引入 Docker 进行部署和操作，明确地专注于为开发者保持一切“原样”。这是一项非常复杂的任务——开发人员的早期参与会让事情变得更糟。

## [](#set-your-boxes)设置您的箱子

Docker 能为现有 IT 应用程序做的最好的事情之一就是迫使你重新考虑应用程序和依赖关系。在现实环境中，组件和系统之间总有可能存在不明显或没有记录的交互和依赖，因为没有人认为这是依赖。考虑一些简单的事情，比如您的应用程序依赖于某个“就在/usr/bin 中”并从您的应用程序内部调用的 Linux 二进制文件:只要您的应用程序运行在最初部署它的主机上，一切都很好。在移动到一个不同的主机上，并且在基本操作系统发行版中安装了不同版本的不同软件包之后，这种方法还有效吗？或者您的应用程序使用了它期望在/media 中装载的网络文件系统，现在，在移动到一个新的环境之后，它被移动到/mnt？也许这些东西甚至取决于你的应用中的配置——你仍然确定它在相关情况下是明显的吗？你确定你能够很好地处理在某个时间点引入的额外依赖吗？

在这里，通过提供“容器”的概念，与 Docker 打交道极大地提高了对这些问题的认识。它迫使你把你的应用程序更多地看作是封闭的盒子，把应用程序之间的交互看作是这些盒子之间的链接，为了工作，这些盒子必须是明确的。Docker 并不真的需要这样做，但它通过在技术上加强这种容器方法以及提供如何描述依赖性、应用程序之间的通信等方式来帮助实现这一目标:用于容器的基本映像描述了将会出现的操作系统库和二进制文件。装入容器的卷和容器公开的端口描述了它的一些接口。使用 docker-compose 之类的东西，你也能够以更严格的方式描述容器之间的依赖关系(它们必须以什么顺序开始工作，它们是如何链接的等等)。

再说一次:这并不是 Docker 真正需要的，但它确实有助于完成 it 组织无论如何都要做的一些工作。

## [](#start-safe-and-fast)安全快速启动

如今，人们经常谈论“作为代码的基础设施”。如果是这样的话(在某些方面，我认为这确实是一个好主意)，我们也应该将我们想要应用于软件开发的相同规则应用于敏捷，一般来说:专注于在短迭代中提供可见的价值，尝试增量改进，尝试从某处开始，在生产环境中的真实用例中学习，改进。将这种方法转化为基于 Docker 的部署，建议是:确保从纯理论快速进入工作环境。选择一个候选应用程序，学习如何从中构建一个映像，学习如何在容器中运行这个映像。让它在生产中运行，并确保您的(开发)运营团队中的每个人都知道如何处理它，即使您正在度假。

为什么？在一个成熟的环境中，比如说 Docker、CoreOS 等专用操作系统、Kubernetes 等流程编排工具、etcd 或本地或远程 Docker 注册表等配置服务，很快就会有太多新事物引入到您的环境中。对于您的 IT 组织中的相关利益相关者来说，有大量的变更很可能会中断现有的工作流。您的操作人员需要学会管理和习惯这一切，在他们这样做的同时，您的系统稳定性也面临风险。

不要那样做。试着找到一个最小的有意义的增量，并尽可能快地实现它。在我们的案例中，这完全是基于通用工具扩展我们当前的部署流程，例如…

*   ssh/scp 用于在各种服务器之间复制工件，
*   用于在测试和生产环境中启动/停止/更新二进制文件的 bash 脚本，
*   zip 构件来发布二进制文件、启动/停止脚本和最小配置文件，
*   用于运行组件的库存 Ubuntu/Debian 服务器，以及
*   本地 gitlab 服务器和 gitlab-ci，用于构建“常规的”Java / maven 工件和 Docker 映像

使用 Docker cli 和存储到文件中的 Docker 图像。最初，我们甚至在没有本地或中央 docker 注册表的情况下运行，只是使用 docker load 和 docker save 将图像保存到文件中，并再次加载到 Docker 服务器上。Docker 容器本身和以前一样运行在相同的 Ubuntu 服务器上，与现有的应用程序并排运行。Docker 容器仍然使用 bash 脚本停止和重启。

不可能有比这更简单的了，但它确实有效。到目前为止，这对开发者来说没有任何改变。这对运营人员来说变化不大。但它已经提供了一些好处，包括查看容器、日志文件……使用基于 web 的 portainer UI，或者能够更容易地回滚到活动服务器上的旧版本生产代码。对于操作人员来说，这已经是足够的好处来证明处理这个问题是正确的，然而以这种方式引入的变化是可以接受的。

## [](#scale-well)称好

如果你在这里完成了，剩下的部分可能会很琐碎——本质上:重复。找到你刚刚达到的现状中最困扰你的事情，找出如何改善，并在另一小步中实际改善。也许给你的 IT 团队一些时间来熟悉新的结构，并收集关于下一步应该做什么的反馈是一个好主意，即使你有一个明确的议程，你想去哪里。在我们的案例中，以下几个步骤似乎是可取的和必要的…

*   …使用或采用内部 Docker 注册表以实现更好的图像处理，
*   …以更智能的方式处理配置和容器启动/停止脚本，
*   …找到一种比必须将 CIFS 共享装载到所有服务器上更好的方式来处理和交付大型二进制数据文件。我们确实对其中的每一个都有一些想法，但无论是优先事项还是实际的解决方案都没有最终确定。让我们看看这一切将走向何方，如果有什么值得注意的，也许我会在不久的将来重述这一点。敬请关注。

## [](#post-scriptum)后手稿

关于这一点可能还有很多要写，但在某些时候，有人需要阅读所有这些，所以我将保持这一点，如果有人感兴趣，可以进入细节。然而，到目前为止的结论是:在 Docker 和 containers 上花费相当多的办公时间和业余时间是有回报的，尽管还有很多可以改进的地方。就个人而言，看着这些东西，我发现在听播客和同时阅读 DevOps 和敏捷软件开发的书籍和文章中有很大的见解和娱乐。我发现大多数开发人员(嗯，有时包括我自己)可能会推动伟大的、功能丰富的新版本或新技术或新框架，以及这些天来所有可能的铃铛、口哨和厨房水槽。与此同时，我完全理解每一个运营人员应该坚持一种更保守的观点，即尽可能少地对生产环境进行任何更改(或者最好避免更改)，因为他们知道更改是稳定的敌人。敏捷开发和 DevOps 文化似乎是解决这种“冲突”的好方法——尽管并不容易，原因有几个。但那是另一回事…

*原贴[在我的博客](http://dm.zimmer428.net/2017/07/shipping-containers-lessons-learnt-from-adopting-docker/)上*