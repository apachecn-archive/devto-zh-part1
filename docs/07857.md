# 迈克的码头小费怪物清单

> 原文:[https://dev.to/mikesimons/mikes-monster-list-of-docker-tips](https://dev.to/mikesimons/mikes-monster-list-of-docker-tips)

我本打算把这个列表变成某种怪物文章，或者把它分成几篇。我不擅长写东西，所以与其让它烂掉不发表，我会照原样出版它。

这个经验来自于 2 年多来在实际工作中对 docker 的评估和使用。其中一些可能是垃圾。我管理的最大节点部署是 50 个，所以不是超级规模。超过这个范围，有些事情会有所不同，但我很确定，在这个范围之下，大部分事情都适用。

## [](#on-the-marketing-touted-benefits)在营销上/吹捧上的好处...

### [](#one-big-pool-of-compute)“一个大计算池”

这是个好主意，但是问问你自己，你是否真的需要它，或者你只是觉得这个主意很酷。如果你觉得你需要这个，先试试 docker swarm。这并不性感，但如果你能在 swarm 上运行你的东西，你肯定能在任何其他的 orchestrators 上运行。寻找 swarm 所提供的差距，并在此基础上做出编制决策。

管弦乐队不是自由的；它们会让你付出操作复杂性的代价，并且在你想出如何使用它们的时候，会降低你判断到底发生了什么的能力。

### [](#build-on-dev-and-ship-artifact-to-production)“基于开发构建并将工件交付生产”

这是一个可怕的想法。通过让开发人员的机器构建二进制工件，你将会放弃生产，你会让自己暴露在无数的坏事面前。映像必须在 dev 上运行，但是工件应该在 CI 管道开始时生成，并提升到生产中。其他的都是疯话。

### [](#homogeneous-nodes)同质节点

现在我们有进展了。虽然您可能需要一些工作负载在大型机器或具有特殊硬件的机器或具有特殊部署特征的机器上运行，但大多数情况下并不需要。

通过大致平等地对待所有节点，您可以大大简化对它们的管理。对于初学者来说，你只需要一个配置管理角色来管理所有的机器；都是码头机！

重新调整节点的用途也非常容易。如果你曾经试图用配置管理工具将一台机器从一个目的完全转向另一个目的，你就会知道这有多糟糕。

使用容器很简单:移除旧容器，启动新容器

### [](#app-isolation)App 隔离

很明显，当你在一个容器中运行应用程序时，它们是用自己的 dep 集合隔离的。这对应用程序来说很酷，但对运行应用程序的节点来说也很酷。您不用太担心(几乎完全不用)主机包升级会破坏应用程序。

## [](#general-advice-for-building-containers)建造集装箱的一般建议

### [](#build-smart-containers)构建智能容器

我不知道这是否有专门针对容器的名称，但 Joyent 称之为“自动驾驶模式”。

其思想是容器在配置自身、配置与外部服务的健康检查以及为自身提供/配置监控的能力方面是完全自包含的。他们编写了一个名为 [containerpilot](https://www.joyent.com/containerpilot) 的工具来简化这一切。

Containerpilot 为 consul 提供服务注册、运行协流程(如度量导出器)的能力、调度任务(如 cron)等。

让你的容器自给自足可以通过动态放置来解决一些令人头疼的问题。

### [](#but-generic-containers)但是...通用容器

反对工具知道它们嵌入的平台的通常论点是，如果你这样做，它们就不再是通用的；容器应该与指标提供者无关，这样您就可以共享它。扯淡。一般的说法只适用于公众可消费的图片**和**。如果您有一些普遍适用的东西，并且您希望使用多个映像，那么可以在一个单独的映像中使用这个功能(或者更好的是，将它推到上游),并从中派生出所有其他的功能。使用`FROM upstream-image:version`您没有理由不创建一个特定于您的工具的本地 docker 文件，并且您应该这样做！

### [](#but-single-process-per-container)但是...每个容器一个流程

我一直不明白这个。我个人认为应该是“每个集装箱一个目的”。您不希望在您的映像中出现大量随机垃圾(当然也不希望出现像 SSHD 这样的东西)，但是您只是给自己带来了不必要的麻烦来强制执行每个容器一个进程的策略。

以 nginx 和 PHP-FPM 为例。`nginx.conf`需要特定的 fpm 配置，包括 webroot、与 fpm 对话的套接字和后端块。FPM 不需要 nginx 的任何东西，但如果你在一个单独的容器中运行它，你需要匹配 webroots 并监听 TCP，因为你不能共享 unix 套接字。

如果 fpm 死了，那么 nginx 就不能服务 PHP(你得到 502)，但它会继续运行。如果你有很多独立的静态内容，这很公平(但是我工作过的使用 PHP 的人都没有)。如果 nginx 死了，那么 fpm 就没用了，但会继续运行...不多。

如果你把它们放在同一个容器中，那么 webroots 自然匹配，你可以使用 unix 套接字，使用 containerpilot，你可以把 nginx 作为主进程，把 fpm 作为协进程，如果它死了，就会重新启动。

将这两者分开没有什么好处，而将它们放在同一个容器中有很多好处。

这两个不是唯一的例子，但它们是我遇到的反对“每个容器一个进程”的最有力的论据。

### [](#always-derive-images)总是导出图像

不要使用公开可用的映像，然后将一堆垃圾塞进另一个容器中，因为您不想修改公开的映像。取公共的，派生出来，使之具体化。这允许您管理此映像的生命周期，如果您在自己的 repos 中为您使用的每个映像创建一个 docker 文件(即使您没有修改它们),那么它们自然可以拥有与您的其他映像相同的 CI 流程。

### [](#sidekick-accessory-containers-suck)Sidekick /【配件】容器吸

Sidekick 容器是一个黑客。Docker 没有办法耦合这些容器的生命周期，所以如果您杀死了您的主服务，但没有杀死您的 prometheus 助手，那么它将永远在那里喷涌错误(嗯，除非它有错误策略，但您不应该依赖这一点)。

出于同样的原因，插入您的服务的“Cron”容器也是黑客。

Kubernetes 有点侥幸(有点)，因为它管理 pod 容器的生命周期，但我仍然会推荐智能容器而不是依赖于 pod，因为智能容器可以从 kubernetes 中携带出来，而 pod 不能。

### [](#dont-parameterize-all-the-things)不要参数化所有的东西

预先参数化所有的东西是完全没有必要的。参数化变量越多，出现可怕组合的可能性就越大。

### 当你参数化事物时，**记录下来！**

ENV 变量是参数化容器的好方法，但是要确保以某种方式记录它们(比如 Dockerfile 旁边的 README.md)。

### [](#if-youre-used-to-config-management-tools)如果你习惯配置管理工具...

我不得不应对的最大变化是配置逻辑从收敛转移到运行。那些包罗万象的 apache chef 模板…是的，当容器启动时，您需要填充那些**。**

在某些时候，你**将**需要容器中的模板。很多选择。领事-模板，如果你是从领事拉。

### 没有为容器构建配置管理工具

Dockerfiles 是最好的。是的，你可以使用配置管理工具，但你真的不需要。你只是把它复杂化了，因为这些工具是为运行带有服务的系统而设计的，并不值得担心。图像不是那样的。

### [](#jq-rocks)JQ 岩石

在某种程度上，你需要混合使用 JSON。jq 是这方面的炸弹。

### [](#privilege-dropping-applies-in-container-land-too)优惠投放也适用于集装箱陆地！

总是在容器中创建一个用户，并使用 gosu 或类似的方法来删除特权，但避免在 docker 文件中创建用户。它扰乱了构建过程，如果是从使用它的映像中派生出来的，可能会特别混乱。

### [](#label-up-your-dockerfiles-amp-images)给你的 docker 文件贴上标签(&图片)

用元数据标记图像(git 版本、构建日期、git url 等)。参见[微型贴片机](https://microbadger.com/labels)。如果你发现一个没有图像标签的旧容器漂浮在周围，你会感谢你自己。当重复使用图像标签但旧图像继续运行时，会发生这种情况。这不是你应该养成的习惯，但它确实发生了。

如果您的 docker 标签与 git 版本不匹配，这也很有用，因为您可以从正在运行的容器快速获得 repo & SHA。

### [](#dont-reuse-tags)不重用标签

重用图像上的标签是一个非常糟糕的主意，原因如下:

*   `FROM my-image:v1`的含义改变了，你不能保证不会破坏衍生图像
*   当有人获取这个图像的新版本时，任何使用这个图像的运行中的或旧的容器都会丢失它们的图像名称和标签！
*   使派生图像更难确定它们是否使用最新版本或落后多少

### [](#add-root-)添加根/ /

如果你需要给一张图片添加一堆文件，我发现`ADD root/ /`是最好的方法。它使文件的预期位置显而易见，而无需在 docker 文件中挖掘，并且如果您在所有图像上这样做，它会增加一致性。这也意味着您的文件都添加在一个层中。

这里唯一的例外是有条件的文件和需要插入或生成的文件。这些人应该生活在这个结构之外，并逐案处理。

### [](#verify-those-checksums)验证那些校验和！

如果你下载文件在容器中使用，你**必须**验证它们。简单的 sha256sum -c 检查就足够了。因此，使用`RUN curl http://... && echo "<sha> <file>" | sha256sum -c`而不是`ADD http://...`

### [](#be-wary-of-community-images)警惕社群形象

请记住，您信任任何第三方容器作者来扮演好。Docker registry 不支持不可变的标签，所以除非你使用公证人，否则你下面的东西绝对可以改变。最重要的是，大多数容器很可能是“我曾经黑过这个项目，不会被维护。我并不是说不要使用它们，但我会提出以下建议:

1.  获得用于构建映像的源代码，并在您自己的 CI 管道中构建它。
2.  在所有的扫描仪和 CI 程序中运行。
3.  像对待一个对 facebook 比健康更感兴趣的实习生写的一样对待它。
4.  通过初步审查后，将其作为内部文件。

### [](#image-scanning)图像扫描

考虑一个支持安全扫描的注册中心(比如[quay . io](https://quay.io))；如果没有它，您应该在 CI 流程中自己扫描图像。这些工具都是新生事物，IME 需要很大的毅力。 [coreos/clair](https://github.com/coreos/clair) 和[openscap/container-compliance](https://github.com/openscap/container-compliance)就是两个例子。

### [](#consider-upstream-change-policy)考虑上游改变政策

您需要考虑如何跟上(或不跟上)上游的变化，这样您就不会运行一个已知的易受攻击的映像。

### 如果没有必要，不要包含你的构建链

只有当你在一个容器中编译你的应用时，这才真正适用。您的生产部署(可能)不需要 gcc 或 go 编译器，更不用说您的源代码了。

确保如果您在一个容器中构建，您正在导出工件并且只打包您需要的东西。

部署大型映像需要不必要的时间、存储空间和传输带宽。

## [](#containerpilot-specifics)集装箱领航详情

更喜欢将 consul-template 作为一个协同过程，而不是后端来观察服务。consul-template 的功能更加全面，我曾经遇到过后端 onChange 脚本在我认为应该触发的时候没有触发的问题。

总是将`CONSUL`作为一个 env 变量来传递，以便能够在不同的 env 中运行

将所有的生命周期脚本放在一个地方。我使用/scripts。如果需要，可以很容易地找到并手动触发它们。

## [](#consul-specifics)领事详谈

### [](#use-the-gossip-encryption)使用八卦加密

使用 gossip 加密，并对每个 env 使用不同的密钥。这将允许你在它们接触的时候强行分开它们。当我说领事流言协议的自愈特性非常有效时，我可以根据经验说话。

### [](#understand-quorum-amp-how-to-maintain-it)了解法定人数&如何维持它

如果您在 HA 中操作，请确保您了解 quorum 是如何工作的，以及如何安全地删除服务器。超级简单，以后会让你省心。如果执政官失去了法定人数，它将不会服务的请求。

法定数学是基于整数的。仲裁的最低要求是 N/2 + 1 个可用节点，其中 N 是群集知道的服务器数量。因此，如果 N=3，那么您需要 N/2+1=2 台服务器来服务请求。

### HA 中最少的服务器

如果仅仅是出于维护的原因，那么三个服务器是 HA 的最低配置。如果你需要领事总是可用，但仍然希望实际维护领事，那么你至少需要一个备用的。

### [](#network)网络

尽可能避免将 consul 暴露给公共接口。这就是我们所做的。

在咨询客户时，TLS 支持似乎有点断断续续。ACL 令牌也是如此。如果我再做一次，我会默认使用 TLS 和拒绝所有 ACL，并尝试解决任何 consul 客户端问题。

## [](#docker-is-not-magic-service-architecture-is-important)Docker 不是魔术。服务架构很重要

### [](#zero-downtime-deploys-are-easy)零停机部署非常简单...

如果你有容错服务。要做到这一点，所有关键服务中至少有两个必须负载平衡/处于服务状态。远离无法实现负载平衡的服务。警惕需要被动副本的服务，因为它们(IME)通常有笨重的故障转移程序。

### [](#firedrill-failures-frequently)消防演习故障频发

关闭服务，切断网络，滥用基础设施，确保一切正常运行。如果你有一个“龙在这里”类型的服务，没有人想碰你**肯定**需要用这个演练。

### [](#data-portability-or-not)数据可移植性(或不可移植性)

数据可移植性不是一个已解决的问题。这就是“不要容器化有状态服务”。

有些服务可以自动复制，但这并不意味着你可以免费获得可移植性。重新平衡数据的强度超出了微小数据集。

像弗洛克这样的卷管理人员应该能够在一个 DC 内解决这个问题，但我还没有去过那里。

如果您不知道这些工作，可以通过配置 SAN /云卷并将它们附加到一台机器上来实现。如果 docker 容器关闭，卷会被分离，当您启动一个新的容器时，它会重新连接卷(可能在不同的机器上)。显然，这在可移植性方面有局限性，但最终我们不应该需要这样的工具。

### [](#some-tools-just-suck-operationally)有些工具只是操作上吸...

有些服务只是一个皮塔饼，从中获得容器的好处。詹金斯就是一个很好的例子。因为执行器队列是内部状态，所以很难进行负载平衡或迁移到新的主机。

## [](#deploying-docker%C3%A2-hosts)部署码头主机

### [](#avoid-environment-envy)避免环境嫉妒

如果将服务放在主机上是有意义的，就这样做。Cadvisor 就是一个很好的例子。这是一个单一的二进制+系统单元，如果你想在 docker 中运行它，你必须绑定安装 7 个不同的位置或任何它需要的位置。这有点羡慕特性的味道(用程序员的话来说)。

顺便说一句，如果你使用 CentOS 和 cadvisor，你必须把它放在主机上，否则你会遇到内核 3.19 中嵌套绑定挂载的一个讨厌的小错误，它会阻止你在 cadvisor 运行时干净地停止任何容器。

### [](#use-a-config-management-tool)使用配置管理工具

您仍然需要调配这些主机。如果你有一个训练有素的团队或者只有几台服务器使用 ansible。没有纪律的团队或很多(像数百)服务器考虑厨师。Ansible 完全可以处理这么多，但是不能用惯用的有良好文档记录的方法。Chef 只对少数服务器来说是大材小用，但 chef 服务器的最终融合和疯狂的良好性能意味着它使处理大量机器变得轻而易举。

### [](#use-said-config-management-tool-properly)正确使用所述配置管理工具

确保它频繁且完全地收敛。ansible 可能会倾向于一次运行一个游戏，这可能会留下一些碎片。

### [](#use-config-management-to-provision-storage)使用配置管理来配置存储

确保您的配置管理工具可以重新配置 docker 存储池(如果适用)。如果你把球扔了，球又满了，那就是无价之宝。

### [](#use-a-not-ancient-kernel)使用一种不古老的内核

如果你部署在一个旧的内核上，你会有一段不好的时间。这里的旧是指任何比 4.x 旧的东西。

### [](#dont-use-centos-rhel)不要用 CentOS / RHEL

CentOS7 / RHEL 搭载了 3.10 内核，他们并没有反向移植所有的错误修复。在最近的内核中已经修复了一些非常讨厌的错误，它们正等着咬你的屁股。

如果您坚持使用 CentOS7 / RHEL，因为您的 IT 人员都是毒品专家，那么带有专用 LVM 精简池的 devicemapper 是存储的最佳选择。

不支持在 CentOS7 上覆盖。我的意思是，它工作…直到它不工作。如果您不经常启动/停止容器，这似乎没什么问题。在高峰时期，我们启动和停止容器的频率高达几分钟，我在这里的主要经验是恢复由于覆盖导致的文件系统错误而耗尽/var 空间的节点。

### [](#storage)储存

出于对一切可爱事物的热爱，不要使用默认的/dev/loop 存储。如果您必须以任何频率启动和停止容器，那就太不可思议了，它会填满您的/var 分区(所有日志通常也放在那里),并且一旦它消失了，您就无法从 sparsefile 中恢复空间。

我推荐 overlay2 存储，因为更好的性能，更稳定，它现在在主线内核中。

ubuntu 上的 Devicemapper 可能工作得很好，但我没有直接的经验，我听说 RH / CentOS 的人有 DM 魔法酱。YMMV。我不明白你为什么要在桌子上做这个。

当心覆盖驱动程序吃掉索引节点。我记不清确切的情况了，但他们用 overlay2 解决了这个问题。如果可以的话，优先使用它来覆盖。

如果您有大的图像，您可能需要启动 dm.basedev 选项。

### [](#tls)TLS

如果考虑一个群或者通过 HTTP 暴露引擎，从一开始就使用 TLS 在奔跑的蜂群中改造是一件痛苦的事。在这里，square/certstrap 帮了大忙。

### [](#logdriverjournald-ftw)- log-driver=journald FTW

如果运行 systemd，journald 无疑是 IMO 的最佳日志选项。所有的系统和容器日志都经过日志和元数据，并可以导出到 JSON。然后，这可以通过管道传输到 logstash 或一些远程系统日志。我更希望有弹性的人能写一个本地的 journald 和 beat，但是现在有一个社区版本(当时它不符合我的要求)。

即使你没有集中日志，这也给你提供了一个简单的选择，docker 日志仍然可以工作(不像其他的日志驱动程序)。

## [](#care-and-feeding-of-docker%C3%A2-hosts)码头工人的看护和喂养

### [](#do-not-let-thinpools-run-out-of-space)不要让精简池耗尽空间！

如果使用 DM +精简池，不要让它耗尽空间。您需要重新启动来修复它。你不能重新启动 docker 守护进程，当它耗尽空间时打开的文件句柄将保持打开，即使在我们的经验中杀死东西之后。

### [](#container-gc)容器 GC

使用一些东西来清理停止的容器和未使用的图像，否则它们会吃掉你所有的空间，扰乱没有配额的容器群调度。

## [](#running-your-containers)运行您的容器

### [](#use-named-volumes)使用命名卷

使用命名卷而不是主机绑定装载。这将允许 orchestrators 调度卷的位置，或者允许您使用对容器透明的替代 docker 卷插件。它还将所有与服务相关的文件保存在一个位置，而不是从整个主机绑定安装。

### [](#dont-put-container-config-on-the-host)不要把容器配置放在主机上

**不要**用配置管理工具在主机上填充配置，然后绑定挂载所有东西。这很容易做到，尤其是当您使用通用容器时，但这会使替换节点或迁移工作负载变得更加困难。

### [](#you-dont-have-to-use-an-orchestrator)你没有*有*使用管弦乐

如果你觉得不需要管弦乐队，就不要用。他们不自由。如果你有 docker-compose 之外的需求，Ansible docker 模块提供了不错的功能，但是如果可以的话，在启动时要小心使用机器特定的事实。

### [](#consul-rocks)执政官岩石

服务注册中心可以提供对平台健康状况的深入了解。领事很优秀，很好管理。如果使用 swarm，还可以充当 KV 背板。

### [](#moar-labels)恐鸟标签

给所有的东西贴上标签。谁启动了容器&何时。如果它坏了，谁会拥有它？如果你的机器是与其他团队共享的(或者你正在使用一个共享的群)，在你启动的时候用这些标签来标记容器，你将会省去一些麻烦。

## [](#secrets)秘密

*   秘密是很棘手的。考虑部署哈希公司保险库。如果你是执政官就更有意义了。
*   如果使用 consul，consul-template 支持 Vault。保管库令牌的分发/获取仍然由您决定，但是这种集成允许您从保管库请求所有类型的东西。密钥、TLS 证书、SSH 登录、TOTP 等。

## [](#running-a%C3%A2-swarm)运行蜂群

*   使用 TLS
*   为 KV 使用 consul，因为服务发现和健康检查是不可或缺的，而且非常重要。一旦你掌握了法定人数的要求，HA consul 也很好操作。
*   仅在需要时部署 HA swarm。如果你需要的话，在 TCP 模式下使用 haproxy 来平衡集群主机的负载。这将通过 swarm 保留 docker exec 和 docker 日志等功能，因为它们劫持 http 连接来运行。
*   在 swarm 中运行任何东西时使用资源配额。如果没有这一点，调度程序依赖于正在运行的容器的数量，包括停止的容器。
*   如果资源配额不合适，请确保快速移除群中所有成员的停止容器，否则它们将永远无法正确平衡。
*   群集是单租户的，它会列出作为其一部分的节点上运行的所有内容。如果不选择 UCP 的 docker 商业产品，就无法限制知名度，这是一个完全不同的领域。
*   对任何在 swarm 中运行的容器使用 containerpilot +健康检查。该服务将在正确的位置注册，并且可以被使用 consul 服务发现机制的其他服务找到。

## [](#running-a%C3%A2-registry)运行注册表

*   尽量不要。有很多便宜的图像存储选择，它会让你省心。
*   如果必须的话，确保使用对象存储。
*   确保您在关闭时使用身份验证门户。让每个人/事物开始认证是痛苦的。葡萄牙语看起来不错，但我们从来没有真正使用它。
*   回收空间需要运行垃圾收集。垃圾收集只能在注册表关闭时运行。垃圾收集速度不快；您必须安排停机时间来处理这个问题！
*   码头工人 DTR 正在……进步……但是有些地方还是有点粗糙。需要 UCP。

# [](#wrap-up)总结起来

哇；仍然巨大。如果你想澄清任何一点(或其组合),请随时发表评论。

喊 BS 也是一样。我一直都是错的；)