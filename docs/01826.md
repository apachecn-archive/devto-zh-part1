# 面试问题:一个双人纸牌游戏

> 原文:[https://dev . to/mortoray/interview-question-a-two-player-card-game-67i](https://dev.to/mortoray/interview-question-a-two-player-card-game-67i)

我在[interview . io](https://interviewing.io/)网站上要求受访者写一个双人纸牌游戏的模拟。这是一个引人入胜的问题，揭示了他们的许多能力。它不涉及任何诡计或随机算法知识。它适合任何技能水平的程序员，并且可以在所有通用语言中工作。

我想分享这个问题和我的一些见解。

## [](#two-player-card-game)双人纸牌游戏

我用一个关于关注代码的设计和结构的序言来引入这个问题。我不需要有一个运行的程序，但需要看到一个入口点，以及如何使用它。

下面是游戏模拟的描述。

*   这是一个双人纸牌游戏
*   游戏从一副牌开始
*   牌分发给两个玩家
*   每次转弯时:
    *   两个玩家都翻开他们最上面的牌
    *   拥有较高价值牌的玩家拿走这些牌，并将它们放入得分堆中(每张牌得 1 分)
*   这种情况一直持续到玩家没有牌了
*   得分最高的玩家获胜

这被认为是一种模拟，因为玩家没有任何选择。我们不需要担心输入。

这个描述中有一些未回答的问题，或者可能是一些能力。有些不是故意的，但效果很好。候选人必须识别并解决需求中的问题。

根据这个描述，我希望这个人编写模拟游戏的代码:写出谁从一轮游戏中获胜。

## [](#design)设计

受访者提问是好的，但不一定能揭示问题。我希望得到一些反馈，表明他们至少已经理解了这个问题。除此之外，我很灵活，见过几种不同的解决问题的方式。我见过的唯一确定的模式是过度设计的消极模式:试图为每件事做计划，并写大量的笔记。如果人们在这里花了太多时间，我会提示他们开始写代码。

这个问题的复杂性不需要太多的准备工作。除了想出几个类，比如`Player`和`Game`，可能还有`Card`，你可以开始写代码了。许多表现良好的候选人使用的最佳方法是在实际代码中概述结构。代码通常是最好的伪代码:在计划时，只需省去细节，走捷径。

## [](#the-cards)纸牌

几个候选人从底层开始工作:深入研究卡的定义，或者创建一个`Deck`类。我问他们为什么构建这些类，暗示这不是一个好方法。我鼓励他们从更高的层面思考，思考他们真正需要的是什么。

尤其是在时间有限的情况下，最好自上而下地思考，忽略细节，直到你需要它们。也就是说，不要设计一个理论上的`Deck`类的所有方面，因为它们可能不会被用到。画出类的草图，放置一些变量是可以的，但是细节应该是稀疏的。

> 我避免在这一点上给出过多的指示；能够在代码中构建问题是编码的一项基本技能。我保留我的评论，直到我觉得事情很糟糕，而且这种方法不会让他们完成任务。如果他们感到自信并取得进步，我尽量不强迫他们接受理想的观点，而是让他们顺其自然。

可能在设计阶段，最迟在比较卡的时候，会出现一个关键问题，那就是我们在处理什么类型的卡。不是每个人都熟悉标准扑克牌，这没什么；他们问这些是什么类型的卡。其他人假设花色牌，并询问如何比较花色。在所有情况下，我都将需求简化为一组编号卡片，从 1 到 n。根据这一需求，完全不使用`Card`类，而只使用整数是可以接受的。尽管如此，琐碎的`Card`类型也没什么不好。

> 不管选择整数还是类，重要的是我理解为什么要做这个决定。特别是，我希望候选人能告诉我为什么他们选择了这个或那个。代码也要清晰。像`int[] array`这样的变量是没有帮助的(是的，这种情况发生过一次)。以事物的逻辑值来命名事物，比如`deck`。

## [](#the-game-progress)游戏进度

我提到编程应该是自顶向下的。在最初的设计阶段和一些代码草图之后，我会期望编写主要的序列。我想看到发牌，轮流，并宣布赢家。

从一个粗略的结构开始，然后填充细节是好的。我到目前为止的经验是，不从高层开始的人很难完成这个问题。

```
defn play_game = -> {
    deal_cards()

    take_turns()

    declare_winner()
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

考虑到问题的简单性，如果可以在以后重构为函数，那么直接在函数中编写这些代码也是可以接受的。无论是受访者发起这种重构，还是我有提示，似乎都反映了他们的经验水平。

> 自顶向下设计的重要性在测试驱动开发和 YAGNI“你不会需要它”的概念中得到了体现。

## [](#common-issues)常见问题

从这里开始，就是填写细节的问题了。这个问题有很多小事情要处理，没有一个是刁钻的，对面试有好处。

### [](#the-player-class)玩家类

一个常见的错误是未能识别出`Player`类型。我们以这种编码模式结束:

```
vector<int> player1_cards, player2_cards;
int player1_score, player2_score; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

一系列匹配的变量名，如`player1_*`和`player2_*`，很好地表明你应该有一个`Player`类型。大多数候选人自己得出这个结论，要么直接从一个`Player`类开始，要么重构它。其他人需要一些提示，但通常能很快理解。少数人只是不理解，需要明确的指导。

> 提示人们，而不只是给出一个答案，是很难的。在这种情况下，我喜欢尝试这样的事情:“看看那些从 player1 和 player2 开始的变量。你看到一个模式了吗？”，“有没有什么结构可以用来抽象这个？”，或者“你不能以某种方式更好地分组吗？”。

### [](#arguments-and-member-variables)自变量和成员变量

应该有一些`Game`类来管理模拟。名字并不重要，但是它应该包含玩家和游戏每个阶段的功能。这里考验考生在 OOP 方面的能力。

成员变量取代了函数的重复参数。这些函数都应该传递玩家、分数和卡片作为参数，但是玩家应该是实例的一部分。有些人立即这样做，有些人需要一点提示。

玩家的详细资料几乎总是最好的成员变量，但在如何处理最初的甲板和处理上有一些变化。

> 同样，适当的提示并不容易。我尝试类似“有必要将播放器传递给所有函数吗？”，“有可能避免这种冗余吗？”，或者更直接地说，“这些感觉就像球员属于这个阶层。”老实说，我不记得我说过的具体的事情，但关键是开始一般，近乎神秘。我需要说多少，需要说得多明确，这在很大程度上反映了受访者的技能。

### [](#magic-numbers-and-details)神奇的数字和细节

代码中涉及的不太多，但是我不喜欢看到。例如，从`1..52`开始创建卡片的循环使用了一个幻数。在增加分数时，还有一个`2`出现了:它有点微妙，但与我计划的扩展问题相关。

这可能看起来是一个微不足道的细节，但是我注意到更好的程序员会适应这样的事情。他们会创建一个常量，使用一个构造函数的参数(可能是默认的)，或者只是说，“是的，这不好，我应该在之后清理它。”

到这个时候，我通常已经很清楚这个人对编程语言的了解程度了。与自然语言相比，有些人似乎说得很流利，代码流一致而干净。其他的好像都是口吃，忘词，脑子里翻译，代码也没那么能言善辩。

虽然使用高级语法的人做得很好，但也有人只用基本的命令式语法就完成了这个问题。然而，真正的竞争是不可接受的:候选人可以选择语言，所以对基础知识有绝对的期望。

## [](#extended-questions)扩展疑问句

如果受访者已经回答了基本问题，我们至少还有 10 分钟时间，我会添加下一个要求:

*   扩展游戏以支持两个以上的玩家

这需要多少改变取决于他们最初采取的方法。如果他们没有提出一个`Player`类，我会要求它。如果函数有点稀疏，我也会请求重构函数。代码需要处于良好的状态。否则，这个新要求太令人望而生畏了。

> 据粗略估计，大约有一半的人回答了这个问题。这使得它成为一个合适的筛选标准:我倾向于不通过不能解决这个扩展问题的人。我会考虑新毕业生，但不会考虑有行业经验的人。如果我估计他们不会完成它，或者有时我提议只扩展一个功能，我通常不会问这个问题。我宁愿早点结束面试，也不愿增加额外的压力。

### [](#more-issues)更期

N 名球员的改变带来了一些新问题:

*   发牌不能再用 if-else 来选择玩家。我有点惊讶有多少人不知道如何使用 module`%`从循环数组中选择元素。
*   从列表中选择最高的卡片不再是一个如果-否则的问题。它对一些人提出了挑战，因为他们知道如何获得最大值，但并不总是知道那张卡的索引。
*   决定游戏是否结束的循环现在不是微不足道的，特别是当玩家可能没有相同数量的牌时。我注意到，更好的程序员自然会创建一个助手函数，或者避免循环中的复杂情况。

程序员的语言知识似乎在这里扮演着重要的角色。那些对自己的语言驾轻就熟的人更容易做出这些改变。对于非常了解 Python 的候选人来说尤其如此，因为有很好的构造可以使这变得更容易。

完成这个问题是一个积极的迹象，表明受访者确实是一个好的程序员，或者至少是一个好的程序员。我甚至不在乎他们在重构中是否有小问题，但通常他们不会。这是一个奇怪的模式，能走到这一步的人在这个问题上往往没有困难。

## [](#super-bonus-question)超级加分题

如果受访者设法增加 N 名球员的支持，我还有一个额外的变化。这比前面的要求更具挑战性:“不要假设卡片有唯一的值”。详情如下:

*   去除卡片是唯一的假设(也就是说，去一副标准的卡片)
*   如果玩家有相同价值的牌，他们抽一张额外的牌，重复直到一个人有更高的牌
*   拥有最高牌的人拿走所有的牌，每人得一分
*   只有打成平手的玩家才能继续抽牌(1+玩家可以不参加额外的抽牌)

只有一个人做到了这一步，为这个面试问题设定了黄金标准。

## [](#only-the-time-pressure)只有时间压力

我喜欢这个问题的一点是，它没有任何欺骗或随机算法知识。节奏似乎很有效:受访者处理不同程度的问题。鉴于我见过的人们遇到的困难，这似乎可以测试一个很好的跨领域能力。

作为面试练习，试着将答案编码。注意哪一点给你带来了麻烦，看它花了你多长时间。