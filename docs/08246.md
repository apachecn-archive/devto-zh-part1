# 关于微服务的一些注意事项

> 原文:[https://dev.to/horia141/some-notes-on-microservices-kni](https://dev.to/horia141/some-notes-on-microservices-kni)

用微服务构建互联网应用，最难的是缺少交易。虽然生产问题也没什么可嘲笑的，但它们至少有解决方案，无论是技术上的还是文化上的。然而，尽管分布式事务在理论上是可行的，但在实践中，它们会带来太大的性能损失，并且需要您不太可能遇到的参与者之间的深度集成和协调。

因此，在打破这种垄断，或者开始一个新的基于微服务的项目之前，需要特别注意哪些操作需要事务。如果你做错了，你最终会得到一个糟糕的设计，你将一些不相关的数据访问放在一个“协调器”服务中。在最坏的情况下，你的系统中会有细微的错误，这些错误只有在出错时才会显现出来。

然而，许多设计并不需要很强的一致性，最终的一致性也能很好地应付。

例如，一个相当标准的微服务是处理用户和身份相关问题的服务，比如用户属性、朋友等。和各种授权流。其他服务利用了这一点，并拥有与用户相关联的数据，尽管这些数据存储在它们自己的存储中。

当用户删除他们的帐户时，一个复杂的问题出现了。自然，我们希望通知每个服务，并让它们为该用户执行自然的生命周期结束场景。比如将相关数据标记为已删除、发送告别电子邮件或删除外部存储的图片。

“删除帐户”按钮的自然事件处理程序将首先调用用户微服务并删除帐户，然后循环通过每个相关的微服务并执行相同的操作。这不会是事务性的，并且在过程中间的失败会使系统处于不一致的状态。或多或少，每种执行多次事务性写入的方法，无论是通过对微服务的多次调用、对微服务的一次调用和在任务队列中的一次查询，还是仅通过行级事务支持对 NoSQL 数据库的多次写入，都会导致同样的问题。

一种改进是只向至少一个队列发送一条消息，例如 [SQS](http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/standard-queues.html) 或[卡夫卡](https://kafka.apache.org/)，并让每个微服务监听消息并做出适当的反应。

这种方法的一个很大的缺点是，它需要从一开始就对体系结构做出承诺。当逐渐发展当前的系统时，为小用例引入像分布式队列这样的大依赖可能没有意义，即使从长远来看好处可能是值得的。

一个不错的解决方案是通过“删除帐户”处理程序删除用户服务帐户。少量元数据也应该与帐户相关联，描述哪些服务注意到了这种删除。它最初是空的。类似 JSON 服务名列表的东西就足够了。每个服务将定期为所有被删除的用户轮询用户服务，但是特定的服务还没有为这些用户做任何事情。有了这些信息，服务就会做自己的事情，比如将数据标记为已删除或发送告别电子邮件，然后通知用户服务它已经这样做了。

失败也可能发生在这里，生命周期结束时的处理应该是幂等的。至少尽可能多。对于类似告别信息的东西，可能会发生双重传递。这与至少一次队列所做的保证没有什么不同，但是我不认为这是这种方法的一个污点。这是在分布式系统中必须付出的代价。

当然，另一个问题是，在用户服务中的初始帐户删除和每个依赖的微服务获得这种改变之间，系统将在短时间内处于不一致的状态。大多数情况下，*和*没什么关系，但是在查询时可以进行额外的检查，以确保一个依赖实体在进行任何其他类型的处理之前确实有一个活动用户。