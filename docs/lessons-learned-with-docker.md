# Docker 的经验教训

> 原文：<https://dev.to/ahansondev/lessons-learned-with-docker>

我已经半定期地和 Docker 一起工作了几个月了。我是一个产品的技术负责人，这个产品不仅有常规的开发和测试，还有多个面向用户的部署。这些部署可能有 5 个或 50 个(或更多)用户，外部用户可以通过互联网访问，或者只能在没有外部连接的公司内部网中使用。Docker 似乎是简化部署的好方法——Docker 可以安装的任何地方，我们的软件栈也可以安装。

我一路走来学到的一些经验:

## 总图分卷

这是一个艰难的教训。我上下旋转一个 MySQL 容器进行本地测试，碰巧最后一次我站起来时忘记了将数据目录映射回主机上的一个目录。我没有注意，吹走了容器，丢失了一部分本地数据。很明显，因为这是我的本地环境，我可以把它找回来，但是我花了一两个小时回到我开始的地方。

显然，能够跨容器共享卷是有好处的，但是最好总是提醒容器是短暂的。

## 脚本一切

我的前几个容器非常简单——应用程序的一部分部署在 Apache Tomcat 上，所以我以该容器为基础，构建了一个简单的 docker 文件，基本上可以放下战争，继续前进。然后我犯了一个错误，开始提交我的容器，而不是更新 Dockerfile。我脑子里有得到一个工作容器需要做的事情，但是当我们将团队过渡到使用 Docker 用于他们的本地环境时，它很快变得不可持续。教训:始终保持 docker 文件最新，并确保从该 docker 文件重建，而不是提交容器。它为构建容器提供了一个可重复的过程，默认情况下它们是受版本控制的，因此很容易看到项目是如何随着时间的推移而发展的。

这适用于实用工具容器，如 MySQL 或 Memcached，它们可能有一两处变化，但基本上与 Docker 注册表中的内容相同。甚至将这些小的更新放在 Git repo 中某个地方的 Dockerfile 文件中，以监视更改。

我们最近开始使用 Nexus 作为内部注册表。它似乎工作得很好，省去了必须在本地构建容器的步骤；他们的 Docker 注册功能相对较新，所以在接下来的几个版本中观察它的发展会很有趣。到目前为止，最大的好处是让注册中心始终拥有来自 Jenkins 的最新开发和测试版本，这样开发人员可以轻松地保持他们的本地环境是最新的，一些 bash 脚本可以轻松地获取最新的容器并选择部署哪个环境。

在一个相关的注意事项- docker-compose 是一个生命的救星。我们的 web 应用程序有 8 个容器，需要利用 compose。同样，docker-compose 文件是受版本控制的，并且通过对所有 pull 请求进行代码审查，部署更新不会带来任何意外。

这让我发现了 Docker 共享属性的一个大问题。

## 共享属性

在许多情况下，当我们部署时，系统与外部数据库对话，所有的容器共享相同的配置；嗯，至少它们共享主机和端口(即使在同一个数据库中，你也不会共享不同组件的用户名和密码，对吧？？？).为了使我们的生活更容易，我们添加了一个 Ruby 脚本来包装 docker-compose，它实际上构建了一个新的 docker-compose.yml，它获取共享属性，然后复制到每个容器的属性列表中。我们有一组基本的属性，一些特定于容器的属性可以根据需要扩展/覆盖这些属性，它们与基本的 docker-compose 文件相结合，生成一个新的文件，这个文件就是我们读入的实际的 compose 文件。

虽然运行包装器脚本而不是直接运行 docker-compose 有点奇怪，但不必在多个地方重复配置的好处使得额外的步骤是值得的。

Docker 很棒；我从通过容器化来简化部署中获得了很多乐趣，我期待着探索如何使用 Swarm 来使我们的部署更加健壮和容错。