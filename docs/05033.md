# 把你的虫子移到左边

> 原文:[https://dev.to/samwho/move-your-bugs-to-the-left-360p](https://dev.to/samwho/move-your-bugs-to-the-left-360p)

我们都想发布无错误的软件。没有人想成为在发布前一周引入一个妨碍节目的 bug 的人。为了有助于这一点，我想出了一个简单的方法来可视化开发过程中可以找到 bug 的点。

[![A flow chart depicting boxes from left to right: compiler, tests, code review,<br>
QA/early access, user](img/dc4462c09eaa1f8d9f99892422961374.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--nSD39GVL--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/http://samwho.co.img/move-your-bugs-to-the-left.png)

越是在图表的左边发现一个错误，每个人都会越高兴。最糟糕的情况是用户发现了一个 bug，显示在最右边。

> “向左，向左”——碧昂斯

以下是帮助你尽早发现漏洞的建议。我将从最左边开始，然后向右移动。

## 静态分析

“静态分析”工具在不执行代码的情况下检查代码，以便在编译时发现问题和低效之处。让我们看一个 Java 中的例子。

```
class Test {
  public static void main(String ...args) {
    int[] a = {1, 2, 3};
    int[] b = {1, 2, 3};
    System.out.println(a.equals(b) ? "woot" : "noot");
  }
} 
```

在 Java 中，`String`类使我们习惯于认为`.equals()`方法比较两个对象以确保它们的*值*相同。数组就不是这样了。对于数组，`.equals()`比较*引用*，所以上面的代码片段不直观地打印出“noot”，因为`a`和`b`是两个不同的对象。

[error problend](http://errorprone.info)是 Google 的 Java 静态分析工具。[它在编译时发现了这个错误](http://errorprone.info/bugpattern/ArrayEquals)和[许多其他错误](http://errorprone.info/bugpatterns)，并且编译失败。

如果你的语言有静态分析工具，使用它们并听取他们的建议。

几乎每个静态分析工具都会产生误报，并且会有一种机制来消除代码中特定部分的特定警告。在使警告*静音之前，请仔细考虑警告*。设置一个静态分析器静音的先例会导致可预防的错误出现在你的用户面前。

### 编译器检查

前面的例子展示了一个独立于该语言编译器的工具，但是许多语言都内置了有用的检查。

缺省情况下，Go 编译器会执行一系列旨在消除常见错误的检查。例如，如果你在声明一个变量后不使用它，编译器会产生一个错误，你的编译会失败。当与 Go 的错误处理结合使用时，这种方法效果很好:

```
package main

import (
  "fmt"
  "strconv"
)

func main() {
  val, err := strconv.Atoi("hello")
  fmt.Println(val)
} 
```

这个例子不能编译，因为我们已经定义了`err`但是没有使用它。为了补救这一点，我们要么对错误做些什么，要么通过重命名它来声明我们不想关心它`_`，这是一个特殊的符号，可以免除 Go 的使用检查。

```
val, _ := strconv.Atoi("hello") 
```

这防止我们忘记处理错误，但是当我们在同一个作用域中有多个产生错误的函数调用时，这就不够了:

```
package main

import (
  "fmt"
  "log"
  "strconv"
)

func main() {
  _, err := strconv.Atoi("1")
  if err != nil {
    log.Fatal(err)
  }

  val, err := strconv.Atoi("uh oh!")
  fmt.Println(val)
} 
```

遗憾的是，编译器没有在这里保存我们，我们最终打印出一个无效的值。

另一个著名的例子是 C 编译器接受的`-Wall -Werror`标志组合。这将启用所有编译器警告，并将所有警告视为编译错误。

然而，不太为人所知的是`-Wextra`旗。尽管有它的名字，`-Wall`并没有启用编译器可以显示的所有警告。

```
#include <stddef.h>
#include <stdint.h>

int main(void) {
  size_t n = SIZE_MAX;
  int P[n];
  for (int i = 0; i < n; i++) {
    P[i] = 0;
  }
  return P[0];
} 
```

即使用`-Wall -Werror`编译，上面的代码也能毫无怨言地通过 GCC 和 Clang。但这是不正确的。你能看出为什么吗？

使用`-Wall -Wextra -Werror`进行编译有助于了解情况:

```
/tmp/test.c:7:27: error: comparison of integers of different signs: 'int' and
      'size_t' (aka 'unsigned long') [-Werror,-Wsign-compare]
        for (int i = 0; i < n; i++) {
                        ~ ^ ~
1 error generated. 
```

这种混合符号比较是未定义的行为，会导致从 segfaults 到无限循环的任何事情。使用正确的编译器标志也是完全可以避免的。

打开你的编译器能给你的所有警告，并倾听它们。类似于静态分析，如果您认为某些警告不适用，您可以将其静音。谨慎行事，并有充分的理由。

### 类型系统

动态语言中遇到的一个常见问题是向函数传递错误的数据类型。

```
def abs(n):
  if n >= 0:
    return n
  return -n 
```

很明显，如果你给它传递一个字符串，它会爆炸。

然而，更糟糕的是，当给定错误的数据时，*不会爆发。相反，它会悄悄地计算出一个无效的结果，并将其传递到代码中的其他地方进行分解。发生这种情况时，追踪问题的根本原因可能需要很长时间。* 

```
def sum(things):
  if things == None:
    return None
  if len(things) == 0:
    return 0

  total = things[0]
  for thing in things[1:]:
    total += thing
  return total

sum([1, 2, 3]) # 6 
```

看起来很合理。它甚至在顶部进行检查，对一些常见的有问题的值做一些明智的事情。那么问题出在哪里？

```
sum("hello") 
```

这将返回字符串`"hello"`。为什么？因为`len`作用于字符串，所以像 Python 中那样迭代字符串会产生每个连续的字符，字符串上的`+`操作符会进行连接。这显然不是该函数的初衷。如果我们提前指定我们期望的类型，这个问题是可以避免的。

更喜欢使用具有类型系统的语言来编写需要正确的代码。如果你的语言没有类型系统，在运行时防御性地检查传递给你的数据是否正确，如果不正确就抛出一个错误。

这并不是说类型系统消除了向函数传递不正确数据的所有可能性。您可能仍然需要对传入的内容执行有效性检查，例如，检查空值。

## 单元测试

捕捉代码中 bug 的下一个最佳地方是单元测试。单元测试是编写代码的实践，它用各种参数和各种条件调用您编写的代码，并对结果做出断言。例如，假设我们编写了以下函数:

```
public int abs(int i) {
  return i < 0 ? -i : i;
} 
```

我们可以编写下面的单元测试来断言它在做正确的事情:

```
@Test
public void positive() {
  assertEquals(abs(10), 10);
}

@Test
public void negative() {
  assertEquals(abs(-10), 10);
} 
```

这两个测试覆盖了我们的基本用例，甚至给了我们 100%的“代码覆盖率”，这意味着我们代码中的所有分支都被采用了。这是否意味着我们的代码是正确的？

很遗憾没有。有一个问题。这很微妙，但花一分钟，看看你是否能发现它。

我们需要确保在单元测试中做的一件事是给出可能导致问题的代码输入，或者我们*知道*会触发错误的输入。对于整数，有许多已知的值会引起问题:0，-1，`Integer.MAX_VALUE`和`Integer.MIN_VALUE`。

我们的代码不能很好地处理`Integer.MIN_VALUE`。`abs(Integer.MIN_VALUE)`返回`-2147483648`，这明显违反了`abs`的工作方式。弄清楚为什么会这样是留给读者的一个练习 <sup id="fnref1">[1](#fn1)</sup> 。

确保你的单元测试用各种各样的数据来测试你的代码。不要误以为 100%的覆盖率意味着你已经编写了所有你需要编写的测试。

### 突变检测

作为单元测试的补充，突变测试是自动修改部分源代码的实践，以查看这样做是否会破坏任何测试。

重用我们之前定义的`abs`函数:

```
public int abs(int i) {
  return i < 0 ? -i : i;
} 
```

一个典型的变化是将比较操作符从`<`翻转到`>`，或者完全替换条件:

```
public int abs(int i) {
  return false ? -i : i;
} 
```

如果我们的测试失败了，我们就说这个突变已经被“杀死”了如果他们通过了，变异“存活”了下来，需要被杀死。

变异测试是确保你的单元测试捕捉到代码中问题的好方法。

pitest 是一个流行的 JVM 语言突变测试库，如果你搜索“<你的语言>突变测试”，你可能会找到一些与你相关的东西。不过，我要指出的是，变异测试是一个相当新的概念，还没有在所有语言中流行起来。你可能很难找到现成的解决方案。

## 集成测试

单元测试是防止错误的重要工具，但是它本身是不够的。您还需要以用户将要使用的相同方式测试您的代码。

进入集成测试。

假设我们已经编写了一个命令行程序，它获取一个文件并用字母“o”替换每个元音。程序会被这样调用:

```
$ oify input.txt output.txt 
```

大多数语言都有像这样调用命令的方法，这使得测试我们的程序变得简单。该测试将创建一个输入文件，将其写入磁盘，运行命令，然后断言输出文件只包含元音“o”。

也许你的程序也可以在没有相应参数的情况下从`stdin`读取和/或向`stdout`写入。这些都是您想要测试的，以及当无效的参数组合或空的/不存在的文件被传入时会发生什么。测试您的错误处理是否正确与测试事情是否按预期工作一样重要。

你希望你的用户与你的代码进行的任何交互都应该有一个相应的集成测试。

有时候这很棘手。如果你正在创建一个网站，并想测试当用户在该网站上提交表单时，正确的事情会发生，你不需要投票给许多 web 开发人员来找到一个会告诉你这是一场噩梦的人。如果您大量使用 Javascript，情况尤其如此。浏览器是大型复杂的程序，试图模仿它们的行为会产生不一致的结果。你要测试的运动部件越多，你的困难就越大。

## 代码审查

在编写单元测试、集成测试并确保您的编译器和静态分析工具满意之后，您的下一道防线是代码审查。最简单的形式是，代码审查包括另一个人阅读你的代码，并检查它是否有意义。有些公司有不同类型的评审，例如，来自对现有代码库有深入了解的人的评审，加上来自对您正在使用的语言或技术有深入了解的人的评审。

无论哪种方式，都不可能否认第二双眼睛可以为您的代码提供的价值。当我刚开始在一家实行定期代码审查的公司工作时，我发现人们能够在我的代码中发现如此之多的错误和低效之处，这令人吃惊。这非常令人谦卑，也是向团队中的其他人学习的绝佳方式。

确保所有签入代码库的代码都经过了至少一名其他团队成员的审查。

有些人觉得这些评论很乏味。一次又一次遇到同样的问题并不罕见。当这种情况发生时，它可能是一个 API 难以使用或者没有很好记录的信号。Go 社区对这个问题采取的一个有用的方法是编制一个[代码评审注释](https://github.com/golang/go/wiki/CodeReviewComments)的列表，当评审人员看到人们犯常见错误时，他们可以参考这些注释。

### 样式指南

代码评审的一个常见组成部分是“风格指南”这通常是一个给定语言或技术的注意事项列表，并对每个建议进行解释。

一个很好的例子是谷歌的 [Python 风格指南](https://google.github.io/styleguide/pyguide.html)。让我们来看看其中的一点:

> 列表理解:可以用于简单的情况。
> 
> 优点:
> 
> > 简单的列表理解比其他列表创建技术更清晰和简单。生成器表达式可能非常有效，因为它们完全避免了列表的创建。
> 
> 缺点:
> 
> > 复杂的列表理解或生成器表达式可能很难阅读。

它继续展示了一些好的和坏的列表理解的例子。

好:

```
squares = [x * x for x in range(10)] 
```

坏:

```
result = [(x, y) for x in range(10) for y in range(5) if x * y > 10] 
```

这表明有一条微妙的线要走。你可能认为这太严格了，这个“坏”的例子完全没问题。如果使用嵌套列表理解使你的代码可读性更好，你可以和你的评审争论。风格指南就是指南，所有这些都是在说你应该更喜欢简单的列表理解而不是复杂的。尽可能多的压缩在一行中并不是一个好主意。记住，代码是用来阅读的。

拥有风格指南的另一个好处是，如果你严格遵循它，你的代码将会是一致的。这减少了理解代码的认知开销，减少了引入错误的机会。

为你正在使用的语言选择一个合理的风格指南，并在代码审查时强制执行。如果你不同意你找到的风格指南的某些部分，你可以不遵循它们。与其说是严格遵守，不如说是一致性。

## QA 和早期访问

一些公司有质量保证部门。这将是一个团队，他们的工作是测试一个版本的正确性。他们如何做到这一点因公司而异，从老派的“手动运行一系列常见用户操作并勾选一些框”到完全自动化这一过程。

如果你负担不起一个专门的 QA 部门，或者你想要一个额外的保证，你可以发布“早期访问”版本。用户将有机会选择加入，对他们的好处是，他们可以在任何人之前使用新功能。缺点是不能保证软件是稳定的。

这是一个伟大的中间地带。用户并不期望所有的东西都能工作，你可以向那些对你的软件中的问题直言不讳的用户发布。双赢。

向选择加入的用户子集发布软件的早期版本。在向每个人发布之前，倾听他们的反馈并付诸行动。

## 用户反馈

假设你遵循了上述所有建议，并投入大量精力清除代码中的 bug，但是有一个 bug 漏网了，给你的用户带来了痛苦。他们会告诉你的！如果你有一个容易找到的 bug 追踪器或用户反馈机制，用户会让你知道发生了什么，以及他们认为应该发生什么。

倾听他们的意见，并按照他们的建议去做。

一个维护良好的、活跃的 bug 追踪器将是一个无价的资源，不仅是你的用户想要什么，也是他们如何解决问题的。这对于任何有同样问题的人来说都是有用的，当主要文档不能满足他们时，它可以作为一种辅助文档。

让用户容易给你反馈和问你问题。当他们这么做的时候听他们的。

如果用户报告了一个之前的步骤都没有发现的错误，修复该错误并进一步向左引入检查以防止相同的错误再次出现。

## 死后

你搞砸了。也许你有一个漏洞泄露了用户的个人信息，或者你的服务中断了一段时间。不管是什么，用户都很愤怒，想知道发生了什么。

“事后分析”是一份详细说明的文件:哪里出了问题，它是如何出现的，当时是如何解决的，以及你将如何确保它不会再次发生。该文档不需要向公众发布，但这样做将有助于恢复你在事件发生后失去的用户信任。用户重视透明性，这在现在著名的 [GitLab 数据库宕机事件](https://about.gitlab.com/2017/02/10/postmortem-of-database-outage-of-january-31/)的评论部分得到了极好的证明。

随着时间的推移，您可能会对代码进行大量的更改，而这些更改并不明显。也许您会检查某个字节是否出现在 blob 中，或者某个字符串是否以特定的字符组合开头。随着导致这些变化的事件的知识逐渐消失在神话中，有一种去除这些检查的诱惑。

写事后分析有助于你的同事理解为什么你的代码是现在这个样子，并防止你犯同样的错误两次。发布事后分析有助于恢复在大型事故中失去的用户信任。

写事后分析可能很棘手，但跟进就更棘手了。你需要想出一个行动项目的清单，以防止将来同样的问题再次发生，并把完成它们当作头等大事。

## 结论

没有保证写出无 bug 代码的方法，但是遵循上面所有的步骤应该可以在一定程度上减少你发送给用户的 bug 数量。

从现在开始，当你写代码的时候，问问你自己:“在这段代码中，一个 bug 可以被捕获到左边多远？我能不能把它重写一遍，让它更靠左一点？”

* * *

1.  `b1000`的二进制补码是`b1000`，所以最小的负数总是对自身求反。这是因为任何整数范围内的最小值总是比最大值大，例如范围-128 到 127 不能包含 128。 [↩](#fnref1)