# 这就是熔毁的工作原理

> 原文：<https://dev.to/isaacdlyman/how-meltdown-works-28j2>

Meltdown 和 Spectre 是最新的两个让科技世界陷入混乱的项目。他们彼此有许多共同之处；两者都依赖于计算机处理器的内置特性。

在做了一些阅读后，我认为我对 Meltdown 漏洞利用有足够的理解，可以用外行的术语来解释它。如果有任何不正确的地方，请在下面评论并纠正我。

众所周知，CPU(或处理器)是计算机的大脑。它能非常快速地执行许多简单的指令，比如将数字相加和读取记忆。

假设您的 CPU 是一个快餐柜台的员工。人们在柜台前排队，点菜单上的东西，然后用信用卡支付，然后去取食物。过程很简单。如果他们不付钱，他们就拿不到食物。

(类似地，CPU 接受来自进程的指令，确保该进程具有执行这些指令所必需的权限，然后执行这些指令并将结果返回给该进程。)

这家快餐店以快速服务而自豪。事实上，如果其他餐馆比它快，它会失去很多顾客。所以它开始走捷径。例如，只要你告诉收银员你想要什么食物，他们就会把你点的食物送到后面，厨师就会开始做，甚至在你交出信用卡之前。他们把它煮好，放在后面的托盘上，等你到了取货处，就可以给你送去了。这大大加快了速度。当然，如果你不能支付，他们不得不取消订单，把食物扔掉，这是一种浪费。但是大部分人都是马上付费的，所以问题不大，更快上手获得的效率肯定弥补了。

(你的 CPU 做这个。它执行某些指令*，同时*检查进程的权限，并行执行这些指令(称为“推测执行”)可以节省一些时间。如果它没有正确的权限，它会取消指令并转储结果。)

然后餐馆有了一个好主意:如果你不付钱，他们不会把食物倒掉，而是把它放在后面的托盘里长达 5 分钟。如果其他人在 5 分钟前点了同样的菜，他们会把你取消的菜给他们。更少的食物浪费，更快的服务。双赢。

(你的 CPU 也是这样。它有自己的缓存，在它知道进程是否有正确的权限之前，它把执行指令的结果放在那里。)

有一天，餐馆提出了一个令人难以置信的创新:能够数字化复制食物。食物制作完成后，可以一次给几个顾客，而不需要从头开始重新制作:只需将其复制到每个顾客的托盘上。R&D 的部门还没有想出如何将食物保持热的和新鲜超过 5 分钟，但是如果一个顾客点了一份#6 套餐，在接下来的 5 分钟内点了#6 套餐的其他人将会得到一份同样的饭菜，他们将能够非常快地得到它，因为它不必从头开始制作。超级高效。利润飙升。

(我知道这个比喻在这一点上越来越牵强，但这就是数据的工作方式。一旦 CPU 在缓存中有了东西，它就可以根据需要将它分发给尽可能多的进程，直到缓存的这一部分被覆盖或转储。)

餐厅的最后一项创新是关于隐私的。你有没有因为自己点了三份大薯条而尴尬过？不用担心:多亏了一个非常有创意的白噪音机器、厚窗帘和窃窃私语系统，你现在可以点菜和吃你的食物，而没有任何其他顾客知道你有什么。

(进程和 CPU 之间的私有通信*非常重要。*它可以防止程序互相监视。你不会希望你的纸牌游戏读取你的 Outlook 密码，你会吗？)

你是一个快餐黑客，你想弄清楚如何操纵餐馆，以便找出别人点了什么。你为此投入了大量的时间和精力。

首先，你发现如果你点的食物是在最后 5 分钟内已经做好的，你会比他们必须为你做新鲜的要快得多。因此，通过使用秒表，您可以确定它最近是否被其他人订购过。事实上，如果你盯着柜台，即使你的信用卡被拒绝，你也能知道你的订单是新鲜的还是只是数字复制的。

(CPU 缓存的作用是加快速度。如果多次需要指令结果，从高速缓存中获取它们要比再次处理相同的操作快得多。即使一个进程没有正确的权限，它也可以向 CPU 请求一些数据，对交互进行计时，并确定这些数据是否在 CPU 缓存中。)

从这你孵化你的计划。你去餐馆挑选一个受害者:另一个已经在吃饭的顾客，你想知道他们点了什么。你走近收银员，声称自己是另一位顾客，询问是否可以修改你的订单。你说你不小心把之前的*菜单项点到了你想要的那个；他们能把你的订单改成*下一个*菜单项吗？出于礼貌，他们说好，把订单送到厨房，但要求看你的信用卡以验证你的身份。当事实证明你谎称自己是另一位顾客时，收银员取消了订单——*但是已经做好了；它在后面的托盘上。此时，你所要做的就是点菜单上的每一个项目，一次一个，手里拿着秒表，直到其中一个项目快速返回，表明它已经做好了。然后你就知道了:另一位顾客点了前一个菜单。例如，如果#6 很快就回来了，你知道另一个顾客订购了#5。**

(可以指示 CPU 根据其他数据查找数据(例如，“查找内存地址 0xFFF 它包含另一个内存地址；返回存储在*的数据，即*存储地址)。这是拼图的最后一块。Meltdown 要求 CPU 根据*无法访问的其他数据查找一条数据。*CPU 拒绝了请求，但它仍然进行计算，并将第二段数据放入缓存中。然后 Meltdown 只需要请求一堆内存地址，无论哪一个返回得真快，都是等式的另一部分(在我们的示例中，它是存储在原始禁用内存地址中的内存地址。)这使得 Meltdown 可以读取内存中的任何内容。这很糟糕。)

那是熔化。而你*受其影响*。你应该立即更新你的浏览器和操作系统来获得补丁。

回想起来，如果没有快餐的比喻，这可能会更容易解释...但是，嘿，我玩得很开心。

如果这对你没有意义，或者你有什么要补充的，请告诉我。