# 反应“啊哈”时刻

> 原文:[https://dev.to/tylermcginnis/react-aha-moments](https://dev.to/tylermcginnis/react-aha-moments)

每当我教授或撰写技术内容时，我的主要目标之一就是最大化“啊哈”时刻。一个[“啊哈”时刻](https://en.wikipedia.org/wiki/Eureka_effect)是突然顿悟或清晰的时刻；当主题突然变得有意义时。我们都经历过这些，我所知道的最好的老师能够理解他们的观众，并调整课程以最大限度地利用这些时刻。

在过去的几年里，我几乎在每一种流行媒体上都教过 React。在那段时间里，我一直在记录是什么触发了这些“啊哈”时刻，特别是为了学习反应。大约两周前，我在 Reddit 上看到了这个有着相同想法的帖子。所以我想在这篇文章中分享我收集的这些时刻，同时也加入我对 Reddit 帖子中分享的一些时刻的想法。如果还没有，希望它能帮助你做出“点击”的反应。

* * *

> 你的 UI 是你的状态的函数，道具对于组件就像参数对于函数一样。

React 最好的部分之一是，您可以使用与 JavaScript 函数相同的直觉来决定何时何地应该创建 React 组件。然而，不是你的函数接受一些参数并返回一个值，而是你的函数将接受一些参数并返回你的 UI 的一个对象表示。这个思想可以用下面的公式来概括，fn(d) = V .一个函数接受一些数据，返回一个视图。这是考虑开发用户界面的一种很好的方式，因为现在你的 UI 只是由不同的函数调用组成。这就是您已经习惯的构建应用程序的方式，现在您可以在构建 ui 时利用函数组合的所有好处。

* * *

> 在 React 中，整个应用程序的 UI 都是使用函数组合构建的，JSX 是这些函数的抽象。

我看到第一次使用 React 的人最常见的反应是“React 看起来很酷，但我真的不喜欢 JSX。它打破了我的关注点分离”。JSX 并不想成为 HTML，而且它绝对不仅仅是一种模板语言。对于 JSX，有两件重要的事情需要意识到。首先， [JSX 是对 *React.createElement*](https://tylermcginnis.com/react-elements-vs-react-components/) 的抽象，该函数返回 DOM 的对象表示。我知道这是罗嗦，但 TL；dr 是无论何时你写 JSX，一旦它被编译，你就会有一个代表实际 DOM 的 JavaScript 对象(或者任何代表你所在平台的视图，iOS，Android，等等)。然后 React 能够分析对象，分析实际 DOM，并通过 diff，只在发生变化的地方更新 DOM。这有一些性能上的提升，但更重要的是表明 JSX 真的“只是 JavaScript”。第二，因为 JSX 只是 JavaScript，所以您可以获得 JavaScript 提供的所有好处(组合、林挺、调试),但仍然具有 HTML 的声明性(和熟悉性)。

* * *

> "组件不一定要对应 DOM 节点."

当我们第一次学习 React 时，我们被告知“组件是 React 的构建块。它们接受输入并返回一些 UI(描述符)”。这是否意味着每个组件都需要像我们通常被教导的那样直接返回 UI 描述符？如果我们想让一个组件呈现另一个组件(高阶组件模式)会怎样？如果我们想让一个组件管理状态的一部分，然后它返回一个传入状态的函数调用(Render Props 模式)，而不是返回一个 UI 描述符，那该怎么办？如果我们有一个负责管理声音而不是视觉 UI 的组件，它会返回什么？React 的伟大之处在于，您不需要从组件返回典型的“视图”。只要最终返回的是一个 React 元素、null 或 false，就没有问题。

您可以返回其他组件

```
render () {
  return <MyOtherComponent />
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

你可以返回函数调用

```
render () {
  return this.props.children(this.someImportantState)
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

或者，您可以不返回任何内容

```
render () {
  return null
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我非常喜欢 Ryan Florence 的 [React 集会演讲](https://www.youtube.com/watch?v=kp-NOggyz54)，他在演讲中更深入地阐述了这一原则。

* * *

> “当两个组件需要共享状态时，我需要提升状态，而不是试图保持它们的状态同步。”

基于组件的架构自然使得共享状态更加困难。如果两个组件依赖于同一个状态，那么这个状态应该在哪里？这是一个非常流行的问题，它刺激了整个解决方案的生态系统，最终以 Redux 结束。Redux 的解决方案是将共享状态放在另一个称为“存储”的位置。然后，组件可以订阅他们需要的存储的任何部分，还可以分派“动作”来更新存储。React 的解决方案是找到这两个组件的最近的父组件，并让该父组件管理共享状态，根据需要将其传递给子组件。这两种方法各有利弊，但重要的是要意识到这两种解决方案都存在。

* * *

> "在 React 中继承是不必要的，包含和特殊化都可以通过组合来实现."

React 在采用函数式编程原则方面一直非常开明，这是有充分理由的。一个从继承转向组合的先例是 React 0.13 的发布明确了 React 不支持 ES6 类的混合。这是因为大多数用混合(或继承)完成的事情也可以通过组合来完成，但是副作用更少。如果你是从一种重继承的心态中走出来的，这种新的思维方式可能会很难，可能会感觉不太自然。幸运的是，有一些很好的资源可以帮助你。这里有一个不是我喜欢的具体反应。

* * *

> "容器和表现组件的分离."

如果考虑 React 组件的结构，它通常涉及一些状态，潜在的一些生命周期挂钩，以及通过 JSX 的标记。如果我们将状态和生命周期挂钩从标记中分离出来，而不是将所有这些都放在一个组件中，会怎么样呢？这给我们留下了两个组件。第一个具有状态、生命周期方法，并负责组件如何工作。第二个通过 props 接收数据，并负责组件的外观。这种方法使我们能够更好地重用我们的表示组件，因为它们不再与接收到的数据耦合。我还发现，它可以让您(以及项目的新手)更好地理解应用程序的结构。您可以交换组件的实现，而无需查看或关心 UI，反之亦然——设计人员可以调整 UI，而不必担心那些表示组件如何接收数据。

关于这个主题的更多信息，请查看[表示和容器组件](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.q9tui51xz)。

* * *

> "如果你试图保持大部分组件的纯净，无状态的东西会变得更容易维护."

这是将表示组件从容器组件中分离出来的另一个好处。国家是不一致的助手。通过画出正确的分割线，您能够通过封装复杂性来极大地提高应用程序的可预测性。

* * *

*最初发表于[tylermcginnis.com](https://tylermcginnis.com/react-aha-moments/)T3】*