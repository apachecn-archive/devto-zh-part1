# React 是固体吗？

> 原文：<https://dev.to/kayis/is-react-solid-630>

在阅读了由 [Subbu](https://dev.to/subbramanil) 发布的 JavaScript 中的[坚实原则后，我思考了我们的框架如何遵循或不遵循这些原则。](https://dev.to/subbramanil/solid-principle-in-javacript-9eh)

正如您可能已经猜到的，目前我选择的框架是反应。所以我检查了它是否遵守这些原则。

## 固体代表什么？

SOLID 是由 5 个面向对象编程设计原则的第一个字母组成的缩写。基本思想是，如果你遵循这些原则，你的软件会变得更好。

**S** 单一责任原则
T3】O 笔/闭原则
**L** 伊斯科夫替代原则
**I** 界面分离原则
**D** 依赖倒置原则

## 这些原则意味着什么？React 如何遵守这些原则？

### 单一责任原则

**这是什么意思？**

一个类应该只有一个责任。

【React 是如何坚持下去的？

React 应用程序由组件组成，这些组件是从`React.Component`类继承的类。您可以开始将您的应用程序构建为一个组件，如果它变得太复杂，您可以将这个组件拆分成多个更小的组件。

React 并不强迫你遵守这个原则，但是你可以把你的组件类分解成更小的组件，直到你对你的所有组件实现**单一责任**。

例如，您可以有一个只处理点击的按钮组件和一个只处理用户输入的输入组件。上一级使用一个表单组件，该组件使用按钮和输入组件的多个实例来获取用户凭证，上一级使用一个连接组件，该组件获取表单数据并将其发送到服务器。

### 开启关闭原则

**这是什么意思？**

软件实体应该对扩展开放，但对修改关闭。这意味着您可以在不修改源代码的情况下扩展它。

【React 是如何坚持下去的？

Reacts 组件模型是围绕聚合而不是继承构建的。所以你只扩展了基类`React.Component`而没有扩展它的子类。这可以防止您直接重写现有组件的行为。唯一的方法是用你自己的组件包装它。

例如，你可以用一个总是将特定样式应用于基本`Button`的`RedButton`来包装一个`Button`，但是`Button`因为修改而被**关闭。**

这没有继承灵活，但也简化了 API。虽然您不能像在扩展中那样直接访问方法，但是您只需要关心聚合中的`props`。

### 利斯科夫替代原理

**这是什么意思？**

程序中的对象应该可以用其子类型的实例替换，而不会改变程序的正确性。

【React 是如何坚持下去的？

嗯，它根本不用继承。当然，您扩展了`React.Component`，但是这个类在 React 应用程序中本质上被视为抽象的，您永远不会直接从它创建一个对象，所以您永远不会在以后用子类替换它。

另一方面，您发现自己编写的聚合应该经常表现得像其包装的组件一样。就像我之前说的`Button`。您希望那个`RedButton`已经被设计好了，但是您也希望它的行为像`Button`，但是因为组件之间的 API 总是**只是道具**，所以当您的包装器道具被传递给被包装的组件时，添加一些东西通常是很简单的。因为一切都是动态的，你的包装器甚至不需要知道最初传递给被包装组件的所有数据，在`RedButton`的例子中，它只需要知道样式。

### 界面偏析原理

**这是什么意思？**

许多特定于客户端的接口比一个通用接口要好。

【React 是如何坚持下去的？

因为 React 是用 JavaScript 编写的，所以它受益于这种语言的动态特性。没有正式的接口。如果你不使用`refs`，它允许你直接调用一个组件的类方法，组件之间唯一的交互是通过道具，没有人强迫你使用你不需要的道具。

如果您有一个包装器组件，它传递一个`onClick`处理程序，该处理程序显示一个带有包装组件类名的警告，您可以使用这个包装器来包装所有使用这个`onClick`属性的组件，如果它们不使用这个属性，这个处理程序就会被忽略。

我对这个事实的经验是，它简化了许多事情，你不会迷失在预先定义许多小接口中。缺点是，我经常发现在我传递道具的情况下，被包装的组件只是默默地忽略。当我试图传递未知的 CSS 属性时，至少`glamorous-native`抛出了一些警告。为此，使用 PropTypes 或其他方法通常会有所帮助。

### 依存倒置原则

**这是什么意思？**

一个人应该依靠抽象，而不是具体。

【React 是如何坚持下去的？

在实践中，通常遵循这个原则从其他类中删除类名。就像，你可以有一个有`Items`的`List`，所以你可以得到在`List`类中创建你的`Item`对象的想法，现在你有你的`List`和你的`Item`紧密耦合。在你的`List`类中有一个`new Item(...)`或`Item.create(...)`等。

React 并不严格遵守它，你可以将一个字符串数组传递给你的`List`组件，并从它创建`Item` `children`没问题。

但是你也可以告诉`List`它应该简单地渲染出它的`children`,而不管它们是什么，也许可以给它添加一些键或者调整它们等等。

现在你可以创建一个由`Item`组成的数组，并在其中加入一些`HighlightItem`，它们都是从不同的字符串数组中创建的，并将它们放入你的`List`中，你不会知道。

## 结论

虽然 React 不会把原则强加给你，但至少它通常会让你遵循这些原则。有时因为 JavaScript，它变得更容易，有时 JavaScript 使它变得更难，但总的来说，用 React 编写可靠的应用程序是可能的。