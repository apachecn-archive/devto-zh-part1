# 将 Done 定义为布尔值

> 原文：<https://dev.to/d4ttatraya/defining-done-as-boolean>

*最初发布于[我的博客网站](https://d4ttatraya.github.io/Defining-Done/)* 。

在软件开发环境中，经常会问开发人员他们是否完成了任务。这是管理者问开发人员的一个非常明显的问题，没有任何错误或意外。开发人员倾向于回答这个问题为“是的，我完成了”,如果这里有任何错误和意想不到的事情，这就是他们所说的*完成了！*

[![](img/65699ef5c9e3b299d7f24dadb40d0144.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--eGKkRiwX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/pjwp71vaoe1tqc9suiq2.jpg) (图片提供:[http://www.quickmeme.com](http://www.quickmeme.com))

开发人员对“完成”的理解因开发人员而异，我们无法预测他/她实际做了什么。 *done* 是一个布尔值，它清楚地表示要么根本没有完成，要么实际上完成了所有事情？“实际上完成了一切”是什么意思？由于*完成*的定义因人而异，在开发人员*完成*和管理人员*完成*和业务人员*完成*之间总是有理解/假设差距的机会，其后果会扰乱整个产品交付链，并会吸引对该开发人员的负面关注。

所以我在这里列出了一些*做过的*的事情，按照从完全错误到几乎正确的顺序排列:

## 才管用

很多时候，更确切地说是大多数时候，开发人员说一旦他们写了一个可以正常工作的代码，他们就完成了。所以他们为新功能编写代码，运行它，看看它是否工作。这种对*的正确定义是否完成了*？当然不是。为什么？因为正常工作的代码不会被干净的编码者认可为最终代码。要了解刚刚工作的代码如何不是完美的解决方案，看看[我以前的帖子](https://d4ttatraya.github.io/Dirty-Code)。

## 工程和清洁，单元测试

因此，能够正常工作的代码并不足以说明我们已经完成了功能。我们应该编写与现有代码标准相匹配的代码，它应该是干净的；可读的，可测试的，可修改的。此外，我们应该添加单元测试，以确保代码在各种测试用例中正常工作。即使我们这样做了，我们也不能说‘我完了’!

## 工作并清理，单元测试并通过自动化测试

一旦我们有了工作的代码，干净的代码和经过单元测试的代码，我们必须寻找下一个标准来完成功能。这个标准就是通过所有已经写好的自动化测试。这些自动化测试可以是集成测试和验收测试。集成测试确保新编写的代码与现有系统正确集成，并且不会破坏任何东西。

## 工作并清洁，单元测试并通过自动化测试和 QA 批准

一旦我们完成了上述所有步骤，我们仍然没有完成。现在还剩下什么？完成上述所有步骤后，我们应该将工作系统移交给 QA，并等待他/她的反馈，无论是错误、修改还是批准。当 QA 批准我们新实现的特性时，只有我们可以说“我完成了”!”，终于。所以现在我们可以说，我们的 ***done* 是布尔型的，其中根本没有完成或不起作用，或者上述所有定义都属于值-0，只有这个定义属于值-1** 。
正如鲍勃大叔所说-
*Done 的意思是完成了，没有完成，就没有完成——完成了。*

## 奖金

人们多次提到，我们应该总是重新分解或清理现有的代码，我们也可以将这一点添加到我们对 *done* 的定义中。我们不应该说*完成了*，直到我们重新分解(如果需要)与我们新编写的特性相关的现有代码。

每个公司都有自己对“完成”的定义，但如果任何公司没有，那么他们应该立即定义它，并要求他们的员工遵守它。

如果你已经定义了你自己的 *done* 或者现在已经定义了，那么别忘了在下面的评论里写上你的定义！

*参考资料:
鲍勃大叔的《干净的编码器》一书和[谈专业](https://www.youtube.com/watch?v=BSaAMQVq01E)*