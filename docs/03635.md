# 自信的堡垒:自我测试您的数据库

> 原文:[https://dev . to/pesse/strong holds-of-confidence-self-testing-your-database-4bl 9](https://dev.to/pesse/strongholds-of-confidence-self-testing-your-database-4bl9)

软件测试在专业开发中一直是一个非常重要的话题，因为软件——不像建筑——从第一行代码到发布，以及从发布开始的整个生命周期中会有很多变化。由于这种不断的变化及其复杂性，每个诚实的开发人员总有一天会接受，没有没有缺陷的软件。

敏捷方法的兴起，像持续集成这样的想法，以及更频繁发布的渴望，导致了对现代测试策略的更加强烈的关注([关于发布频率和敏捷实践的相关性的有趣博客文章——尤其包括自动化测试](https://telegraphhillsoftware.com/release-frequency-agile-practices/))。

不幸的是，围绕测试的一些编程技术存在某种“圣战”(我将在这篇博客文章的最后一章写得更多一点)，但尽管如此，在今天的软件开发中，对自动化自测(无论是系统测试、集成测试还是单元测试)的需求是真实的，在专家中没有争议。因此，我将在本文中使用“自测”这一通用术语，专注于非常基本的概念，并尝试介绍如何在数据库项目中进行自测。在我的印象中，今天的许多数据库项目甚至不知道自测的基本知识，所以让我在不挑剔具体技术的情况下尝试向您展示它的好处。

# 自测基础

计算机是非常正式的存在，目前不可能用自然语言告诉它们做什么。这在未来可能会改变，但在那之前，开发人员仍然坚持用编程语言来告诉机器他们想要什么。另一方面，人类不是非常正式的存在，编程对我们来说不是自然的。这导致软件有缺陷，并再次导致测试成为软件开发的一个非常重要的部分，尤其是在生产中对错误的接受是有限的情况下(这取决于客户、具体项目和软件的目的——内部网站点的员工数据库中的错误可能不像飞行控制软件中的错误那样有影响)。

让我们看一个现实生活中的例子:

你的西斯指挥官温和地要求你在死星控制数据库中创建一个新功能。它应该给出关于几个支柱的当前能量水平的信息，并且还允许设置每个支柱的目标能量水平。

作为一名熟练的数据库开发人员，您决定创建一个新的数据库视图和一个 instead-of 触发器来控制可以更新哪些数据。你努力工作，对自己所做的事情充满信心，实现观点并彻底测试它(你不想被扼住喉咙的力量左右浮动吧？).一切正常，你为自己感到非常自豪。然后，经过几个月的观察，西斯指挥官希望在控制面板上显示新的信息。你做了恶梦，梦见反叛者在前一天晚上准备对死亡之星发动自杀式袭击，你头疼，而且非常疲劳。尽管您向视图中添加了一个新列，并发出了“创建或替换视图…”命令(每个人都知道阴暗面使用 Oracle，否则为什么管理这些数据库会造成如此大的痛苦呢？).你迅速检查控制面板，看到新的信息出现，然后去你的休息区。这将是你最后一次休息。

对于那些不太熟悉 Oracle 数据库的人来说:当您替换一个视图时，所有附加的 instead-of 触发器都丢失了，您必须重新创建它们(希望您的数据库[版本得到了控制](https://dev.to/pesse/there-is-no-clean-database-development-without-version-control-2hfe-temp-slug-1558795)，所以如果发生这样的问题，您能够轻松地解决)。事实上，这种情况在我的作品中至少发生过一次。只需在视图中进行快速更改，运行创建或替换脚本，几分钟后，电话中的客户告诉他不能再保存值，或者在尝试时出现错误。

有人会说我不专业，我应该知道这些影响，这可能是真的。但在现实中，会有压力很大、你的头脑不像应该的那样清晰，或者你只是不记得你应该记住的一切(实际上，我们应该为遗忘的能力感到高兴——如果我们能更好地控制它……)

我自己接受这样一个事实，我是人，可能会忘记我不应该忘记的事情。我甚至接受犯错的可能性。我认为接受犯错的风险并采取相应的行动是很专业的——例如在你的项目中加入自测。

在我们的例子中，一个用 PL/SQL 编写的简单测试程序就可以拯救我们。这种自测可能包含以下步骤:

*   在将预期的测试数据插入到基表中之后，从视图中读取测试数据
*   通过更新视图来更新测试数据，并通过重新读取视图来检查输出
*   通过插入视图来插入测试数据，并通过重新读取视图来检查输出

```
create or replace procedure test_pillar_view
as
  v_energylevel integer;
begin
  -- Inserting test-data into the base table
  insert into pillar_table ( id, energylevel ) values ( -1, 100 );

  -- Test we can read the data via view
  select energylevel into v_energylevel from pillar_view where id = -1;
  if v_energylevel <> 100 then
    raise_application_error(-20000, 'expected energylevel to be 100, was ' || to_char(v_energylevel));
  end if;

  -- Update the test-data via view
  update pillar_view set energylevel = 150 where id = -1;
  select energylevel into v_energylevel from pillar_view where id = -1;
  if v_energylevel <> 150 then
    raise_application_error(-20000, 'expected energylevel to be 150, was ' || to_char(v_energylevel));
  end if;

  -- Insert new test-data via view
  insert into pillar_view ( id, energylevel ) values ( -2, 200 );
  select energylevel into v_energylevel from pillar_view where id = -2;
  if v_energylevel <> 200 then
    raise_application_error(-20000, 'expected energylevel to be 200, was ' || to_char(v_energylevel));
  end if;

  -- rollback all things we've done during the test
  rollback;
exception when others then
  rollback;
  raise;
end;
/
-- Run
call test_pillar_view(); 
```

现在，我们只需要确保每次修改时都运行测试。这样的自检可以立即发现缺少的 instead-of 触发器，我们可以在更新生产系统之前采取行动。

这是一个非常低级的自测，直接与特定的功能或模块相关联。这就是你们中的一些人可能已经知道的单元测试:直接测试单元，在这种情况下是视图(有人可能认为这不是一个“单元”测试，因为它测试三个单元的组合:视图、后面的表和 instead-of 触发器。)

自测可以而且应该包含比这更多的低级测试，我给你一个非常基本的例子，我从一开始就把它包含在每个新的数据库项目中:确保你的数据库中没有无效的对象:

```
create or replace procedure check_all_valid as
  v_count integer;
begin
  select count(*) into v_count from user_objects where status &amp;amp;lt;&amp;amp;gt; 'VALID';
  if ( v_count <> 0 ) then
    raise_application_error(-20000, 'Check failed: not all database objects are valid!');
  end if;
end; 
```

在应用程序开发中，我们的编译器大部分时间都包含了类似的功能。你通常不能构建一个部分(编译器)无效的应用程序。但是您可以在数据库中拥有无效的部分，但仍然使用其余部分，这是一个非常重要的功能，但也让开发人员承担了一些责任(我认为我们不必争论无效的数据库对象是否是干净和专业的开发，不是吗？).

这个简单的函数是一个很好的例子，说明了自测包括什么。它从更高的抽象层次测试你的项目。这还不是全部:用几个“高级”自测来检查数据中的业务逻辑是绝对有效且有用的，这是简单的数据库约束所不能实现的。这与单元测试无关，但对项目的安全同样重要和有益。

我鼓励你阅读 Martin Fowler 关于自我测试的精彩文章，并尝试给自我测试下一个简短的定义:

> 自测提供了一个自动化的、易于使用的检查，检查项目中的特定问题或特性是否得到了解决。
> 
> # 我为什么要在乎？

我猜包括西斯想要杀你在内的威胁场景并没有完全说服你？您认为围绕数据库功能开发测试非常昂贵，并且会破坏项目的时间表？你认为包含更多的代码会引入更多的错误吗？你以为自测是给一开始就不知道怎么正确发展的人用的？

自测的话题在应用程序开发领域已经存在了几十年，并且有许多关于自测的好的和全面的论点，例如[编写单元测试的 12 大理由](http://www.onjava.com/pub/a/onjava/2003/04/02/javaxpckbk.html)(注意这个答案是 2003 年的，并且仍然有效，所以我们可以猜测我们发现了软件开发中一个非常基本的话题)。[《实用程序员》](https://en.wikipedia.org/wiki/The_Pragmatic_Programmer)包含了几章关于自我测试的内容——这是一本我推荐给每一个开发者的书，不管他/她是数据库还是应用程序开发。

以下是我自己的(到目前为止还不完整的)为什么你应该在你的项目中使用(自动)自测的原因列表:

*   自测可以让你对问题有不同的看法。您可能必须以不同的方式考虑一个用例或一个特性，这将导致对业务用例的更深入的理解，从而使您能够交付一个更好的解决方案。
*   自测是记录一个功能或用例的目的的好方法。它可以提供一个关于函数如何工作的“真实生活”的例子。
*   自测可以确保一个 bug 一旦出现并被解决，就不会再出现。它们可以提高质量，减少项目中的错误。
*   自测给你机会向你的客户展示你关心你的软件质量。为什么不向您的客户提供自动化测试运行的输出(当然要解释一下它是什么和目的是什么)？您确实投资于质量和可靠性，您的客户会很高兴有这样的合作伙伴
*   自测有助于编写更好的代码。拥有一个干净简单的 API 使得自测更容易，所以自测鼓励你开发一个干净简单的 API

为什么自测对你的项目大有裨益(老实说是必要的)还有很多原因，但有一点对我来说尤其重要:

> 自我测试为变革创造了一个信心的堡垒

软件的变化，有时比参与项目的任何人想象的都要快。需求会改变，用例会改变，期望会改变，软件也应该如此。为了让你的项目和软件变得伟大，你必须拥抱和欢迎变化——但这只有在你自信的情况下才有可能。你必须有信心，增加一个新功能不会破坏另一个功能。你必须确信改变一个 API 不会使软件停止工作。你必须有信心通过重构来改进你的代码库，而不是搞砸它。你必须有信心，在你发布下一个更新后，你的客户会有很好的体验。在合作项目的情况下，你必须确信你不会破坏一个项目。

拥有一套可靠的自测工具可以创造这种自信。在这样一个自信的堡垒中成长，会让你放松、激励，并为你需要的创造力提供空间。

# 工具

完全有可能在没有任何框架或工具的帮助下创建自测。只需创建一堆 T-SQL 或 PL/SQL 脚本和一个简单的 pyhton、perl 或 Powershell 文件来运行它们。您甚至可以创建一个 main-SQL 文件来调用所有其他文件(硬编码)。这比没有测试，没有问题要好得多。

虽然从长远来看，这可能还不够，您可能需要某种帮助来减少样板代码。

有几个工具(至少对于大型 DBMS Oracle 和 SQL Server 来说)可以使自测变得非常容易，虽然这个主题可以(并且可能会)成为自己的博客文章，但我想根据您的 DBMS 提供一些可能的切入点:

*   Oracle: [utPLSQL](http://utplsql.org/)
*   SQL Server:
    *   [tSQLt](http://tsqlt.org/)
    *   Visual Studio 测试

# 但是我不能把我的项目搁置三个月来写所有的自测

你猜怎么着没关系。不需要。我们不在完美的环境中工作，我们不创造完美的软件，我们也不生活在完美的世界中。然而，没有理由也没有借口不开始改善所有这些事情。

开始自测最重要的是改变思维。不要认为写自测是负担和责任，增加了项目的成本，却没有提供(可见的)好处。相反，把你的软件质量作为一个关键目标，欢迎你的项目中的变化，把自测作为对你的代码库的一个强大的补充，它给你一个喘息的空间，让你可以不停顿地快速前进。

对于实用的方法，两个简单的规则可能足以开始在您当前的项目中包括自测:

*   每当软件出现错误时，写一个自测来揭示这个错误。您可以使用最初导致问题的确切数据集。确保你的自测失败。然后修复 bug。
*   为你**改变**或**增加**的每个功能编写自测。

您的测试套件将以这种方式缓慢增长，而不会对项目的时间表和成本产生巨大的前期影响。老实说——既不改变也不在软件行为中产生错误的功能不需要自测，不是吗？

# 有意义的测试

一旦你决定用自测来改进你的软件，确保你的自测是有意义的。

这可能是显而易见的，但是要认真对待失败的测试。尽可能频繁地进行测试(例如，在本地环境中的每次更改之后，在单独的共享环境中的每次提交之后，在整合环境中的每次交付之后)。如果测试失败，不要继续，直到它被修复。我见过有人忽视自测，评论说“啊，我知道是什么问题导致了这个，我不需要立即修复它”，甚至感觉自己有冲动那样做。别做那种人。失败的测试意味着质量差的软件——无论是软件本身还是测试。不要接受糟糕的质量(即使它是一个非常讨厌的话题，比如字符集问题)。

您包含了一个针对无效对象的高级测试，但它失败了？修复无效对象或删除它们。如果它们是不可修复的，那么它们就是数据库中的废物，把它们处理掉。

不要为简单或明显的行为编写测试。测试一个返回序列下一个值的函数就像下面的注释一样有益(我喜欢对源代码进行好的注释，不要误会我的意思):

```
-- Increment i
i := i+1; 
```

测试您的公共 API。测试重要的功能或测试非常复杂的算法。测试对软件成功至关重要的东西。

如果你测试琐碎的行为，你污染了你的源代码，浪费了你本可以在更高层次上创建一个更有意义的测试的时间。

不要仅仅为了增加项目的自测数量而编写测试。它们会给你一个错误的信心错觉，降低可维护性。写自测并不意味着你不用动脑子。它是一个提高软件质量的工具。如果你的自测导致了较低的代码质量，那你就做错了。

像对待其他代码一样对待测试。否则你的测试将变得毫无意义。无意义的测试比没有测试更糟糕，因为它们不能提供信心的堡垒。他们提供用纸板做的堡垒正面，隐藏着一个巨大的深洞。

# 测试驱动开发(TDD)

过去几年中最著名的敏捷编程技术之一，[测试驱动开发(TDD)](http://www.agiledata.org/essays/tdd.html) ，创建了一个基于测试优先的设计原则，将整个开发和设计过程主要集中在(单元)测试上。

虽然 TDD 无疑将自动化自测的重要性和必要性带回了人们的脑海，但是实践 TDD 的部分社区越来越积极地认为 TDD 是开发软件的唯一有效和“专业”的方法。尽管有一些严肃的争论，从经验上质疑单元测试在大多数情况下的有用性，并批评 T2 过度关注单元测试是如何损害软件设计的。就连 TDD 的[死了都被公布了好几次。](http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html)

为了说明这一点:繁重的单元测试和 TDD 的批评者并不质疑自动化自测的有用性。他们批评过分关注一种特殊的自我测试以及围绕这种测试而产生的设计原则。

在我看来，TDD 方法，尤其是今天许多 TDD 实践者的观点包含了越来越多的教条。在我的经验中，教条的方法和争论很少导致务实的解决方案(这是教条的[一](https://en.wikipedia.org/wiki/The_Troubles) [一般](https://en.wikipedia.org/wiki/Crusades) [问题](https://en.wikipedia.org/wiki/Islamic_State_of_Iraq_and_the_Levant)，不仅仅是在软件开发技术的问题上)。

我并不是说 TDD 或单元测试已经死了，它可能是一个伟大的工具，对于某些情况来说是一个合适的方法。但是我鼓励每个人对任何教条的、宗教的规则保持批判。正如我在前一章所说:自测必须有意义。如果不是，它们就是无用的代码，会损害你的项目，不管它们是否作为 TDD 的一部分。

因此，让我们开始编写有意义的、自动化的、易于运行的自测，以便在快速变化的环境中给予我们所需的自由和创造力。

[![](img/6a719b399ecef23066ec5404bd7a0ad4.png) ](http://feeds.wordpress.com/1.0/gocomments/cleandatabase.wordpress.com/533/) [ ![](img/0898c4f85d9bdb948a7fc712f4d2f115.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--aM9Hsiim--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://pixel.wp.com/b.gif%3Fhost%3Dcleandatabase.wordpress.com%26blog%3D134663363%26post%3D533%26subd%3Dcleandatabase%26ref%3D%26feed%3D1)