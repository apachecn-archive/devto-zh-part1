# 如何在源代码控制之外实现零代码更改

> 原文:[https://dev . to/funky si 1701/how-to-get-zero-code-changes-out-of-source-control-4 iao](https://dev.to/funkysi1701/how-to-get-zero-code-changes-outside-of-source-control-4iao)

源代码控制是 web 开发人员的饭碗，但是对于 SQL 开发人员和其他业务人员来说就不那么重要了。我来年的目标之一是让我的整个团队使用源代码控制过程。

反对使用源代码管理的一个理由是总会有一些不使用它的例外情况。让我们看几个场景来帮助说明源代码控制。

**场景一**

Web Dev 1 在产品中做了一个改变来修复一个问题，并且没有使用源代码控制。Web Dev 2 正在开发一个新特性，并利用了源代码控制。他被允许部署他的新特性，并在此过程中撤销 Web Dev 1 的修复。

管理层指责 Web Dev 2 在部署过程中“破坏”了东西。Web Dev 2 不理解发生了什么，Web Dev 1 对整个场景视而不见，尽管事实上是问题的一部分。

**场景二**

一个 SQL 开发人员通宵工作来解决一个问题。他部署到生产环境中，没有注意到由于睡眠不足而遗漏了 where 子句。

—

让我们来看一下整个团队购买源代码控制的这两个场景。

**场景一**

Web Dev 1 在产品中做了一个改变来修复一个问题，并且也提交了源代码控制。这需要他额外的 5 分钟(如果是这样的话！Web Dev 2 正在开发一个新特性，并利用了源代码控制。他得到了部署新特性的许可，并在部署到生产环境之前，在这个过程中合并了 Web Dev 1 的修复。

管理层对 Web Dev 1 很满意，没有任何问题，新功能使网站变得更好而不是更差。

**场景二**

一个 SQL 开发人员通宵工作来解决一个问题。他部署到生产环境中，由于睡眠不足，他没有注意到遗漏了 where 子句，他还提交到源代码控制，这花费了他额外的 5 分钟(如果是这样的话！).

早上，一位同事查看了晚上提交的内容，并查询了缺少的 where 子句。在源代码控制和部署中进行了修复，但是管理层和客户并不知道问题已经被创建和修复。

—

这些都是简单的场景，但是我想不出不使用源代码控制会有什么更好的结果。这些例子假设没有连续的部署，在每个团队购买源代码控制之前将它添加到系统中会导致到处都是错误和问题。

然而，对于一个 100%落后于源代码控制的团队来说，持续的部署可以实现惊人的生产力提升。之后，每个提交代码都可以被自动测试，由团队的其他成员审查，并部署到测试环境中进行进一步的分析。只有经过审查的测试代码才能接近生产环境。

说了这么多，当你致力于培训个人和说服管理层的时候，有一些方法特别是在 SQL 方面可以减少松散的变更。在将任何代码部署到生产环境之前，都要进行模式比较。如果你只看到你所做的改变，你可以继续前进，如果你没有对你的团队大喊大叫。

**优势**

代码评审

团队意识到什么正在被改变

历史变化

更顺畅的部署

自动化

更好的团队合作

不同版本之间的差异变化

更多

**缺点**

是时候学习工具了

记得提交变更

使用二进制文件的技术更难版本控制

帖子[如何在源代码控制之外实现零代码变更](https://www.funkysi1701.com/2017/11/13/get-zero-code-changes-outside-source-control/)首先出现在 [Funky Si 的技术演讲](https://www.funkysi1701.com)上。