# 重构基础

> 原文：<https://dev.to/arne_mertz/refactoring-basics>

*本文[原载](https://arne-mertz.de/2017/02/refactoring-basics/)在我的个人博客[“简化 C++！”](https://arne-mertz.de)。简化 C++！是一个关于现代 C++和干净代码的博客。*

# 参与代码的规则...

## 可编译的小步骤

你是否曾经花了几个小时编写你的代码，然后你试图编译并测试它——然后*什么都不能再工作了？通常，在这种情况下，你会花几个小时来解决问题，直到你意识到你只是陷入了更多的麻烦。最后，你沮丧地把所有事情都回滚，重新开始。或者更糟的是，你退缩了，甚至懒得再试一次。*

这就是为什么重构最好在小步骤中完成，每个步骤都要编译并通过测试。你可能会问，为什么要通过测试。你想要通过测试，因为*而不是*通过测试意味着你改变了一些行为。您要么意外地更改了您不想更改的内容，要么是故意更改的，在这种情况下，您也必须更改测试。

## 经常提交

路上的每一小步都是一个小小的胜利。每当您的代码编译、通过测试以及您所做的更改有助于实现重构目标时，设置一个回滚点。

当然，没有人希望看到一百个由单行变更组成的提交。但是 git 这样的版本控制系统可以提供帮助。例如，在我真正做某件事之前，我经常会做一些小的改变。如果一个变更没有编译或者没有预期的效果，我可以简单地返回到只有阶段化的变更。当我进行了足够多的更改后，我要么创建一个新的提交，要么修改上一个提交。最后，如果需要，我们可以将多个提交压缩成一个。

## 有计划

提前计划好每一小步。试着想一条从代码的当前状态到你想要达到的状态的路径。将你所做的和你计划做的进行比较——这样你就能及早发现你是否在朝着错误的方向前进。

不要偏离你的道路。如果你发现不好的变量名，违反设计原则或其他需要修正的地方，记下笔记，但先不要修正它们。完成你计划要做的事情，然后修正你的发现。这样你的改变就能保持专注和可理解。这也能防止你分心和遇到时间问题。如果在一天结束时，你开始了一打重构，但没有完成一个，那么这是没有用的。

## 来回地

做小步骤有时需要我们做一些中间步骤，这些步骤必须在以后撤消。例如，要将一个方法移出一个类，我们可能必须先将该类的其他成员变成公共的。稍后，当方法不再需要访问成员时，我们可以再次将它们私有。

起初，撤销我们几分钟前做的事情看起来像是浪费时间。然而，这样做给了我们一些安全，否则我们不会有。把它比作穿过一个漆黑的房间:沿着墙摸索着走，绕了一大圈，可能比在黑暗中跌跌撞撞地跑进家具里更安全。

上面的例子还展示了其他一些东西:我们被允许，有时甚至被要求在重构过程中打破编码规则。我们可以违反风格指南，复制代码，犯下各种暴行，只要我们的计划包括修复这些事情的步骤。

## 不要把事情搞混了

有时你可能会遇到一个问题，阻止你继续你目前的计划。请记住，重构意味着在不改变整体行为的情况下修改代码。如果您需要做这样的更改来解决您的问题，基本上有两种选择。第一种选择是尽早结束重构(但是修复您所犯的规则违规),并在下一步应用更改。

另一种选择是回滚到目前为止已经完成的步骤，修复问题，然后再次应用这些步骤。回滚并不一定意味着抛弃一切。例如，在 git 中，我们可以在重构开始之前检查一个点，在新的分支上修复那里的问题，然后在修复的分支上重新构建重构。

# ...更像是指导方针。

以上几点可能显得过于迂腐和乏味。另外，一小步应该有多小？这取决于你。如果你有信心可以一次迈出更大的一步而不会遇到问题，那就前进吧。如果您正在重构不熟悉且难以理解的代码，较小的步骤可能是合适的。

每个步骤之后运行的测试数量也是如此。在每 20 秒的变化后运行一个 3 分钟的测试套件会大大降低你的速度。这是投资时间和牺牲安全性之间的折衷。根据您的步骤的大小，只要您偶尔运行所有受影响的测试，甚至仅仅编译可能就足够了。