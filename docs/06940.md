# Redux 架构指南

> 原文:[https://dev.to/joeellis/redux-architecture-guidelines](https://dev.to/joeellis/redux-architecture-guidelines)

这些年来，我已经编写了许多 Redux 应用程序，它是迄今为止我最喜欢的 JS 框架。唯一的缺点是，与其他框架不同，Redux 在如何构建应用程序方面远没有那么固执己见。我更喜欢这种自由，但它确实会导致更陡峭的学习曲线，尤其是如果你是 Redux 的新手。因此，我决定写下一些我在构建 Redux 应用程序时经常使用的高级思维和结构。希望它对外面的人有用。

### [](#state)状态

##### [](#plan-your-state-shape)规划你的状态形状

就节省时间而言，预先规划状态对象的结构是你能为应用程序做的最有价值的事情。一个格式不良的状态对象会使你的应用程序难以维护，通过一些计划是可以避免的。在规划状态对象时，我快速检查了一下这个清单:

*   它将如何存储来自 API 的多种资源(用户、帐户、项目等)？
*   它将如何处理加载状态(在获取/更新数据时显示加载微调器)？
*   它将如何处理 UI 成功和错误通知的显示和清除？
*   是不是感觉一致，可预测？其他团队成员能轻松使用它吗？
*   访问其中的数据容易吗？它会不必要地嵌套属性吗？
*   是否可序列化？它可以很容易地存储在本地存储或数据库中吗？
*   有没有什么属性可以从 URL 中提取，而不是放在 state 中？
*   这里有重复的数据吗？如果有，真的需要吗？

有许多不同的方法来回答这些问题——这取决于你的应用程序。但是根据我的经验，从长远来看，至少每个问题都有一个答案会节省你的时间。

##### [](#avoid-nesting-state-objects)避免嵌套状态对象

一些 Redux 应用程序有深度嵌套的状态结构，比如看起来像这样的形状:

```
{
  foo: {
    bar: {
      baz: {
        qux: ...
      }
    }
  }
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这在我们处理关系数据时经常发生，因为使用嵌套来表示这些关系感觉很自然。不幸的是，嵌套的数据结构造成了复杂性。在组件级别，您必须更深入地了解状态才能获得某些信息。在 reducer 级别，将新数据合并到您的状态将变得更加复杂。最重要的是，嵌套数据甚至会导致 React / Redux 本身的性能问题。

考虑将你的状态形状变平并[正常化](http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html)。在 Redux land 中，嵌套越浅，在应用程序中获取和更新状态数据就越容易。规范化状态有助于解决上面列出的问题，并使您的状态总体上更加灵活。

##### [](#storing-only-raw-data-in-the-state)只存储原始数据的状态

使用 Redux 的状态作为载体来存储您认为以后可能需要的任何和所有信息是很有诱惑力的。然而，这样做会以状态膨胀和冗余属性的形式增加应用程序的复杂性。这反过来增加了您的操作、缩减器和测试的复杂性。那么什么东西应该储存，什么东西不应该储存呢？

在 Redux 应用中，实际上有两种类型的数据。第一个是原始数据，即应用程序运行所需的数据。从 API 获取的用户数据就是原始数据的一个例子——没有它，你的应用程序就没有运行所需的信息。第二种是派生数据，或从其他现有数据创建的数据。使用`firstName`和`lastName`属性将用户名显示为`Jane Doe`是派生数据的一个例子。

我建议在您的状态下只保存**原始数据。它有助于减少状态膨胀，并使推断应用程序中哪些数据是重要的变得更加容易。所有其他派生数据都应该使用函数来创建，这些函数接受来自状态的原始数据返回您需要的信息。**

在向状态对象添加新的东西之前，问自己这样一个问题，“我能从状态中已经存在的数据创建它吗？”如果答案是肯定的，那么用一个函数创建数据。如果答案是“否”，那么您可能有很好的理由将这些数据添加到状态中。随着时间的推移，你可能会惊讶于答案往往是“是”

##### [](#prefer-redux-state-over-react-state)偏好还原态而非反应态

React 自带管理组件内部状态的系统。但是，在 Redux 应用程序中，对于大多数应用程序数据和组件间通信，更喜欢使用 Redux 的状态。当组件有一种可接受的方式来设置和访问状态时，对你的应用程序进行推理总的来说要容易得多，尤其是当你在一个团队中工作时。

请注意，本指南也有合理的例外。对于复杂的 UI 组件来说，使用 React 组件状态来持久化本地属性是有益的，尤其是当这些属性对于应用程序来说不是全局重要的时候。当这样做时，只需尝试将反应状态管理局限于该组件。过多地使用两个独立的状态系统，尤其是对于组件间的通信，很可能会给开发人员带来困惑。

### [](#actions)动作

##### [](#standardize-action-payloads)标准化行动有效载荷

当与团队合作时，为您的动作建立一个标准的对象形状非常有帮助。这样做减少了 [bikeshedding](http://bikeshed.org/) 并创建了可维护和可测试的代码。我强烈建议你的团队采用某种标准。我使用[通量标准行动规范](https://github.com/acdlite/flux-standard-action)，因为它简单易懂。但是不管你用什么，要确保它是一致的，并且容易使用。

##### [](#ensure-action-creators-are-composable)确保动作创建者是可组合的

我遇到的许多示例应用程序和教程在教授 Redux 概念时都使用简单的 action creator 函数。这很好地说明了一个观点，但是现实世界的应用程序是复杂的。不可避免的是，您将需要组合更高层次的复杂动作，最好是来自您已经编写的现有动作创建器。

养成一个习惯，确保你所有的动作创建函数都可以以某种方式组合。这是一个简单的规则，当你需要它的时候，它真的会有回报。我亲自将每个动作创建者包装在一个[承诺](https://github.com/then/promise)中，这样就可以使用`then`函数轻松地将他们链接在一起。

### [](#component-architecture)组件架构

##### [](#containers-amp-presentational-components)集装箱&表象组件

对于构建稳定且易于维护的 Redux 应用程序，我遇到的最有用的概念是 Dan Abramov 在 Redux 官方文档中描述的[容器&表示组件](http://redux.js.org/docs/basics/UsageWithReact.html#presentational-and-container-components)范例。我不会在这里深究，因为文档已经用很好的例子很好地解释了这个概念。但是理解这种范式可能是你在 Redux land 可以学到的最有用的东西之一。如果没有它，即使是中等复杂程度的应用程序也很难维护和迭代。好好学。

##### [](#use-intermediary-containers)使用中介容器

虽然容器/表示组件范例是可行的，但是并不总是清楚何时应该引入容器。我见过(也写过)只有一个顶级容器的应用程序，它获取整个世界，然后将一切传递给组件的子组件和子组件的子组件。这导致道具在被使用之前就“穿过”了多个组件。随着应用程序的增长，这变成了一个恼人的问题，因为即使是简单的更改，如重命名道具，也涉及到更改许多其他不相关的组件。肯定是代码的味道，有些不对劲。

相反，当您注意到多个道具“穿过”多个组件时，请创建容器。当中间的容器可以访问状态并为您创建这些道具时，没有必要将道具从一端传递到另一端。中间容器还有额外的好处，比如封装组件树的各个部分，使得它们的子组件更容易维护和测试。如果情况需要，不要害怕使用它们。

### [](#there-are-no-rules)没有规则

我列出的所有指导方针只是我发现值得重复的模式。但是，不要认为这些要点是唯一的做事方式。毕竟，Redux 的最大优势之一是它的自由形式结构，所以知道什么时候应该“打破”规则，尝试新的东西。如果你有自己的创造性的方法来解决上面列出的任何问题，请告诉我——我很乐意听听！

*这篇文章最初发布在 [joeellis.la](http://joeellis.la/redux-architecture/) 上。*