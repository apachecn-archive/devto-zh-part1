# (不要害怕)正则表达式:正则表达式实用介绍

> 原文：<https://dev.to/hawkinjs/dont-fear-the-regex-a-practical-introduction-to-regular-expressions>

你以前用过琴弦吗？没错，那些我们都知道并喜爱的“字符数组”？除非你只用 C 语言编码，否则我敢打赌你肯定用过——甚至很多。

但是用很多弦呢？或者使用你的程序没有生成的字符串？也许你正在阅读一封电子邮件，解析命令行参数，或者阅读说明书，你只是需要一个更结构化的方法来处理这些。

当然，您可以迭代字符串中的每个单词或元素。您可能会理解您用来这样做的代码。但是对于大型应用程序来说，这可能会变得非常难以承受，并且维护起来非常昂贵。

### 回车:正则表达式

在不深入计算机科学的情况下，让我们快速定义一个正则表达式。

*   正则表达式是描述正则语言的语法
*   正则语言是一种形式语言，可以用有限状态机来描述

关于正则语言有很多更好的解释，所以如果你还不满意，就谷歌几分钟。

### 回车:Regex

如果它还没有，这里是它变得时髦...我区分了编程语言所谓的“正则表达式”和计算机科学所谓的正则表达式。

*   计算机科学正则表达式——描述一种常规语言的语法
*   编程语言正则表达式——描述最多一种*上下文相关的*语言的语法

上下文敏感的语言要复杂得多，也有用得多，所以我们现在称一种编程语言正则表达式为“regex ”,以巩固其语言*不是正则语言*的区别。

### 学习写正则表达式

如果正则表达式符合两个//之间定义的“模式”,则在//和匹配字符串之间描述正则表达式。例如，`/Hi/`匹配“Hi ”,因此我们可以使用正则表达式检查一个字符串，看它是否是(或有，稍后将详细介绍)字符串中的“Hi”。

我们通过正常输入来用正则表达式匹配字符串中的字符。例如，`/Hello World/`将匹配字符串“Hello World”。

我们可以通过添加一点正则表达式来简化它，使其匹配任何*单词:`\w`匹配任何只由字母组成的“单词:`\w`匹配任何一个单词(如果只是字母)。*

我们同样可以用`\d`来匹配数字。

#### 例 1

很好，所以我们现在可以执行字符串相等，或者看看字符串是否符合一些简单的模式。那又怎样？它们能更有用吗？

你打赌！比方说，我们编写了一个 IRC 聊天机器人，它监听某人说“Josh”。我们的机器人基本上扫描每个人在频道中说的消息，直到我们得到一个匹配。然后，机器人会回应“哇，我希望你不是在说我的朋友乔希的坏话！”因为乔希唯一的朋友是机器人。

...

我们的机器人将使用模式`/Josh/`来匹配字符串。

突然，一个叫伊莱的人踉踉跄跄地走过来:“伊莱:乔希，你真的需要那么多咖啡因吗？”

我们的机器人将启动齿轮，用`/Josh/`扫描信息，找到一个匹配！他这么回答了，伊莱吓了一大跳。任务完成！

或者是吗？

如果我们的机器人更聪明呢？如果机器人称呼说话人的名字会怎么样？类似于“哇，我希望你不要说我朋友乔什的坏话，伊莱。”

### 量词(重复的字符)

#### 0 或许多

我们可以做到...但是我们必须学习一些东西才能到达那里。首先，**量词**(用于重复字符)。

我们可以用*来匹配 *0 或者它前面的很多*字符。例如，`/a*/`与“aaaaa”*匹配，也与*“”匹配。没错，会匹配*空*串。

*用于匹配可选内容，因为它匹配的字符不一定存在。但它可以。而且可以存在很多很多次(理论上无限多次)。

我们可以将“Josh”与`/Josh/`匹配，但是我们也可以将“JJJJJJJJJosh”和“osh”与`/J*osh/`匹配。

#### 1 个或多个

+可以用来匹配 *1 或多个*字符。除了现有的字符不再是可选的之外，它实际上与*的工作方式相同。我们现在必须至少有一个字符匹配。

因此，我们可以将“JJJJosh”和“Josh”与`/J+osh/`匹配，但不能将“osh”匹配。

### 通配符

太好了，我们现在可以匹配更多有趣的功能。如果有人真的生我的气，可能会大叫“Joooosh”...

但是如果他们气得把脸往键盘上撞呢？如果我们不知道“afuhiudgosigs”的鼻子有多尖，我们如何匹配他们？

带**通配符**！

通配符允许你匹配*任何东西*。他们的语法是`.`。(对，就一个时期。句号。).你可能会经常用到它，所以不要把它和句子的结尾混淆了。

通过结合我们在这个 regex: `/Jo+.*sh/`中的重复字符和通配符的知识，我们可以用这个来匹配“Joooafhuaisggsh”。明确地说，这将匹配 1 个“J”、1 个或多个“o”、0 个或多个*通配符*，以及 1 个“s”和 1 个“h”。这五个街区把我们引向我们所谓的...

### 人物群体

**字符组**是按顺序出现在字符串中的字符块。当你使用`*`或`+`时，你实际上是在匹配最后一个*角色组*，而不仅仅是最后一个*角色*。

这本身就有助于理解，但与重复字符结合起来，可能会非常强大。为此，我们可以使用括号定义自己的字符组(就是这些家伙)。

假设我们想要重复“Jos”而不是“h”。所以“JosJosJosJosJosh”会匹配。我们可以用 regex `/(Jos)+h/`轻松做到这一点，对吗？

但是最后...回到我们的例子，我们如何在 Eli 发送的 IRC 聊天消息中得到他的名字？

字符组也是记忆字符串的一种方式。这样，当我们看到一个符合模式的字符串时，我们可以将字符串的一部分添加到程序代码的变量中。

要做到这一点，通常您会做类似于`\1`的事情来匹配第一个指定的组。

例如，`/(.+) \1/`就是一个特殊的例子。在这里，我们看一组随机字符 1 次或更多次，之后有一个空格，然后再次重复*完全相同的字符*。所以这个正则表达式将匹配字符串“abc abc”，但是*不匹配*“ABC def”，即使“def”将独立匹配`(.*)`。

记住匹配是非常强大的，它可能会归结为用正则表达式编程的最有用的特性。

### 例 2

嚄...终于准备好继续我们的 IRC 机器人了。让我们用我们所学的来看看谁在说脏话。

如果我们希望在发件人说“Josh”时捕获他们的名字，我们的正则表达式可以是这样的:`/(\w+): .*Josh.*/`并且我们可以将匹配作为变量保存在我们的编程语言中，以用于我们的回复。

这只是一个或多个字母后跟“:”，一个代表 0 个或多个字符的通配符，字符串 Josh，以及一个代表 0 个或多个字符的通配符。

> **注意** : `/.*word.*/`是匹配包含“单词”的字符串的一种简单方法，这个单词周围可能有也可能没有其他东西。

在 Python 中，正则表达式可能如下所示:

```
import re
pattern = re.compile(ur'(\w+): .*Josh.*')  # Our regex string = u"Eli: Josh go move your laundry" # Our string 
matches = re.match(pattern, string)        # Test the string 
who = matches.group(1)                     # Get who said the message print(who)                                 # "Eli" 
```

Enter fullscreen mode Exit fullscreen mode

注意，我们使用了`.group(1)`，就像在 regex 模式中使用`\1`一样。除了在 Python 中使用正则表达式之外，这里没有什么新东西。

### 开始和结束

到目前为止，我们实际上已经允许匹配字符串出现在字符串的任何部分。对于 intsance，`/(Jos)+h/`将匹配 stringg 中任何地方包含 Jos-repeating-h *的任何字符串*。

如果我们希望字符串以 Jos-repeating-h 开头呢？我们可以用`/^(Jos)+h/`来指定，其中`^`匹配字符串的开头。

类似地，`$`可以用来匹配字符串的结尾。

因此，如果我们希望我们的模式从头到尾匹配包含 Jos-repeating-h 的字符串，我们可以将它修改成这样:`/^(Jos)+h$/`。

### 字符选项

但是也许你正在为一个三明治订单写一个正则表达式。你不知道顾客想要白面包还是小麦面包，但你会接受任何一种。如何在正则表达式中增加选择？用**人物选项**！

角色选项允许你为一个组指定一个可能值的*集合*。这种语法在我们的三明治上下文中是`(white|wheat)`的，在这里“白色”或“小麦”都可以接受。

您也可以使用`[brackets]`以另一种方式指定选项。这里每个字符都是一个选项，而不是整个字符串。即" b "、" r "、" s "、" t "、" e "、" k "、" c "、" r "将被单独接受。但是这对于更复杂的组来说可能很方便，因为您可以在字符组中用一个字符代替更复杂的表达式。

### 修饰语

我们用`/slash marks/`来谈论正则表达式，对吗？我们知道中间是什么，但是边上是什么？

剧情转折，没什么。

*...从左边走。然而，右边有一些非常非常有用的东西。我们忽略了这么久，几乎是一种耻辱！*

**修饰符**修改应用正则表达式的规则。

这里列出了最常见的修饰词(来自[Regex101.com](https://regex101.com/)):

| 修饰语 | 绰号 | 描述 |
| --- | --- | --- |
| g | 全球的 | 所有匹配(第一次匹配时不返回) |
| m | 多线 | 使^和$匹配每一行的开始/结束(不仅仅是字符串的开始/结束) |
| 我 | 感觉迟钝的 | 不区分大小写的匹配(忽略[a-zA-Z]的大小写) |
| x | 延长 | 模式中#后面的空格和文本将被忽略 |
| X | 额外的 | 后面跟一个没有特殊含义的字母是错误的 |
| s | 单线线路 | 点匹配换行符 |
| u | 采用双字节对字符进行编码 | 模式字符串被视为 UTF-16。还会导致转义序列匹配 unicode 字符 |
| U | ungreedy | 默认情况下，匹配变得懒惰。现在，量词后面的`?`使它变得贪婪 |
| A | 固定 | 格局是^逼出来的 |
| J | 复制 | 允许重复的子模式名 |

例如，到目前为止，我们所有的例子都是*区分大小写的*。这意味着，大写或小写任何一个字符将使字符串不再匹配模式。我们可以用`i`修饰符使我们的模式*不区分大小写*。

也许伊莱很生我的气，所以他在聊天中夹杂了一些案例人物。不要害怕，`i`就在这里！我们可以用他的“我讨厌和乔什住在一起！！!"和`/i ha+te living with josh!+/i`一起暴怒。现在它更容易阅读，功能更强大，也更有用。厉害！

我会把剩下的修饰符留给你自己玩，但是我打赌你会发现`igm`是你最常用的。

### 接下来是什么？

希望本文向您展示了另一种更智能地与字符串交互的有用方式。我甚至还没有触及 regexs 的皮毛，但是您现在已经知道如何使用正则表达式来完成一些小任务了。

在你的正则表达式中有大量的符号/记号可以使用。通常，您会在堆栈溢出搜索中偶然发现它们，或者根据以前的经验猜测它们(例如，\n 是换行符)。你或多或少已经得到了你现在需要的东西，但是还有很多东西要学。

你可以得到一个完整的令牌列表，并在这里广泛地测试你的正则表达式。几乎每次我写 regexs 的时候，我都会使用这个网站，因为这个测试工具非常有用和强大。如果您还不确定如何用您的编程语言来完成，它甚至可以为您生成代码。

如果这对你来说是小菜一碟，那就去看看 [regex 填字游戏](https://regexcrossword.com/)。他们真的会让你想到正则表达式！