# 软件复杂性与复杂软件

> 原文：<https://dev.to/ravneetg/software-complexity-vs-complex-software>

这些年来，我一直听到‘这款软件非常复杂’‘我们无法轻易解决这个问题，它非常复杂’等等。大多数时候，当我们听到这种情况时，我们要么处于冲刺阶段，要么处于关键的错误修复周期。这两种情况都是时间紧迫的。所以需要做一个决定。很快。大多数情况下，所做的决定是用最少的时间“热修复”该产品。

我相信我们很多人都经历过这种情况。“热修复”奏效了。客户满意，整个软件正常工作。工程师们解决了这个问题。

但是这个问题真的结束了吗？谁记得做过什么热修复？该补丁程序是如何“应用”到代码中的。这是质量问题吗？它解决了症状还是真正解决了原因？

所有这些都归结为一件事——软件复杂性。不是复杂的软件。

而上述过程，在很多情况下，只是增加了软件的复杂度。如果没有关于修复如何工作的文档，从现在起 6 个月，它会增加软件的复杂性。12 个月后，同一位工程师会发现同样的代码也很复杂(因为在这个补丁的基础上可能还有其他特别的修复/补丁)。他们不会记得为什么添加了这一行:

```
var someValue = someOtherValue *0.65;

//100 lines of code

var someValueNow = someValue*0.5 > 1 ? someOtherValue : someValue * 0.25; //hotfix v1 <— this line was added for hotfix 
```

Enter fullscreen mode Exit fullscreen mode

这里发生的是，一些逻辑被翻译成代码，但没有被记录。没人明白这种逻辑背后的原因是什么。没有人关注修复的质量，是否遵循了良好的编码标准(将逻辑提取到函数中，保持函数特定于它们所做的事情)？

随着时间的推移，这增加了代码的复杂性。并不是说软件很复杂。复杂的软件是火星车登陆火星的动力。这很复杂。大多数时候，一个写得好的、有文档记录的软件并不复杂。由于缺乏标准的编码实践(使用软件设计原则)，缺乏文档，它变得更加复杂。

总有一天，软件所有者会害怕改变代码。为什么？因为，软件现在变得复杂了。好吧，如果所有者知道代码是如何工作的(通过文档，或者构造良好的代码)，就不会害怕改变。

工程师可以做一些简单的事情来将软件的复杂性保持在可管理的程度:

编码前的设计——我们经常看到仓促编写的代码(由于时间限制，由于缺乏全面的代码库知识等)...).这些类型的变化，虽然它们确实实现了“某些东西”，但很多时候它们做的事情要么是重复的，要么根本不需要。这就是我所说的 lint 代码。它比 lint 代码好一点——它可以执行，但是只有 20-30%的代码是真正需要的。休息只是头顶上的棉绒。如果精心设计，本来可以避免的事情。记录需要什么-记录多少？如果你可以在代码中记录一个问题编号等的小引用，就这样做。稍后有人可以参考问题编号(希望其中有一些关于如何修补此问题的解释)。在哪里记录？可搜索的东西。如果被记录的“特性”不仅仅是一个错误修正，它应该有自己的文档页。如果变更是几行变更，在 bug 追踪器中的一个小解释应该足以确保未来的所有者知道为什么以及如何修复。测试/模拟——就像工程师喜欢创建软件一样，我们应该喜欢在软件进入测试/质量保证阶段之前对其进行模拟。为什么？因为知道你写的逻辑在不同的场景下如何工作将帮助你使它更有弹性。防弹的。此外，如果以后发现了 bug，这也为您提供了一个模拟场景的现成平台。
总之，随着时间的推移，代码的所有者使得软件的复杂度或高或低，而实际的产品并不复杂。