# 没有借口，写单元测试

> 原文:[https://dev.to/jackmarchant/no-excuses-write-unit-tests](https://dev.to/jackmarchant/no-excuses-write-unit-tests)

无论你用什么语言编写，单元测试有时都是一个棘手的问题。这有几个原因:

*   有人担心单元测试会花费你的团队没有的时间
*   您的团队无法就可接受的测试覆盖率水平达成一致，或者陷入自行车脱落的困境*
*   当更改代码时，人们会因为破坏测试而感到沮丧

首先让我们花一点时间来理解我所说的单元测试是什么意思。一个单元可以是任何可以独立执行的代码块。这可以是一个函数，甚至可以是一组函数，尽管后者由于许多活动部件而使测试更加困难。

一个函数很容易测试，如果它总是产生相同的输出，也就是说，当给定相同的输入(参数)时，它从函数内部返回相同的东西。

这对于测试来说非常好，因为我们可以基于这些返回值进行假设和设置期望值。想法是，当测试通过时，函数仍然满足断言中的需求，不管它如何得到那个结果。

**简单测试的例子:**

```
import { it } from 'mocha';
import { expect } from 'chai';

/**
 * Add numbers together
 *
 * @param {int} numbers One or many numbers to add
 */
const add = (...numbers) => {
  return numbers.reduce((acc, val) => {
    return acc + val;
  }, 0);
};

it('should add numbers', () => {
  const expected = 15;
  const actual = add(1, 2, 3, 4, 5);

  expect(actual).to.equal(expected); // true
});

/**
 * Subtract numbers from an initial number
 *
 * @param {int} initialNumber The number we start from when subtracting
 * @param {int} numbers       One or many numbers to subtract
 */
const minus = (initialNumber, ...numbers) => {
  return numbers.reduce((acc, val) => {
    return acc - val;
  }, initialNumber);
};

it('should minus numbers', () => {
  const expected = 5;
  const actual = minus(15, 5, 3, 2);

  expect(actual).to.equal(expected); // true
}); 
```

你可以随心所欲地进行这些测试。如果我们愿意，我们可以添加测试，看看当加减函数传递的值不是数字时会发生什么，它需要处理负数吗？

为最简单的功能添加测试可以为您提供关于以下方面的更多信息:

*   函数的使用难度(参数的数量，通过函数名理解输出)
*   该函数存在潜在风险，并且被其他开发人员使用
*   函数是否做得太多，要么是因为你不得不模仿这个世界来运行它，要么是因为你为每个函数断言了太多东西

从编写测试中可以获得很多，如果不这样做，将会失去很多。

### 你有时间进行单元测试

对你的代码进行单元测试需要一些额外的前期时间，因为，当然，你需要写额外的代码——测试。然后，在你写完那些测试之后，几周或几个月过去了，你对一个已经测试过的函数进行了修改，测试中断了。该死的。现在你必须进去修改测试。

我听到有人抱怨修复失败的测试很难，很费时间，或者是浪费时间。我的回答是，你更愿意在哪里修复这个 bug？当人们对特性被破坏感到愤怒时，你更愿意把它放在生产环境中，还是放在单元测试中，延长完成任务的时间？

如果你改变一个 API，事情就会变糟。如果测试没有中断，并且代码被发布到产品中，现在其他地方使用的代码都被中断了，你有 99 个问题，但是幸运的是，测试不是一个。我要告诉你的是，大多数团队都没有时间来修复产品中的 bug，然而时间总是为之而生。从经理到开发人员，每个人都知道修复生产中出现的 bug 很重要，但是我们总是等到他们进入生产时才修复它们。

对我来说，似乎我们可以在过程的早期进行错误修复，并花更多的时间关注代码的清晰性，从而促进对代码的理解。花在修复 bug 上的时间有一半是在搞清楚它到底是怎么发生的。如果你有一个单元测试，它会在你改变一些东西并运行测试时告诉你。

你做得越多，编写测试就越容易。你会发现，过一段时间后，你开始编写易于测试的代码，因为你在写代码的时候就在考虑如何测试这些代码！想象一下！

### 就写该死的测试

工程师以过度设计而闻名。我们抽象地思考，过多地考虑什么是简单的解决方案是正常的。最难的是意识到你可能走得太远了。

通常，当新事物出现时，我们想到的是最佳解决方案，而不是以有效的方式解决核心问题。

决定团队编码的最佳实践是非常重要的。包括测试覆盖率，测试什么以及如何测试等等都是好的。阻止你的团队尝试事情和从错误中学习是不好的。

不要让它阻碍你写该死的测试。任何新软件的一个好的经验法则是:

> 首先，让它发挥作用。那就弥补吧。

这条规则可以以多种方式应用到单元测试中，但我发现最有用的是首先编写代码使它工作，最好是小函数，然后为它编写测试。

现在您已经有了一个经过测试的函数，更改该函数的内部代码，看看测试是否仍然通过。
**简单来说——写。测试。重构。**

### 处理破损测试

在你开始写测试一段时间后，你应该开始注意到你改变的更多的东西会破坏现有的测试。这是好事。不要低估一个失败测试的力量。

首先，它迫使破坏测试的开发人员更多地了解一段代码将如何运行。如预期的输入和输出，这取决于测试的好坏。

第二，它迫使任何 API 变更都要经过深思熟虑，并根据变更的大小进行团队讨论。

第三，**也是最重要的**，是你在终端中发现的，而不是当客户试图做某事时。

就像任何事情一样，测试可能会走得太远。这取决于你在单元测试中深入到什么程度。

根据我的经验，我认为没有足够好的理由不至少进行一些单元测试。在一些预期的场景中运行代码，看看会发生什么。

这就像当你部署你的应用程序，并开始点击按钮，与应用程序互动。

你不会仅仅部署你的应用程序就忘记它的存在！

或者你会吗？今天就开始单元测试。从小处着手，逐步提升。

*自行车脱落指的是花在解决相对不重要的问题上的时间，而大问题应该在解决小细节之前解决。