# 编程范式和过程悖论

> 原文:[https://dev . to/ericnormand/programming-paradigms-and-the-procedural-paradox](https://dev.to/ericnormand/programming-paradigms-and-the-procedural-paradox)

我收集各种观点。我认为，我们能想到的每一个观点都是我们解决问题的另一个选择。我们都应该尽可能多地学习。每一个都增加了我们能够创造的解决方案的数量和质量。

编程范式是用软件解决问题的不同视角。每一种范式都是有价值的。但它们似乎很难定义。人们会无休止地讨论每个范式的含义，试图包容他们认为重要的和不重要的东西。举个例子，我们得到的函数式编程的定义令定义者满意，但不是每个人都满意。我们让人们指指点点，说“那不是真正的面向对象编程”。这些讨论并不令人满意，因为它们只是老调重弹，从未得出任何明确的结论。

我想从一个更广阔的角度来解释为什么它们如此难以定义。这可能有助于我理解如何定义它们。 <sup id="fnref1">[1](#fn1)</sup>

## 什么是编程范式？

> *范式*
> 
> 一个科学流派或学科的哲学和理论框架，在此框架内，理论、法则、概括和为支持它们而进行的实验得以形成
> 
> [韦氏词典](https://www.merriam-webster.com/dictionary/paradigm)
> 
> *范式*
> 
> a)包含科学界成员普遍接受的基本假设、思维方式和方法的框架。任何学科或团体成员共享的认知框架:公司的商业范式。
> 
> [Dictionary.com](http://www.dictionary.com/browse/paradigm)

大多数时候，编程范例是根据它们的特性或约束来描述的。我认为这是一个有用的视角。与一个范例相关的语言通常共享许多特性。例如，函数式语言通常有一流的函数。

但是有一种更好的方式来思考范例，不会将它们简化为特性列表。每一个主要的范例都是解决代码问题的整体方法。范例是包含基本假设、思维方式和方法论的框架。根据语言的特征定义范式(OO 是封装，FP 是无状态)就是忽略了作为一种思维方式的*范式*的定义。这完全是一件精神上的事情，这就是为什么[你可以用任何语言编程任何范例](http://www.lispcast.com/fp-in-my-language)。

我想介绍三种主要的范例(过程的、面向对象的和函数的),并描述它们的特点和它们的整体方法。沿着这条路，我们将探索为什么范例的定义如此难以定义。

## 程序化编程

过程化编程是一种非常可靠的编程范式，已经证明了它在行业中的可行性。如今，它没有得到应有的重视。

**特性**

程序编程的特点是*语句*，每个语句都有一个*效果*。例如，效果可能是设置变量的值，也可能是在终端上打印一行。你经常看到程序语言有包含其他语句的*子程序*(有时称为函数)。子程序允许你从其他效果中建立你自己的效果，给它们命名，并像其他语句一样调用它们。你得到重用和抽象。

**方法论**

用软件解决问题的过程化编程方法是将任何解决方案视为一系列要执行的步骤。每个步骤实际上可以是一个复杂的子任务，包含许多更小的步骤。我真的很喜欢这种解决问题的方法。它很好地对应了描述解决方案的一种非常常见的方式:实现解决方案所要采取的步骤列表。

这很像描述如何制作三明治的小学练习。如果你想把它写出来，这是一个非常复杂的过程。让我们假设你只被允许给出像“拿起”、“抓住”和“转动你的手臂”这样的粗略身体动作的指令。你可以煞费苦心地描述制作三明治所需的每一个动作。为了使它更易处理，您可能希望将常见的操作分解为子例程，并适当地命名它们。这是管理步数的唯一方法。

许多日常解决方案都给出了要完成的步骤。烹饪书中的食谱。家具组装说明。去图书馆的方向。任何指导性材料。这是我们都非常熟悉的东西。

许多人将过程性与全局变量和无限制的可变状态联系在一起。然而，我不认为这是范式的核心。很简单，大多数过程语言没有提供任何其他管理状态的好方法。这种范式本身非常有意义，如果与强大的工具相结合，它可能会很棒。一个简单的例子:交流连续的过程。将通道抽象添加到过程化(顺序)代码中，可以很好地处理并发性。

Python 和 Basic 是非常适合过程化编程的语言的一些很好的例子。

**悖论**

我喜欢过程化的另一个原因是语言特性与范例的映射非常好。连续语句(在随后的行上)意味着连续的步骤。子任务是用子例程定义和命名的。重复步骤是通过循环完成的。基本上就是这样。这种语言的任何其他特性都只是最重要的细节。

而这种语言特征与隐喻的紧密匹配，其实也是另一种特征。任务和子任务与语句和子例程如此匹配。您可以一气呵成地教授特性和范例！

他们之间有如此的对应关系，以至于感觉根本没有范式。这就是我所说的*程序悖论*。当你的语言非常适合范例，以至于你无法区分它们时，你就赢了，然而范例是看不见的。程序悖论让我们习惯于谈论特性，而不是隐喻和思维过程。谈论与语言不匹配的范例变得很困难。

## 面向对象编程

我真的很喜欢面向对象编程。我在大学里研究了很多，尝试了不同的解决问题的方法。我探索设计模式。

然而，大学毕业后，我开始阅读更多关于它的书籍。我看到了面向对象编程的发明者艾伦·凯的作品。他谈论面向对象编程的方式是我的教授都没有的。我了解到 Alan Kay 并不认为 Java 是面向对象的。这是我在 OO 设计课上用得最多的语言。这在我的灵魂中造成了深深的裂痕，从那以后我一直试图去修补。如果 Java 不是 OO，那什么是？

答案当然是闲聊。显然 Smalltalk 是如此的迷人，以至于其他语言采用了 Smalltalk 的一些特性来自称为 OO。这些语言成为人们学习的内容，而不是闲聊。所以现在我们称 Java 和 C++以及其他语言为面向对象，尽管它们不是。

我看过很多艾伦·凯的演讲。有些几次。我推荐他们，虽然他是一个深刻的思想家，并没有为你展示一切。我不得不记录了许多小时的 Kay 的谈话，才真正开始理解他在说什么。不过，很值得。我会参考他的作品，因为我认为他擅长区分思维过程和特征。如果你想进入艾伦·凯的谈话，从 [*开始计算机革命还没有发生*](https://www.youtube.com/watch?v=oKg1hTOQXoY) 。这是入门用语。

**特性**

许多人试图解释 Alan Kay 所说的 OOP 这个术语的真正含义。幸运的是，他时不时会出现在互联网上回答类似的问题。在一封电子邮件中，他列出了他所看到的面向对象的特性:

1.  信息传递
2.  本地状态的封装
3.  后期绑定

后期绑定很好解释。一个常见的编译器技巧是准确地找出需要调用什么指令，以便进行优化。所以你尽可能快地进行查找，有时是在编译时。您可能会看到编译器构建了一个包含所有函数及其名称的表。如果它认为这是更快的代码，它甚至可能内联这些函数。例如，Java 将内联方法调用。晚绑定意味着你不能这么做。您必须等到收到消息后才能查找方法定义，因为它可能在任何时候改变它的含义。

封装是指对象可以维护自己的状态并保持内部一致。读取或更改状态的唯一方法是发送消息。Java 实际上是把这个作为一个特性来做的。

消息传递很有趣。发送的消息必须在另一端被接收和解码。我相信这个特性是 Java 和许多其他面向对象语言所没有的。Java 中的方法只不过是在对象范围内执行的函数。没有必须被解释的消息的接收。这个解释步骤非常重要，因为它允许不同的对象以不同的方式解释消息——而不仅仅是对象通过在`vtable`中查找来解释消息的标准方式。例如，它可以有一个做其他事情的`method missing`方法。这个信息必须存在才能起作用。

这些就是特点。解决问题的途径是什么？

**方法论**

解决问题的方法有点难以理解。我们有一些线索，比如说 Java 不是它。我看了很多演讲，阅读了凯的所有资料。原来[我之前说的那封邮件](http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en)有很多线索。

1.计算机的细胞/网络

当艾伦·凯试图创建一个新的编程系统时，他受到了人体细胞的启发。细胞数量巨大。故障的数量是巨大的(细胞总是死亡或行为不良)。然而，这种生物具有惊人的弹性(尽管也不完美)。我们身体中的细胞是独立的，并相互发送化学信号。这是一个有趣的比喻，既指物体的大小(细胞很小)，也指我们可以达到的规模(数万亿个细胞)。同样，他经常提到的另一个比喻是网络上的个人电脑。每台计算机发送和接收信息。

因此，我们正在寻找一种解决问题的方法，将问题分解成相互发送消息的对象。如果你想在现实世界中找到一个类似的例子，你可能不得不去看看组织结构图或者其他的交流图。例如，餐馆的客人告诉服务员她想吃什么。服务员告诉厨师。然后厨师告诉服务员食物准备好了，等等。每一步都传递了一个信息。

来自[*small talk*的早期历史](http://worrydream.com/EarlyHistoryOfSmalltalk/):

> 你希望任何程序员做的最后一件事就是弄乱内部状态，即使只是象征性的。相反，对象应该呈现为更适合用作动态组件的更高级行为的*站点。*

2.摆脱数据

在 Smalltalk 诞生的时候，许多计算机科学和编程都与数据结构有关。这基本上意味着遍历指针和在内存中保持事物有序的算法。例如，您可以通过跟随`next`指针来编写一个遍历链表的循环。他把对象看作是避免如此复杂地组织事物的一种方式。对象管理它们自己的小状态，并且知道如何访问它们来提供高级接口。

> 然而，正确地进行封装不仅是对状态抽象的承诺，也是对从编程中消除面向状态的隐喻的承诺。>
> -[*small talk*T4 的早期历史】](http://worrydream.com/EarlyHistoryOfSmalltalk/)

这种避免面向状态的隐喻的想法很容易让人想起我们在 Ruby 社区中经常听到的[告诉不要问](https://martinfowler.com/bliki/TellDontAsk.html)原则。

3.代数

艾伦·凯有数学学位。简单来说，[代数](https://en.wikipedia.org/wiki/Universal_algebra#Basic_idea)是一组元素和对这些元素的运算。所以一个对象可能属于许多这样的集合，因此属于许多代数。举个简单的例子，一个字符串可以属于文本代数，也可以属于列表代数(字符)。

Kay 试图提供一种表达对象可以参与的一般行为的方法。我们看到 Java 风格的接口在这方面的尝试。但是一个更复杂的版本是 Ruby 的普及的 Duck Typing。

这种面向对象编程最明显的例子是 Smalltalk。但是 Erlang 可能更适合，因为它在消息传递方面更干净。它没有人们经常与 OOP 混为一谈的类、方法和继承特性。

**问题**

我应该说我真的很喜欢 Smalltalk 和 Alan Kay 的工作中所支持的范例。火炬至少部分是由 Ruby 社区传递的。但即使在那里，也是一触即发。这是为什么呢？

我认为原因是*程序悖论*。范式的支持特征与范式的假设和思维过程没有很好地对应。当然，这些特性支持这种想法，但是它们并不是一一对应的。在过程编程中，“过程抽象”(将一个任务分解成子任务)的方法论与“使用更多的子例程”非常一致。然而，在面向对象方法中，没有任何命令与使用特性的简单命令相对应。我不能说“多使用后期绑定”就指望多发展代数。为了学习“面向对象设计”，我们需要书籍来描述[告诉-不要问](https://martinfowler.com/bliki/TellDontAsk.html)、[命令-查询-分离](https://martinfowler.com/bliki/CommandQuerySeparation.html)，以及许多解释它们如何映射到范例特征的设计模式。

艾伦·凯谈到了面向对象的一些缺点，这些缺点早在 1993 年 Smalltalk 的早期历史中就很明显了。很清楚的是，仅仅借用特性而没有方法论是不会让你得到面向对象编程的，尽管许多人仍然这样称呼它。

> 一起使用的四种技术——持久状态、多态、实例化和作为对象目标的方法——占了很大一部分力量。这些都不需要使用“面向对象的语言”——ALGOL 68 几乎可以转向这种风格——一个 OOPL 仅仅把设计者的思想集中在一个特定的富有成效的方向上。
> 
> ——[*small talk*的早期历史](http://worrydream.com/EarlyHistoryOfSmalltalk/)

也许将特性与技术结合起来将有助于程序员更经常地进行“真正的面向对象编程”,并且我们可以免除关于面向对象设计的争论。例如，也许我们可以称方法为“目标”，称接口为“代数”。

Sandi Metz 是一位资深的 Smalltalker，是 Ruby 社区中“传递信息”的一员。在[Nothing is things](https://www.youtube.com/watch?v=OMPfEXIlTVE)中，她向 ruby 爱好者展示了 Smalltalk 中的消息传递是如何无处不在:甚至条件句都是通过消息传递完成的。她是一位伟大的老师，备受尊敬。然而，这个演讲显示了非 Smalltalk 程序员偏离范例有多远。我们将会看到功能性并没有好到哪里去。

**不是真正的 OOP**

艾伦·凯自己说，当他使用术语*面向对象*时，他脑子里没有 Java 或 C++。那么 Java 怎么不是面向对象的呢？显然，因为您可以在任何语言中使用消息传递范式，所以这也适用于 Java。但是在 Java 中经常发生的是，类只是用来将状态和状态上的操作捆绑到一个地方。太好了！除此之外，所有状态都是通过属性访问器(也称为 getters 和 setters)公开的。你基本上已经用函数重新创建了结构。代数中没有抽象概念。

在我看来，OOP 的一个问题是我可以向其发送消息的“抽象计算机”和“智能结构”(仅仅是将函数与数据捆绑在一起)之间的界限是多么的模糊。在这条线的一边，我们看到了高生产率、低行数、高度抽象的系统的美丽繁荣。另一方面，大量的大类都紧密耦合在一起。桑迪·梅兹介绍了一些简单的规则，这些规则似乎对[这次演讲](https://www.youtube.com/watch?v=npOGOmkxuio)有所帮助。弗雷德·乔治也在 [*敏捷*](https://www.youtube.com/watch?v=l1Efy4RB_kw) 的秘密假设中谈到了这一点。

那么什么样的*是 Java 的典范呢？我不知道它是否有一个清晰的、基本的范例。如果我必须选择一个，我会说这是一个自顶向下的建模范例。记住，我们在谈论解决问题的方法。我压倒性的经验是，在 Java 中，你被鼓励使用类对问题中的实体建模，使用方法对它们的行为建模。我做过一个关于面向对象教育的问题的演讲，名为 [*，是我的面向对象老师告诉我的*](https://www.youtube.com/watch?v=cdAVWYw-dO0) 的谎言，在这篇演讲中，我讨论了试图以这种方式建模世界的危险。这个演讲更深入，但只是简单的:当你在设计一个学校注册系统时，你真的想要一个学生类和一个课程类吗？他们有`register`方法吗？退一步说，你真正模拟的是学校用来记录哪些学生上了哪些课程的那本书。这本书有明确的属性(例如，它可能有先到先得的原则来注册课程)。*

 ***继承**

许多人将 OOP 与继承、类层次结构和 is-a 关系联系在一起。这可能是由于 OOP 在学校的教授方式。我不认为在没有消息传递的情况下，这个类的层次结构实际上能给你带来任何计算。它本质上是一个静态的概念，不会导致计算。Smalltalk 具有继承性，但是它在 Smalltalk 组内部进行了辩论，并且不被认为是该语言的核心。我认为对类层次结构的过度关注是试图将静态类型系统与继承结合起来的结果。

## 功能编程

函数式编程由来已久，但它最终得到了工业界的广泛关注。人们真的很好奇，有很多炒作，也有很多困惑，因为人们试图确定到底什么是 FP。

**特性**

函数式编程的特点显而易见:

1.  不可变数据
2.  一流的功能
3.  词法闭包
4.  纯函数
5.  ...

不是所有的函数式语言都有这些特性，就像不是所有的 OOP 语言都有类一样。它们只是在函数式语言中更常用。

**方法论**

解决问题的方法不太明确。已经有很多尝试，我将在这里一试身手。过程式编程将解决方案表达为一系列步骤，而 OOP 将解决方案表达为通信对象，而函数式编程将解决方案表达为数据、计算和效果。

1.数据

数据可以追溯到文字诞生之初，那时人们会记下他们交易了多少头牛。他们会为每个头画一幅画或打一个结。数字被永久地记录在介质中——因此我们希望数据是不可变的。

数据在计算机程序中扮演着类似的角色。你记录一些东西，比如用户输入，或者你从数据库中取出一个存储的记录，它被传递并用于计算。大多数程序都以某种方式使用数据，但它并不像函数式编程那样在范式中被明确地调用。

2.计算

函数式编程区分了有效的操作和纯粹的计算。计算以数据作为输入，返回数据作为输出。我喜欢把它们看作是从“表演”中分离出来的“思考”。你可以在购物的时候想想你在商店里需要什么。或者你可以在去商店之前花些时间计算一下你需要什么。

3.效果

效果是我们运行程序的原因。一般来说，我们运行程序是为了它们的效果。这意味着我们想在屏幕上看到一些东西，或者发送电子邮件，或者在世界上做一些事情。

把这三个想法分离出来，我们就把一个问题分解了。例如，提供一个网页可能看起来像这样:

```
Query DB => Data => Render HTML => HTML => Send response
  Effect    Data    Calculation    Data      Effect 
```

为什么要沿着这些界限把东西分开？嗯，这是因为他们的作曲方式。例如，两个效果可以连续(一个接一个)或并行(同时)合成，但合成的东西是一个新的效果。我们把这个非常粗略地写成`Effect + Effect => Effect`。

两个计算可以以类似的方式组成。我可以把两个函数串联起来(`function (x) { return f(g(x)); }`)。或者我可以运行它们并返回两个答案(`function (x) { return [f(x), g(x)]; }`)。无论哪种情况，我都会得到一个新的计算。`Calculation + Calculation => Calculation`。

而且，为了完整起见，有许多方法可以组合数据(hashmaps、lists、tuples 等。)，但是我总是把数据弄出来。`Data + Data => Data`。

有趣的是当我们把两个不同组的东西结合起来。我可以编写一个计算程序，比如字符串的大写，还有一个效果，比如打印。`function (s) { println(uppercase(s)); }`。在 FP 范式中，这将被视为一种新的效应。所以`Calculation + Effect => Effect`。

类似地，我可以把数据和计算结合起来。这就产生了所谓的*闭包*，这只是另一种计算。`Data + Calculation => Calculation`。

假设我做了一个新东西，总是打印(效果)“Hello”(数据)(例如`function() { println("Hello"); }`)，那么这个新东西就是一个效果，`Data + Effect => Effect`。

这些只是事物如何组合的一些例子。

但是接下来真的很有趣...因为你可以让一切都变得一流。您可以影响您的数据、作为其他计算参数的计算等。一个函数只是数据，直到你调用它。将函数应用于复杂数据类似于解释语言中的代码。记住这些想法都在你的脑海里。

当然，如果你能合成，你就能分解。使代码更具功能性通常包括沿着这三个边界分离出代码的各个部分。取一个效果，从中抽出一些计算。从你的计算中抽出一些数据等等。

*State* (一个随时间变化的事物)可能值得在这三者中占有一席之地。但是正如一些人所说，你总是可以从效果中创建状态，所以我们现在就把它打包。

**出现的问题**

其中一个问题是，许多函数式语言缺乏语言特性和这三个关键概念之间的严格对应关系。例如，在 Clojure 中，计算和效果之间真的没有区别。我们对两者都使用`fn` s。Haskell 用它的`IO`类型做得最好，它在它认为的效果周围标记了一条清晰而有用的线。但是，计算和效果的区分是任意给你做的。我相信这种对应比 OOP 中的稍微好一点。一般来说，让一些东西“更有功能性”意味着将更多的代码从效果转移到计算和数据中。

另一个问题是，我找不到其他这样分解事情的人。人们经常谈论缺少状态或缺少副作用，但这显然不是 FP 的定义。函数式程序的运行是因为它们的副作用，就像其他范例中的程序一样。事实上，这些“有问题的”特征被指出来，这表明它们对方法是多么重要。有些人谈论用一级函数编程，这暗示了结合计算的想法，但这忽略了其他两个想法。

还要注意，FP 观点卓有成效地区分了计算和效果，但这并不意味着这种区分在其他范式中也没有成效。更多的是它不是定义的一部分。将 FP 分析应用于其他范例肯定是有价值的，并且是多视角价值的另一个例子。

## 讨论

试图对范式进行分类可能是徒劳的。他们真的存在吗？我认为它们存在于我们的头脑中，这是我们大部分工作发生的地方。我们需要这种分类结构来帮助我们工作和讨论。

这些范例的好处是，如果你注意到，它们都不是纯粹的。当然，计算机相互发送信息是一个很好的比喻，但是你仍然必须以某种方式给每一台计算机编程。在 Erlang 中，这种编程倾向于以函数的方式完成，但是在 Ruby 中，它是过程化的。当在 FP 中编程我们的效果时，它们倾向于以一种过程化的方式完成(在 Haskell 中使用`do`符号，或者在 Clojure 中仅仅通过排序效果)。这绝对不是一件非此即彼的事情。这更像是互补的方法。你可以看到它们发生在建筑的不同层面。

然而，话虽如此，艾伦·凯“摆脱数据”的目标和 FP 对数据的热情使用之间还是存在冲突的。不得不说这本身就是一个大讨论。简单触及一下，看看 Smalltalk 坚持的“一切都是对象”。偶数是信息接收者。相比之下，Erlang 区分数据(数字、数组、元组、哈希表等)和流程(接收消息)。

在某种程度上，它们都摆脱了数据中一些最糟糕的部分——也就是说，任意使用字节块来表示数据结构和相应的代码来遍历这些数据结构。Erlang 做出了一个实际的决定，不允许新的数据类型，因此可以保证它们都可以被 VM 有效地处理，并且您没有机会在内存中创建任意的数据结构。另一方面，Smalltalk“摆脱数据”(数据是需要接收者解释的事实的惰性编码)的目标从未实现，并且仍然是艾伦·凯头脑中正在进行的思想实验。

## 结论

我们需要区分特征和方法。当我们争论的时候，我们需要意识到争论哪些特性定义了一个范式是没有多大意义的。范式是精神上的，通常很难表达，这就是为什么我们谈论“真正的 OOP”和“用我的语言做 FP”。

或许有希望打破程序悖论的诅咒。我们能让语言更好地表达范式吗？或者，更一般地说，从范式开始告诉我们如何设计语言？毫无疑问，所有这些范例都是有用的，而且它们并不相互排斥。它们只是对同一件事的不同观点——用代码解决问题。一种语言和它的特征应该被更清晰地构建为表达我们的思想的支持，而不考虑范式。

如果你对探索这类事情感兴趣，你应该订阅免费的 PurelyFunctional.tv 时事通讯。这是我正在阅读和观看的十个深层内容的链接，主要是关于 Clojure 和函数式编程。

* * *

1.  关于范例本身的另一个观点，请阅读[编程范例和表达能力](http://www.lispcast.com/paradigms-as-subtractive)。 [↩](#fnref1)*