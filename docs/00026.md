# 用户界面的状态驱动开发(第 1 部分:简介)

> 原文:[https://dev . to/nimmo/state-driven-development-for-user-interfaces-part-1-an-introduction-27 f1](https://dev.to/nimmo/state-driven-development-for-user-interfaces-part-1-an-introduction-27f1)

像目前的许多公司一样，我的工作场所在我们的代码库中有许多 Angular (1.x ),我们不希望写得更多。当然，这并不是对 Angular 的直接批评，但我认为公平地说，前端开发自其首次出现以来已经取得了很大进展，并且我们现在比多年前有了更好的选择。

我们已经有了几个用 React 和 Redux 开发的应用程序，我们已经决定将它作为新 UI 代码的默认设置。

为了帮助我们的工程团队顺利推出这些东西，我们想出一种结构化的方法来与他们合作。为了实现这个目标，我的同事 Todd 和我一直在考虑我们认为 UI 开发中最大的问题是什么，以及如何最好地解决它。

## 是什么*的问题？*

基本上，我们认为应用程序的状态(或者更确切地说，它可能具有的状态)应该是我们开发过程的起点，但是我们觉得`state`经常被错误地认为仅仅是我们应用程序中任何操作的副作用。

想象一下这样的场景:你刚刚加入了一个全栈团队。该团队负责一个电子商务应用程序，但后端是他们的主要关注点。他们有一位经验丰富的 UI 工程师，但这位工程师上周被公交车撞了，因此目前不在，这也是你加入团队的原因。你有 UI 经验，你来帮忙。您的第一个任务是添加一个新组件，如果用户没有登录，它将显示注册提示，如果用户登录了，它将显示用户最近购买的商品。

你已经有了一个设计，所以你决定不妨从编码开始。一旦你能看到你在做什么，你会觉得你毕竟在进步。

您通过标记工作，并找出新组件应该位于何处。您添加它，确保当用户登录时显示它的正确位，当用户注销时显示它的正确位，这样就完成了。*下一个*。

你可能还在想“好吧，但问题是什么？”。这很难看到，因为一切似乎都很好。但是这里发生的是:

*   一个应用程序的架构受到一个小的可视组件的影响
*   整体复杂性增加了
*   您对应用程序进行推理的容易程度已经降低

...同时进行。不仅仅是这个组件，还有*以这种方式添加的所有东西*。

## [](#so-what-can-we-do-differently)那么，我们可以有哪些不同的做法呢？

通过首先考虑应用程序的`state`(或者更确切地说，可能的状态),可以完全从相反的一端着手。

让我们来分解一下之前的任务:

```
Add a new component 
that displays a sign-up promotion if the user is not logged in, 
and the most recent items bought by the user if they are logged in 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

基于这项任务，我们现在对这个应用程序有用的所有信息是，它可以以两种状态之一存在:

```
LOGGED_IN
LOGGED_OUT 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我们对被要求添加的组件了解多少？我们知道它的形式是完全不同的，取决于它所处的状态。等等，这听起来像是*的一个*组件吗？

我多年前共事过的一位工程师曾经说过，单元测试描述中的“和”是在告诉你你有两个测试。我认为我们任务描述中的“和”是在告诉我们，我们正在处理两个组件。事实上，它们恰好在给定页面上的相同位置是完全不相关的，但当我们只考虑如何让*看起来*时，这就不那么明显了。

根据我们目前所知，考虑一下现在的情况:

```
possibleStates: [
  { 
    name: 'LOGGED_IN',
    RenderedComponents: [RecentItems]
  },
  { 
    name: 'LOGGED_OUT',
    RenderedComponents: [SignUpPromotion]
  }
] 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

现在我们有了一个清晰的概念分离，我们发现所有的事情都感觉更容易处理，而且我们有两个任务可以很容易地同时处理。或者至少这个*会*为真，如果整个应用程序一开始就以这种方式编码的话。

## [](#other-benefits)其他好处

我们发现以这种方式工作的最大好处包括:

*   降低认知负荷
*   易于测试
*   可视化文档的简易性
*   与行为驱动开发(BDD)技术的紧密联系

### [](#reduced-cognitive-load)降低认知负荷

将状态看得比什么都重要意味着您能够孤立地考虑单个应用程序的状态，确切地知道*您目前考虑的任何事情都不会对任何其他状态产生任何影响，除了潜在地将消息从一个状态发送到另一个状态(这是我们将在本系列的第 3 部分中讨论的)。*

### [](#ease-of-testing)易于测试

因为状态驱动开发(SDD)在我们的应用程序树中给我们留下了定义明确的路径，所以快照测试非常容易完成。我们认为，通过时刻高度意识到我们不同的状态类型，并能够将它们直接插入到我们的快照测试中，我们甚至不得不考虑编写的测试数量会大大减少。

### [](#ease-of-visual-documentation)易于可视化的文档

因为 SDD 导致一切都被仔细划分，所以很容易提供正在发生的事情的可视化表示。例如，下面是我们之前讨论的任务的应用程序树图:

[![State diagram showing paths for LOGGED_IN and LOGGED_OUT](../Images/bce09652d0b3f8dce2b31f29ac28097b.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--pth_pcC0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/anwxf7bndl6jqnsie5mt.jpeg)

这显示了通过我们的应用程序的单向数据流，从我们的身份验证存储开始，并根据用户是否登录显示了到 UI 本身(包括要表示的数据)的路径。

我们大多数人不喜欢写文档，但是当向人们描述我们的应用程序的架构时，或者当提醒我们自己时，很难否认它的价值。我在这篇文章前面提到的巴士因素不是巧合；我相信由于这一点，SDD 使得降低你的车队的巴士系数变得更加容易。

### [](#close-ties-with-bdd-techniques)与 BDD 技术关系密切

我们想得越多，就越清楚状态和动作的组合*就是*映射出你的应用程序的行为。这可能不是一个特别令人震惊的发现，但是当你仍然把状态简单地认为是“发生的事情”时，这是很容易忘记的事情。

我们是丹·诺斯(BDD 的创造者)的超级粉丝。你可能也是。如果是这样，你可能熟悉*在介绍 BDD* 时引用的这句话:“程序员想知道从哪里开始，测试什么和不测试什么，一次测试多少，如何称呼他们的测试，以及如何理解测试失败的原因”。

SDD 超越了这一阶段，允许我们通过将应用程序分解成可管理的应用程序树路径来轻松定义和构建我们的应用程序结构，这些路径基于已经转化为状态的行为。虽然这对于我们团队的非开发人员来说没有 BDD 有价值(因为它不是基于普遍存在的语言),但是它确实为开发人员增加了很多价值。我们认为这是一个可靠的方法，使得文档和实现之间的*非常*容易。

## [](#implementation)实现

为了使这更简单，我们还得出了一个结论:从有限状态机(FSM)的角度考虑我们的应用程序，而不是考虑来自用户的可能交互，已经提高了我们对应用程序进行推理的能力，并对我们如何规划它们产生了很大的影响。在[第 2 部分:用于 UI 开发的有限状态机](https://dev.to/dnimmo/state-driven-development-for-user-interfaces-part-2-finite-state-machines-3hgc)中有更多的介绍。

#### [](#links-to-things-ive-mentioned)我提到过的事情的联系:

*   托德·伦汉姆
*   [总线因子](https://en.m.wikipedia.org/wiki/Bus_factor)
*   [丹北](https://www.twitter.com/tastapod)
*   [介绍 BDD](https://dannorth.net/introducing-bdd)
*   [第 2 部分:用于 UI 开发的有限状态机](https://dev.to/dnimmo/state-driven-development-for-user-interfaces-part-2-finite-state-machines-3hgc)