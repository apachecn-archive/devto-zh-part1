# 用戳戳的方式来假装，笨蛋

> 原文:[https://dev . to/gone dark/fake-it-by-stubping-the-mock-dummy-df2](https://dev.to/gonedark/fake-it-by-stubbing-the-mock-dummy-df2)

我最近在 ZendCon 主持了一个名为*开始测试你的 PHP 代码*的研讨会。我已经给这个工作坊讲过几次了。我不断收到的问题是不同类型的*模拟*(测试对象)。

确实有差异。我经常借用马丁·福勒的定义(他借用了 T2 的杰拉德·梅萨罗什的定义)

*   虚拟对象被传递，但从未真正使用过。通常它们只是用来填充参数表。
*   **Fakes** 对象实际上有工作的实现，但是通常采取一些快捷方式，这使得它们不适合生产(an `InMemoryTestDatabase`就是一个很好的例子)。
*   存根(Stubs)为测试期间拨打的电话提供固定答案，通常对测试程序之外的任何事情都不作回应。
*   间谍是根据他们被叫的方式记录一些信息的存根。其中一种形式可能是记录发送了多少条消息的电子邮件服务。
*   **模拟**是预编程的预期，它形成了它们预期接收的呼叫的规范。如果他们收到一个他们不期望的调用，他们可以抛出一个异常，并在验证过程中进行检查，以确保他们得到了他们期望的所有调用。

当你刚开始测试时，所有这些都很清楚。这些术语在不同的测试框架中使用不一致，这一事实常常使问题复杂化。

这些差异可以归结为实现和使用上的细微差异。例如，*假的*和*存根*之间的区别可能仅仅是*假的*有一个底层类。或者说*间谍*和*模仿*的区别在于*间谍*也记录调用。

在我看来，这些差异无关紧要。通常，只有当测试框架做出这种区分时，它们才重要。不幸的是，mock(我在工作室中演示的模拟对象框架)造成了这种差异。

嘲讽*树桩*、*嘲讽*、*间谍*都是一回事。虽然它试图区分间谍和模仿，你仍然可以对模仿进行验证。他们唯一真正的区别在于他们的默认行为。mock*mock*要求你存根测试中使用的每一个方法。而间谍不会。如果你嘲弄地调用一个 spy 上的方法，它将简单地返回`null`。

在 mock 中，还有创建一个*局部 mock* 的能力，它的行为更像一个*假的*，因为如果你不存根它，它将调用已实现的(原始的)方法。

再说一遍，一清二楚。

我喜欢杰拉德·梅萨罗什的通称——双重测试。RSpec 实际上是通过简单地使用`double()`来创建*一个代替系统中另一个对象*的对象。

这很简单。测试时，我并不*真的*关心测试对象之间的差异。我只关心我能容易地创建和使用一个测试对象。

最后，虽然测试对象之间确实存在差异，但是我不想在测试的时候被它们阻碍。这归结为开发人员的快乐。*别让我觉得*！

***利用嘲弄？**我为 Mockery 创建了一个简单的助手函数，名为 [`double()`](https://github.com/jasonmccreary/test-double) ，将所有这些细微差别抽象回测试替身的一般用法，使测试更容易。*