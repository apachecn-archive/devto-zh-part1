# 使用 Scientist 进行增量重构

> 原文:[https://dev . to/uday _ rayala/incremental-refactoring-using-scientist-30pm](https://dev.to/uday_rayala/incremental-refactoring-using-scientist-30pm)

在我最近的一个项目中，我们必须用一个新的具有更多功能的定价服务来替换计算价格的部分代码。

计算价格是我们服务中最重要的部分之一，我们面临以下问题——

*   我们如何知道新的定价服务是否与我们的计算一样？
*   如果它没有按预期工作，它没有工作的输入是什么？
*   我们如何知道我们是否正确地集成了新的服务？
*   调用新服务对性能有什么影响？是更好还是更差？

我们可以用一堆已知输入的场景进行测试，但是生产都是关于意想不到的情况。我们需要一种方法来测试集成，然后才能向用户发布更改。就在那时，我们遇到了科学家。

> 科学家是一个小型的 ruby 库，它提供了必要的框架来测试你的新代码，而不用发布它。主要的构建模块是一个实验。它有两块代码**控制**和**候选**。每次调用实验时，都执行这两个块。但是只返回来自控制块的结果。候选块中的异常将被挽救。最后，可以比较和记录两个模块的结果，以供进一步分析。

想法是创建一个科学家实验，用控制块作为现有的本地价格计算，用候选块作为对新定价服务的调用。在直播前对比结果。

### [](#preparation)准备

在使用 Scientist 之前，我们想做几件事:

*   将现有代码重构为一个类。这样，我们可以使用类多态性在使用现有实现、新实现或科学家实验之间切换。我们使用 Figaro 来管理应用程序配置。因此，这种使用类多态性的重构将帮助我们传递类，以用作我们服务的配置。我将在下面展示我们是如何做到的。

重构后，我们现有的定价计算被转移到 LocalPricingEngine 中，使用估算方法: