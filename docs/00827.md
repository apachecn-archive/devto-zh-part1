# 星期五爆炸#23

> 原文：<https://dev.to/horia141/friday-blast-23-30ca>

[线程不能实现为库(2004)# pdf](http://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf)——重点是为了更好的并发支持，语言需要介入。仅仅依靠`pthreads`这样的库是不够的。原因是性能相关的——这样的库希望每个同步都经过它们，并且没有真正说明在没有库提供的同步的情况下使用的共享变量。然而，现代处理器提供了一些加锁之外的原语——原子操作、栅栏等。哪些*是获得最佳性能所必需的*，但是如果编译器进行了重新排序或其他优化，哪些就不能被正确表达。这也是安全相关的。一些优化可能没有意识到`pthreads`函数*的特殊行为，可能会产生*竞争条件或其他意外行为。这项工作是在开创性的 Java 内存模型之后进行的，但是针对 C/C++和其他低级语言(Ada？).在后来的版本中，C 和 C++拥有了内存模型*和*，这一切达到了高潮。

[我正在从您的网站收集信用卡号码和密码。以下是(2017)](https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5)——我们对第三方库的依赖既是福也是祸。如果我们有一个未审计的依赖关系(或依赖关系的依赖关系),它可以在敏感的上下文中执行，那么它就可以被用来窃取机密信息。作者提出了一个巧妙的例子来说明前端代码的 NPM 是如何做到这一点的，那里有大量的小的和没有被很好审计的包，一个项目可能会依赖它们。我觉得其中的一些原因是，JS 不包括的*电池。所以我们需要有类似 [`left pad`](https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/) 模块的东西。*

[SQL key in depth(2017)](https://begriffs.com/posts/2018-01-01-sql-keys-in-depth.html)-SQL key 的数据建模概述。我没有意识到主键更像是一个实现工件。有很多关于自然键和人工键的资料，以及如何使用代理键。非常值得一读。

[内存带宽(2017)](https://fgiesen.wordpress.com/2017/04/11/memory-bandwidth/) -直觉告诉我们为什么*内存对系统来说是个大问题*。在每个时钟周期可访问的*字节*方面，我们已经从 MOS 6502 的 4 字节/指令发展到最近的 Core i7 的 1 字节/指令。对于 SIMT 模式或 GPU 来说，事情甚至更加激烈。因此，虽然从绝对意义上来说，内存容量和带宽已经增加，但相对于处理器可以执行的指令数量来说，情况却变得更糟了。

[众数、中位数和均值——统一视角(2013)](http://www.johnmyleswhite.com/notebook/2013/03/22/modes-medians-and-means-an-unifying-perspective/)——原来众数、中位数和均值都是一个分布的三个差异度量的期望值，看起来非常相似。

[你知道你的电脑一秒钟能做多少事吗(2017)](http://computers-are-fast.github.io/) -一些事很多，其他事很少。大部分代码都是用 Python 编写的，但即使这样，您也会看到这样的情况——顺序内存访问很快，而随机内存访问很慢，或者文件 IO 很慢，但互联网上的网络访问甚至更慢。例如，每秒可以处理 1-2 个请求，这是示例中的最低值。尽管有大量异步 IO 来提高吞吐量的空间。最棒的是这是一个小测验。