# 构建一个工具，然后提取一个库

> 原文：<https://dev.to/rvprasad/build-a-tool-and-then-extract-a-library>

最近，我编写了 tool X，它接受一个布尔 SAT 公式(合取形式)以及一个模型/解释——公式中变量的真值赋值——并检查模型是否满足公式。

然后，我开始计划开发一个工具 Y，它为一个给定的布尔 SAT 公式识别一个令人满意的模型(如果存在的话)。显然，工具 Y 可以使用工具 X 中的算法作为子例程来检查模型是否满足公式。出于效率(避免通过文件系统在程序之间传输数据)、使用简单(安装一个工具)和避免代码重复等原因，如果工具 X 可以重构为工具 t-X 和库 l-X(其中 t-X 使用 l-X)就更好了。这将使工具 Y 能够使用库 l-X，并且更加高效、简单和避免代码重复。

虽然从软件工程的角度来看，上述所有内容都是有意义的——重用、简单性、减少代码重复等。，我现在想知道“在实现工具 Y 之前，我是否应该将工具 X 重构为 t-X 和 l-X？”

```
Is one possible reuse good enough to refactor out a library from a tool? 
```

我想答案是**不**。我的理由如下:

1.  一次可能的重用并不等同于一次重用。据我所知，将工具 X 中的算法用作工具 y 中的子例程可能是次优的想法。因此，最好验证这样的使用确实是最佳的，然后重构工具 X 和工具 y。

2.  一次重用不同于多次重用。一旦有了(可能的)第二次重用，重构工具 X 和工具 y 就更有意义了。

3.  这种重构需要为库 l-X 创建一个测试套件。由于测试套件的创建需要时间和精力(即使它是基于 tool X 的测试套件)，所以最好推迟到有必要重构的时候。

4.  多种用途可以帮助设计库 l-X 的接口。不同用途所需的行为的最大交集可以很容易地帮助识别库要捕获的行为。因此，这有助于设计一个足够通用的库 l-X 接口，使得许多客户端都可以访问这些行为。

以上原因无非是避免过早优化的原因。

现在，开始实现工具 Y:)

(原帖可在[这里](https://medium.com/about-things/build-a-tool-and-then-extract-a-library-913554310aaa)找到)