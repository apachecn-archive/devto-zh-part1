# 野外的小规模微型服务(1):不合时宜的整体

> 原文:[https://dev . to/kr 428/small-scale-micro services-in-the-wild-1-anachronistic-monoliths](https://dev.to/kr428/small-scale-microservices-in-the-wild-1-anachronistic-monoliths)

这年头微服务遍地都是。从零开始构建不同“微服务”的框架也是如此，帮助从微服务中构建真实应用环境的基础设施和运行时组件也是如此。使用小组件来构建更大、更复杂的应用程序似乎已经成为当今实际的工作标准，以至于我们倾向于将这种模式应用于手头的每一个问题。这取决于你的问题，可能是也可能不是一件好事(TM)。在过去的几年里，我们一直在将更复杂的应用程序切割成更小的组件，从中可以获得一些深刻的见解。我想花些时间思考这些事情，看看我们现在在哪里。

为了不至于让少数阅读这篇文章的人感到太无聊，也为了不要试图一次写太多而最终无法完成，我将试着把这篇文章写成一个简短的系列文章。希望它会以某种方式解决。

## 解决问题

一般来说，技术解决方案应该是对某些现实世界问题的实际解决方案，无论是在实际的业务领域还是在解决实际业务问题的技术领域。大多数情况下，微服务似乎属于后一类——一种解决构建重要应用程序时可能遇到的某些技术问题的技术解决方案。不要太惊讶，这些解决方案确实比其他解决方案更好地解决了一些问题，并且可能存在某些解决方案会使事情变得更糟的需求。微服务在这里也不例外，在优化现有 IT 环境的两个场景中都可以看到。

## 加快发展。

在大多数情况下，一个主要的痛点是众所周知的可用开发人员资源有限，假设我们大多数人不是 Google 或 Amazon，并且我们大多数团队都相当小。简单粗暴:你可能想要一整块。句号。这听起来非常不合时宜。然而，现在将系统分成微服务通常意味着由几个通过 HTTP 和 JSON 通信的小服务组成一个应用程序。从发展的角度来看，这有一些有趣的方面:

*   您将在诸如序列化和数据传输之类的事情上花费大量的大脑(以及 CPU)周期。你应该把你的业务对象和数据结构转换成某种语言无关的表示，这种表示可以通过某种线路安全地发送。在整体式应用程序中，所有或至少绝大部分通信都在本地进行，这几乎没有关系。您生活在一个共享的公共数据模型和公共应用程序上下文中，因此不涉及“外部世界”。

*   您将不得不通过处理所需系统可能随机响应过慢或完全失败的事实，以编程方式为您的应用程序增加可靠性和弹性。同样，在单个应用程序上下文中工作，如果应用程序倾向于作为一个整体工作或失败，这是没有任何意义的。

*   您还需要考虑重新传输某些批次的数据的场景，以及至少以一种基本的方式“正确地”处理诸如分布式事务之类的事情——无论对您的应用程序来说“正确”意味着什么。跨单个应用程序处理事务并不总是容易的(如果它涉及可能已经开始的数据存储和业务流程)；将一个事务跨越多个应用程序并不会使它变得更容易。

*   一旦您公开的任何接口被任何客户端使用，它将变得几乎“不可变”,因为(假设是松散耦合的系统)很难也不可能追踪到该特定系统的所有用户，所以删除“旧”方法总是比删除大型 Java 项目中不赞成使用的 API 更有风险，例如，一旦您删除系统的某些特定部分仍在使用的代码，该项目将无法构建甚至部署。

*   您将需要处理更多的样板文件，以便在基础设施中构建各种可分发的模块，以及各种依赖关系(如其他服务)的可配置性等。在 monolith 中，如果你做得正确，你将为整个应用程序做这些事情一次。

肯定不止这些，但我认为如果至少在我们的环境中遵循这样的方法，它们是最关键的。不过，你的可能不一样。

## 也加快行动速度？

开发很有趣也很好，但通常不会给我们带来任何收入；在大多数情况下，我们需要一个可运行的应用程序来实现这一点。此外，与开发、操作和运行应用程序非常相似，如果使用分布式系统，与某个应用服务器中的单个整体或单个应用程序相比，会变得更加困难:

*   突然间，您将不得不处理各种服务，这些服务需要启动并运行，以便整个系统能够完美地工作。您很有可能必须负责服务的(重新)启动，也可能是以正确的顺序。

*   大多数操作方面，如部署、日志记录、监控、调试或审计变得更加复杂，因为涉及到更多的组件。你很可能需要付出相当大的努力，甚至在概念上，来维护一堆相互依赖的模块，在这些模块中，给定一个整体，你将只需要处理一个应用程序，可能还有它的日志文件和监视钩子。

*   在一些用例中实际上的优势在简单的操作中变成了劣势:您将不得不考虑可伸缩性和性能，不仅仅是针对一个应用程序，而是针对许多应用程序。如果您遇到瓶颈，您可能会很难找到哪个组件是关键的，以及如何扩展它才能正常工作。

*   同样从系统安全的角度来看，事情可能会变得…有趣。显然，这包括向客户端公开和提供的 HTTP/REST API——它们是否总是得到适当的保护、审计和加密？或者，当本地网络流量根本不使用 HTTPS 时，SSL 终止只是发生在外部网关上的事情？服务能够检测(和处理)中间人攻击吗？应用程序是否能够以任何方式验证请求和响应，以确定它们来自哪里以及它们是否真的可靠？或者，更简单地说，我们如何避免内部服务使用存储在配置文件中的标准凭证(可能最糟糕的是存储在某个 git 存储库中，供整个团队使用)相互通信？我们是否确保“生产”系统只能相互通信，而不能从开发或测试环境中访问？

## 那么到底何必呢？

当我自己面对所有这些问题时，为微服务辩护的理由就不会太难了:大多数问题都有现成的解决方案。有编排和部署基础设施来处理大量的服务器和服务，从更“传统”的工具(如 puppet 或 chef)到大规模环境(如 kubernetes)。有很多工具，比如 zabbix、nagios、elastic stack 和其他很多工具，在大多数情况下都是开源的、免费的，正等着你去解决你的问题。此外，对于这些原因中的每一个，您可能会找到至少一个放弃单片结构以支持更模块化的微服务架构的好理由。

其实没关系。我也看不出 monolith 是一种非常理想的应用程序架构方法。但是，一如既往:你的里程可能会有所不同。如果有一件事要做的话，那就是:小心为什么要把你的系统变小。它最终会产生一个更加分布式的系统，至少最初会增加维护工作量，最终会给你的系统增加一个可能会失败的[意外复杂性](https://en.wikipedia.org/wiki/No_Silver_Bullet)的负载。因此，批判这种方法的缺点和不足，关注业务需求，最重要的是:

想出好的理由来解释为什么要建立一个模块化的分布式系统，而不是一个整体。此外，还要想出一个好主意，说明在您的环境中，一项服务的“小”或“大”规模是多么合适。这些原因可能会因你的业务领域和公司规模的不同而不同，所以我很快会花一些时间来思考我们仍然遵循这条道路的原因。敬请关注…并随时添加您的反馈和见解。除了报告我们的想法，我还想看看其他人在这个领域的经验...

(最初发布于[dm.zimmer428.net](http://dm.zimmer428.net/2017/09/small-scale-microservices-in-the-wild-1-anachronistic-monoliths/))