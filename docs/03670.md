# 框架没有错——除了你可能认为它是什么

> 原文:[https://dev.to/dguhl/nothing-is-wrong-about-a-framework——除了你认为是什么的议员](https://dev.to/dguhl/nothing-is-wrong-about-a-framework---except-what-you-think-it-is-mp)

框架的效用使社区两极分化。它们不仅数量多，而且解决的问题比开发人员实际解决的问题还要多。但也许这是一个框架的概念，一直以来都被误解了。

在 web 开发中，一种流行或广泛使用的语言和即将到来的对其缺陷的注意汇合在一起，形成了一段时间，在这段时间里，热情的开发人员将启动一个框架，以一种共同的方式解决共同的问题。JavaScript 有过这样的时代，PHP 有过这样的时代，还有 Java，Ruby，Python。

后三者发展出了一个单一的框架(分别是 Spring、Rails 和 Django ),不仅是编写它们的语言中的单一的通用编程解决方案，而且定义了我们目前对框架的理解:一个工具集，它收集了对程序员的问题的常见的或者重复的自我编码的解决方案，因此它们可以保持其实际应用程序逻辑的必要和整洁。

许多部署和构建应用程序的机制，例如，作为一组一起工作的组件，仅由一个*框架*保持在一起，在语言中不被我们今天所知的技术所支持:依赖管理器将第三方模块作为组件加载到我们的应用程序中，或者甚至根本没有模块化您的应用程序的可能性。

由于这个原因，为早期版本的语言提供的早期版本的框架不得不避开这些特性的缺乏，结果是这些框架作为工具箱出现，以解决开发人员在他们面临的每个项目中经常遇到的各种问题:数据库连接、HTTP 请求处理或控制台输出等等。

这使得早期框架的本质变成了对今天的框架的偏见。像 PHP 的 *Symfony* (或更小的足迹 *Silex* )或 JavaScript 的 *VueJS* 这样的现代框架，本质上是组件的集合，而我们都知道，作为框架交付它们的是*组件集合*的*标准版本*。如果你选择了一个好的框架，它使用了一个设计良好的依赖管理系统，用这个系统我们总是应该选择我们需要的部分。

例如， *Symfony* 的组件在其他项目和框架中也获得了广泛的成功:那个项目的 ORM 数据组件演变成了*主义*项目，模板组件演变成了*树枝*项目， *Symfony 控制台*组件是 PHP 生态系统中最受欢迎的控制台输出模块——甚至被受欢迎的 *Symfony* 继任者使用: *Laravel* 。

因此，当 PHP 的发明者拉斯马斯·勒德尔夫[表达他对框架](https://youtu.be/fYTKm2oUzAg)的怀疑时，他指的是一种实际上属于过去十年的框架:一个带有预执行堆栈的单片样板文件，其宽度与服务器机架一样，你只需在上面附加代码即可。由于当前的十年也快结束了，你可以清楚地看到这种对框架的错误理解在开发人员的头脑中保持了多久。

现代框架是模块化的，由组件构成。一个框架带给所有依赖它的应用程序的几个概念仅仅是你在你的应用程序中拥有和实现的概念:配置和自动加载机制(现在可以是依赖管理器的一部分)或者甚至像依赖注入或模型-视图-控制器这样的模式，以一种方式实现，这种方式可以在熟悉那个特定框架的每个开发人员之间作为常识共享，或者——如果你的社区已经超越了框架流行的时代——一个特定的语言标准，像[PHP Framework Interaction Group](http://www.php-fig.org/)在他们广泛认可和遵循的 PSR 的。

最终，现在的框架正在做框架一直以来的概念:它将选定的组件框到解决方案中。仅仅因为每个问题都可能有一个组件，并不意味着它们都必须在您的选择中:尽管框架提供了工具，但并不意味着您在每个项目中都使用它们。框架曾经的工具箱在一种改进的语言的环境下变成了一个工具商店，由各自的框架社区维护，并由开发人员访问。

**TL；博士** *框架从来不应该是一把瑞士军刀，而是一个平台提供者，让你的框架包含选定的模块工作。为此所需的模块化是大多数流行框架所基于的语言最近引入的特性。*