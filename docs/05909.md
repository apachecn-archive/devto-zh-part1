# 调试循环缺陷中的同步回调

> 原文：<https://dev.to/mortoray/debugging-a-synchronous-callback-in-loop-defect>

我在给`Each`添加新功能时发现了一个 bug:[Fuse](https://www.fusetools.com/)中的一个动态添加 UI 元素的行为。我不得不修改很多代码，所以我很勤奋地添加了一堆新的测试。`Each`这可能是我们现在最受考验的行为，但是，唉，一个回归溜走了！幸运的是，我们在预发布测试中发现了它，但这仍然在过程的后期。发生了什么事？

## 缺陷

一旦我们对缺陷进行了删减，缺陷的设置大致是这样的:

```
<StackPanel>
    <Each Items="{items}">
        <PanelA/>
        <PanelB/>
    </Each>
</StackPanel> 
```

Enter fullscreen mode Exit fullscreen mode

这个片段需要一个`items`列表，我们将在其中添加/删除项目。对于`items`数组中的每一项，我们向`StackPanel` : `PanelA`和`PanelB`添加两个子元素。当一个项目从`items`中移除时，我们希望这两个子项目都被移除。不幸的是，它们中只有一个被移除；另一个永远存在！

> 一个完整的例子将包含一个控制`items`的`JavaScript`代码块，但是因为它与问题无关，所以我在这里省略了它。由此产生的简单性令人震惊，没有一个测试能够发现错误。我稍后会回到为什么他们没有。

缺陷在这个清理代码:

```
for (int n=0; n < av.Nodes.Count; ++n)
    Parent.BeginRemoveChild(av.Nodes[n], CompletedRemove); 
```

Enter fullscreen mode Exit fullscreen mode

当从`items`列表中删除一个项目时，将删除子项目。`av.Nodes`是添加的节点列表，在本例中是`PanelA`和`PanelB`中的一个。有两个项目，所以我们期望`RemoveFromParent`被调用两次，但它只被调用一次！疯狂！

## 同步回调的危险

我以前写过一次关于[地狱循环迭代器](https://mortoray.com/2014/03/25/the-infernal-loop-iterator/)的文章，这种情况就是其中之一。它建立在同步回调的问题上，我在关于[事件编程](https://mortoray.com/2017/06/26/what-is-event-programming/)的文章中也提到了这个问题。

上面没有看到的是`CompletedRemove`回调的定义。一个节点上可能有一个`RemovingAnimation`,这意味着它会停留更长一点时间来动画显示它的移除。回调通知我们这个删除何时最终发生。

```
void CompletedRemove(Node n)
{
    //uninteresting bits...

    WindowItem wi;
    if (_dataMap.TryGetValue(n, out wi))
    {
        wi.Nodes.Remove(n);

        //...more bits
    }
} 
```

Enter fullscreen mode Exit fullscreen mode

当孩子从其父母那里被移除时，我们从我们自己的列表中移除它。看到 for 循环旁边的代码，应该更容易发现问题。如果同步调用这段代码会怎么样？移除`Nodes`列表中的第一个项目将到达回调并缩短列表。当我们回到`for`循环时，将不会有第二个项目，因此解释了为什么它只被调用一次。

> 在这里，我们是使用索引 for 循环还是 foreach 样式迭代器并不重要。他们都将失败，尽管可能以不同的方式。我们在代码库中使用索引循环，因为它们在一些目标平台上更有效(是的，这是应该优化的)。

这种情况突出了拥有同步回调或事件函数的危险。进行回调时，不确定副作用会如何影响堆栈中更后面的代码。为了安全起见，我们希望在调用堆栈的顶部附近进行回调和任何其他消息调度。一个异步回调用`Each`修复了我们的缺陷。

### 两次修复

在发布过程的后期改变消息顺序有点冒险。我们已经做了大部分的手工测试，所以我们可能不会再捕捉到细微的错误。相反，我做了一个替代的修复，改变了上面的依赖关系。原来我们甚至不需要跟踪`Each`中的删除，所以修复是删除大部分`CompletedRemove`代码。

我们仍然想要首选的异步回调，所以我也做了那个改变，但是只在开发版本上。在发布之前，它将接受更多的测试和使用。

## 但是为什么没人注意到呢？

这种缺陷是代码的几个正交方面相互作用的结果:

*   必须通过`Each`中的条目插入多个子条目(我们称之为单个模板是不够的:第一个条目总是被成功移除)。
*   列表中必须删除一些项目(如果我们只是添加项目，我们不会注意到这个问题)。
*   移除回调必须是同步的(当它是异步的时，这是常见的，缺陷不会发生)。

我们对所有这些情况都进行了测试。我们甚至有这些组合的测试。我们没有将这三者结合在一起的测试！使用多个模板更改项目列表的测试也涉及到一个可视化的`RemovingAnimation`，因此不会触发同步回调。调用同步回调的测试没有多个模板。

测试具有高度正交性的 API 有很大的困难。我们无法验证每个组合。编码的目标是尽可能的通用，这样组合不会改变太多的行为。然而，互动是不可避免的。在这种情况下，缺陷的发生是因为一个错误的，但是合理的，关于移除函数如何在 for 循环中工作的假设。

退步是我的错；我不是想推卸责任。我只是在努力找出如何防止这种类型的缺陷。