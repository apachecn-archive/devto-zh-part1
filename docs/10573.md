# p-图灵沥青坑的原始大脑和母亲

> 原文:[https://dev.to/buntine/p——图灵沥青坑的原始大脑和母亲](https://dev.to/buntine/p---the-original-brainfck-and-mother-of-the-turing-tarpits)

当我们想到深奥的编程语言时，我们大多数人很快就会被其中一种吸引:臭名昭著的 [Brainf*ck](https://en.wikipedia.org/wiki/Brainfuck) -一种超级简约的编程语言，仅用六条简单的指令就实现了[图灵完整性](https://en.wikipedia.org/wiki/Turing_completeness)(不包括两条 I/O 指令)。

1993 年，Urban MÃ ller 创建了可爱的 Brainf*ck，试图用 1024 字节以下的编译器构建一种可用的编程语言，尽管这种语言很勉强。为什么是 1024 字节？嗯，他受到了 Wouter van Oortmerssen 的 [FALSE](https://esolangs.org/wiki/FALSE) 的启发，这是一种基于堆栈的语言，编译器正好有 1024 个字节。所以我想你可以说这是一种竞争。

在本文中，纯粹为了取乐，我们会看到 **Brainf*ck 实际上是 50 多年前意大利发明的一种编程语言的非正式方言:Corrado bhm ' s P(读作“P Prime Prime”或“P Double-Prime)** 。

我希望读者对 Brainf*ck 有基本的了解——尽管，如果你从未听说过它，我强烈建议你看一看。哦，别担心；尽管名字很吓人，但是真的非常好学(注意，我没说“好用”！).

在深入了解 corra do bhm 这一绝对奇怪的发明的具体细节之前，我们先来谈谈他在计算机科学史上的地位。

## 科拉多·伯姆和结构化程序定理

如果你只对细节而不是动机感兴趣，你可以跳过这一部分。

当我们今天谈论“编程”时，我们几乎普遍指的是所谓的“[结构化编程](https://en.wikipedia.org/wiki/Structured_programming)”。也就是说，编写使用块结构、函数和循环的程序。很简单，是吧？事实上，这在今天看来是如此明显，以至于我们觉得没有必要如此具体地限定我们的意思——所以我们使用更一般的术语，如“命令式”和“声明式”来描述我们最喜欢的编程范例。整个“结构化”部分是某种给定的。

但并不总是这样...

许多最早的编程语言，包括像 BASIC、FORTRAN 和 COBOL 这样的重量级语言，都是[非结构化的](https://en.wikipedia.org/wiki/Non-structured_programming):语句是顺序排列的，通常每行一个。这些行被贴上标签或编号，这样程序就可以从程序的一部分执行*无条件跳转*到另一部分。

当我说“跳”的时候，我真的是说跳！与函数调用的情况不同，执行不会返回到调用上下文(当然，除非在另一次跳转中实际要求返回)。至少在理论上，人们可以直接跳到`SUBROUTINE`或`IF` <sup>2</sup> 的中间。跟踪程序的执行意味着跟踪所有的跳转。这种混乱的执行形式最终产生了一个我们今天仍然经常听到的短语(当然，从来没有关于我们自己的代码):“意大利面条代码” <sup>3</sup> ！

以防你还没想好。没错，我说的就是臭名昭著的`GO TO`。

60 年代早期，结构化与非结构化编程的争论占据了主导地位。1966 年，Corrado bhm 和 Giuseppe Jacopini 发表了一篇题为“只有两种形成规则的流程图、图灵机和语言”的划时代论文，这进一步点燃了这一热情。这篇论文 <sup>4</sup> 通过证明一个人只需要三个简单的控制结构就可以计算任何可计算的函数，为结构化编程(以及`GO TO`的废除)提供了[的理论基础:](https://en.wikipedia.org/wiki/Structured_program_theorem)

1.  执行一个子程序，然后执行另一个子程序(序列)
2.  根据布尔表达式的值执行两个子程序之一(选择/分支)
3.  执行子程序，直到布尔表达式为真(迭代)

为了用图灵机来证明这一点，他们当然使用了一种编程语言:**P**

## Pé，图灵沥青坑之母

p 是一个非常简单的。事实上，这太简单了，以至于整件事都有点令人困惑。有点像那些很差的电影，它们又回到了好的一面。该语言仅由四个字符组成:`R`、`Î»`、`(`和`)`，它们作用于一台[图灵机](https://en.wikipedia.org/wiki/Turing_machine)，该图灵机具有无限磁带(主存储器)和有限字母表(可以写入存储单元的一组东西——如数字`0..9`)。

伯姆将语法规则 <sup>5</sup> 定义如下:

1.  `Î», R âˆˆ Pâ€³`
2.  `qâ‚, qâ‚‚ âˆˆ Pâ€³`暗指`qâ‚qâ‚‚ âˆˆ Pâ€³`
3.  `q âˆˆ Pâ€³`暗指`(q) âˆˆ Pâ€³`
4.  只有可以从规则 1、2 和 3 中导出的表达式才属于 P。

没错。让我们在没有集合符号的情况下尝试一下:

1.  字符`Î»`和`R`是 P 中语法上有效的程序。
2.  可以编写程序。所以，如果`qâ‚`和`qâ‚‚`是 P 中的程序，那么它们的组成也是:`qâ‚qâ‚‚`。
3.  任何有效的程序都可以被迭代。所以，如果`q`是 P 中的一个程序，那么`(q)`也是。当我们谈到语义时，这将是有意义的。
4.  就是这样！

邦姆接着解释了语言语义，我在这里对其进行了总结和简化:

*   机器有一个长度为`N`的有限字母表，其中`N > 1`。`0`被认为是一个特殊的、空白的符号。所以每个存储单元可以包含从`0`到`N`的任何值。因为我们正在涉足图灵机的理论世界，我们可以说`N`的确切值正是手头的计算需要的值。
*   执行从最左边的符号开始，然后向右进行，直到没有什么需要计算的了。
*   `R`是将 tapehead(又名*数据指针*)向前移动到右边一个单元格(如果有)的操作。
*   `Î»`是将 tapehead 处的符号`c`替换为`(c+1) mod (N+1)`，然后将 tapehead 向左移动一个单元格的操作。注意模数运算——所以如果`N = 5`试图增加`5`将导致`0`(空白符号),因为`6 mod 6 = 0`。
*   `(q)`，其中`q`是任何有效的程序，被解释为一个 *while 循环*，它在当前单元格不包含空白符号(`0`时迭代。当然，无限循环是可能的。

因此，我们可以认为 P 是图灵机的近似字面的实现，就像我们可以看到原始的 Lisp 与 Church 的 Lambda 演算密切相关一样。前者对于实践中的程序员来说用处不大。

在 1964 年为罗马国际计算中心 <sup>6</sup> 发表的一篇论文中，伯姆证明了 P 是图灵完全的，这使得它成为第一种不包含`GO TO`指令而是依赖迭代的*结构化*编程语言。Djikstra 接着引用了 bhm 和 Jacopini，并在他现在著名的论文[中引用了被认为有害的陈述](http://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf)，这将有助于巩固他们在计算机科学民间传说中的地位。

这是一个简单的程序，用于将图灵机的两个数相加，其中`N = 3`和主存看起来像这样`[2, 1]` :

```
(
 Î»RÎ»RÎ»R    # Decrement current cell (remember that N+1 wraps back around to 0, so decrementing is equivalent to N increments).
 R         # Move tapehead right.
 Î»R        # Increment current cell.
 Î»RÎ»RÎ»RÎ»   # Move tapehead left by decrementing the current cell and then executing one final Î».
)          # Iterate if the current cell is not 0\. This means we iterate twice in this example. 
```

在执行结束时，主存看起来像这样:`[0, 3]`。

好吧，很酷，我想。也许你可以看到一些与 Brainf*ck 的细微相似之处，但我们肯定遗漏了一些东西。甚至用深奥的编程语言术语来说，都非常笨拙！

但是，对我们来说幸运的是，bhm 提供了几个小的抽象，允许我们编写更简单的程序。在这样做的时候，我们会看到 Brainf*ck 和 P 是等价的。

让我们来看看。

## 当两个变成一个

Brainf*ck 给了我们一些指示，我们不能用 P 来开箱即用。具体来说，我们仍然需要填补以下空白:

*   增加当前单元格(不移动磁头！).
*   递减当前单元格。
*   向左移动磁带头。

让我们定义如下:

*   **增量**
    *   `I = Î»R`
    *   增加当前单元格并向左移动，然后向右移动。
*   **减量**
    *   `D = I^N`
    *   这被定义为`N` `I`的连续。所以对于图灵机来说`N = 5`就是字面上的`IIIII`。看待`D`的最佳方式是将其扩展为`N` `I`的宏，而不是像函数一样的运行时构造。
*   **向左移动**
    *   `L = DÎ»`
    *   减少当前单元格，然后增加它(以恢复原始值)并向左移动。

概括地说，我们现在已经定义了以下指令:

*   **向右移动**:T0
*   **向左移动** : `L`
*   **增量** : `I`
*   **减量** : `D`
*   **开环** : `(`
*   **闭环** : `)`

现在开始有点眼熟了！所以，最后，让我们用新的抽象重新编写前面的程序:

```
(D R I L) 
```

同样的程序在 Brainf*ck 中是什么样子的？

```
[- > + <] 
```

有意思！尽管我们决定了稍微不同的语法，但这两个程序现在在语义上是相同的。

我可能会在这里花一点时间来提到，定义一种编程语言，其中的`DRILL`是一个有效的程序(虽然，我必须承认，hm 使用了不同的名称)，这是一件非常令人满足的事情。我想我会把我的方言叫做**【脑钻】**。

让我们试试另一个程序 <sup>7</sup> ，它将单元格`0`中的值向右移动两个位置(单元格`2` ):

```
R R ( D ) L L ( D R R I L L ) 
```

还有 Brainf*ck:

```
> > [ - ] < < [ - > > + < < ] 
```

我不知道你怎么想，但我被说服了。我恳求你继续尝试其他的 Brainf*ck 程序，但是，考虑到这两种计算模型现在是相同的，我的假设是它们在指令之间都是相同的。

最后一个提示——你会注意到我们已经跳过了大多数 Brainf*ck 方言中存在的 I/O 指令`,`和`.`。这是因为 P 的理论性质意味着像输入和输出这样的实际事物没有任何用处——我们只对指令对机器状态(存储单元)的影响感兴趣。但是如果你要构建一个 P 解释器——我鼓励你这么做——那么你可以像 Brainf*ck 一样实现 I/O。

## 感谢

如果你已经走了这么远-干得好！我相信你刚刚付出的精神能量最终会得到回报。想想看:下次你和提起 Brainf*ck 的人交谈时，你可以告诉他们所有关于 P 的奇迹和 corra do bhm 的天才。

一如既往，我们非常欢迎您的指正和反馈。:)

1.  BASIC、FORTRAN 和 COBOL 都在以后的版本中增加了对结构化编程的支持。
2.  我猜这将使协程实现起来稍微简单一些。
3.  没有人确切知道是谁创造了这个术语，但是根据维基百科，一个早期的用法来自盖伊·l·斯蒂尔 1977 年的论文:[通心粉比意大利面条好](http://dl.acm.org/citation.cfm?id=806933)
4.  众所周知，这篇论文被引用的次数比阅读的次数多。好吧，我承认，我*努力*熬过这一切。我真的做了。但是在你评判我之前- [自己试一试](http://www.cs.unibo.it/~martini/PP/bohm-jac.pdf)。
5.  如果巴克斯-诺尔形式在 64 年流行，它应该是这样的。
6.  我到处寻找这份报纸。国际商会在 60 年代末退役，他们的大部分出版物现在很难找到。我已经找到了大英图书馆的纸质版本，但还没拿到手。
7.  由 [esolangs](https://esolangs.org/wiki/brainfuck) 提供。
8.  封面图片来自 [corradobohm.it](http://www.corradobohm.it/) ，展示了第一届 Lambda 微积分会议(1979 年)的与会者。科拉多的白头发在第二排。