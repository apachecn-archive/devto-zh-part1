# 邪恶的会话令牌

> 原文：<https://dev.to/rmorschel/evil-session-tokens>

SIMPLES.COM，你已经创建了一个新的 web 应用程序。客户端可以登录到安全的站点，当然是通过 HTTPS，然后发布一个会话令牌。因为我们不希望客户端每次都必须登录，所以我们给令牌一个长的生存期，或者至少是一种使用它来获得新令牌的方法。

应用程序使用 cookies 将令牌保存在浏览器上。您确实考虑过使用浏览器本地存储，但是 cookies 似乎是保证广泛浏览器兼容性的最佳方式。

然后，应用程序使用 cookie 中的会话令牌验证每个 HTTP 请求，并根据需要授权对客户端的访问。

已排序。

黑客进入。

客户 Joe Bloggs 收到一封带有欺诈网站 S1MPLES.COM 的钓鱼链接的电子邮件(注意名称不同)，并点击了它。乔被带到一个页面，在那里一些偷偷摸摸的 GET 请求被发送到真正的 SIMPLES.COM 网站，乔的浏览器提供了会话 cookie，因为它是正确的域，黑客现在可能通过一些[跨站点脚本攻击](https://en.wikipedia.org/wiki/Cross-site_request_forgery)攻击向量控制了乔的帐户。(*编辑了之前关于完全访问的不正确陈述，不适用于此场景-参见下面的评论*)

我们如何解决这个问题？

首先要做的是不要使用*cookie*进行认证。web 应用程序必须将会话令牌*头*附加到每个请求上。这样，上述跨站点请求伪造攻击是不可能的。

但是，现在有了一个长期会话令牌，但这没关系，因为您使用了 HTTPS。

但你没有。不是所有的时间。

可以通过 HTTP 访问 SIMPLES.COM。只有登录页面和安全网站是通过 HTTPS。

乔是咖啡和免费 WiFi 的爱好者，他被邪恶先生用一个便宜的便携式 WiFi 路由器进行的中间人攻击所困。Evil 先生拦截请求，当然还有随每个请求一起发送的会话令牌。

邪恶先生现在可以长时间完全访问乔的账户。

答案是让 SIMPLES.COM 完全成为 HTTPS，并利用 [HSTS](https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security) 来确保不存在中间人的机会。并添加所有推荐的安全报头，例如[内容安全策略](https://en.wikipedia.org/wiki/Content_Security_Policy)。

酷毙了。邪恶先生耸了耸肩，决定找一个没有读过这篇文章的人。

很久以后，Bored Developer 先生正在浏览应用程序日志(通过日志聚合器可以很方便地获得)，这时他注意到所有人都可以看到会话令牌的日志记录。

没那么酷。开发人员也不能免受犯罪的诱惑，即使是在编写 Clojure 的时候。

那我们该怎么办？

一种方法是使用 OAuth 风格的方法来发布，不是一个会话令牌，而是两个:短期访问令牌和长期刷新令牌。刷新令牌存储在应用程序浏览器中，但从不用于访问，仅用于请求新的访问令牌。

当然，这些访问令牌仍有可能被泄露，但由于是短期的，将很快过期。

现在你知道了。