# 没有愚蠢的问题:只有一种编程语言？

> 原文:[https://dev . to/Jacoby/no-dumb-questions-just-one-programming-language-4gm](https://dev.to/jacoby/no-stupid-questions-just-one-programming-language-4gm)

我和妻子坐在客厅里，谈论着一些事情，她问我是否可以只有一种编程语言。

至少，这听起来是一个简单的问题，但事实证明这是一个复杂的问题，因为答案是“是，不是，是，不是，是”。

## 是

在任何给定的机器上，只有一种语言，即二进制表示，或称为**机器语言**。在计算机中，*一切*最终都是一系列的开关，代码告诉我们这个开关是开还是关。

## 否

事情是，人们很难用 1 和 0 来思考，所以有一种叫做 **assembly** 的表示，它接受语言能够完成的每一项任务，并将其转化为(更)人类可读的形式。

[这里是 x86 汇编中的`Hello, World`，来自 Github 上的 Overv。](https://gist.github.com/Overv/5714335)

```
 extern exit, printf

    section .data
    msg db "Hello World!", 10, 0

    section .text
    global main
main:
    push msg
    call printf

    mov dword [esp], 0
    call exit 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

*(注意:当第一次学习一门新的计算语言时，程序员倾向于编写一些标准程序。第一个是`hello world`，它教程序员如何处理字符串和输入/输出。第二个通常是`fibonacci`的两个实现之一，展示循环或递归是如何实现的。)*

如您所见，我们仍然处于机器领域，而不是问题领域，因此很难看到这一点并知道它正在做正确的事情。

因此，在这一点上，我们有两种语言来编写计算机程序:一种是人类不可能使用的，另一种是人类几乎不可能使用的。

## 是

上面的例子是为 Intel 的 x86 芯片组的汇编语言编写的。在 MacOS 和 Windows 和 Linux 之间，大部分桌面和服务器电脑都是用这个，但不是全部。还有 ARM，这是你的手机可能使用的，当很多这些决定被做出时，每个计算机制造商都有自己的架构和组装。这对制造商来说是件好事，因为这让他们可以说“我们的电脑有 X 功能，它值所有的钱！”但这是不好的(对程序员来说)，因为这意味着你的程序只能在为其编写的计算机上运行。

这就是艾伦·图灵的用武之地。还有阿隆佐·邱奇。

你可能认识艾伦·图灵，他发明了用暴力破解密码的炸弹，并创造了图灵测试，通过它我们可以判断一台计算机是否达到了感知能力。套用吉米·迪瑞斯塔的话，“如果看起来聪明，那就是聪明。”但我认为，图灵对计算最重要的贡献是

> “有人说...“如果一个函数的值可以通过一些纯机械过程找到，那么它就是有效可计算的。”我们可以从字面上理解这一点，通过一个纯粹的机械过程，一个可以由机器完成的过程。发展...导致...用有效的可计算性来识别可计算性。"

[漫长的维基百科可计算性之旅的开始](https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis)

因此，简而言之，如果我能自己做一个数学问题，我可以 1)通过 Lambda 演算(Church - more later)或 2)图灵机(Turing)机械地做。所以，我们可以创造一种语言，它可以在所有这些体系结构和汇编语言之间移植——从某种程度上来说，我们会说它是`C`——并且有一种语言可以在人们的头脑中工作，并且仍然(可以被编译)在你的计算机上工作。

所以，我们都可以只用 C 语言写就可以了。

## 否

我可以做这个`(NO,NO,NO,NO,NO)`，但是我想我会把它减到一个。注意，这里有很多手势。

丘奇-图灵命题并不是我们从丘奇那里得到的唯一不可思议的聪明的东西。我们也得到了 lambda 微积分。

当我们从 C 语言的角度考虑时，它最终采取了非常机械的形式，就像它编译成的汇编语言一样。

丘奇转而主张用数学和逻辑系统进行思考，他的[λ演算](https://en.wikipedia.org/wiki/Lambda_calculus)，用[约翰·麦卡锡的 LISP 语言](https://en.wikipedia.org/wiki/Lisp_(programming_language))实现，展示了**函数式编程**，其中 *functional* 并不意味着“它有效”，而是数学函数。在 C/汇编思维中，你跳转到例程或子例程的不同部分，但在函数思维中，你有一个函数`add()`，它接受两个或更多的值，并返回所有值的总和。

LISP 还有很多，我没有资格解释。

每一种表述都有力量，随后出现的语言从另一种语言中吸取概念，并根据自己的目的加以改造。(我认为 C 学派从 LISP 学派偷东西的次数比 LISP 学派从 C 学派偷东西的次数多，但我可能错了。)

此外，你必须有一个接口来调用你写的所有这些程序，如果你有一个程序在终端上打印很多数字，你现在想把它发送到打印机，这样你就可以离开屏幕考虑这些数字，你可以重写程序，让它打印到打印机，或者写一个方法把你的输出连接到打印机的输入。为此你需要一个界面，所以外壳，你与计算机交互的方式，成为一种语言。这被称为**外壳脚本**。在 Unix 系统上，这通常是 Bourne Shell，或`sh`，Bourne Again Shell，或`bash`，或`zsh`。(还有`csh`和`tcsh`，但是不推荐它们用于 shell 脚本。)

还记得我提到过过去有许多不同架构和机器语言的计算机制造商吗？我们可以使用丘奇-图灵理论来提出一个虚拟架构，并创建一种新的语言来编译它。这就是我们如何得到 **Java** 和 **Java 虚拟机(JVM)** 的，目的是允许一种应用程序语言跨所有不同的架构和操作系统工作。(“一次编写，随处运行”是口号。)Java 大多是 C 风格的语言(或者是 C++风格的语言；让我们来验证一下)，但是您也可以让其他语言在 JVM 上编译。例如，Clojure 是一种工作在 JVM 上的 LISP 方言。

作为这一切的潜流，有 [**摩尔定律**](https://en.wikipedia.org/wiki/Moore%27s_law) ，粗略地说，处理能力每 12-18 个月翻一番。戈登·摩尔是英特尔的联合创始人，我上面提到过英特尔的 x86 架构。它不是像欧姆定律那样的科学规则，而是被那个人的员工和整个行业视为行军命令的观察结果。编译 C 程序比 shell 程序运行得更快，所以你编写和编译程序是为了更快地完成任务。但是最终，计算机变得足够快，你能够用外壳语言写越来越复杂的东西，没有编译步骤。最终，你需要比 shell 更复杂的程序，所以我们得到了**动态编程语言**，比如 **Perl** 、 **Python** 、 **Ruby** 和 **PHP** 。

比起编译语言，你更想使用动态语言的原因有很多，但其中一个关键原因是*“计算机科学中的所有问题都可以通过另一个间接层次来解决”*，动态语言有足够的间接性，你可以更多地考虑问题，而不是机器。例如，如果你想写一个关于你去杂货店的程序，你最好能够以`walk_to_entryway();`开始，而不是在一个循环中以`lean(left); lift_leg(right); move_leg(right,forward);lean(forward);`开始。这两种情况都会发生，但如果你能把注意力放在找到牛奶、鸡蛋和面粉的水平上，然后去结账，而不是你的肌肉在做什么，那么写出这个过程就更容易了。

## 是

杰夫·阿特伍德提出了介于摩尔定律和墨菲定律之间的阿特伍德定律:

> *任何可以用 JavaScript 编写的应用程序，最终都会用 JavaScript 编写*

起初，这是因为“将其放在 web 服务器上”成为了 Java 的“编写一次，在任何地方运行”的替代版本， **JavaScript** 是在每个 web 浏览器上运行的语言，但自从 **Node.js** 的发明，你可以编写在服务器上运行的 JavaScript。

有了 [Johnny-Five](http://johnny-five.io/) ，你可以编写运行在嵌入式系统上的 JavaScript。

没有真正的理由为什么你不能把 JavaScript 编译成 JVM 或机器码，只要稍微搜索一下，我可能会在 GitHub 上找到这样做的项目。

此外，JavaScript 是用大量 LISP 语言开发的，所以你可以用它编写 C 风格和 LISP 风格的程序，或者随意混合使用。

## 总之

最终，只要有不同的架构参与计算，就会有多种语言，有时这些不同的架构是有充分理由的。那些架构和机器语言可能只由试图让高级语言编译成不同架构的人来处理，但是它们仍然会存在。

基于程序员的需求和愿望，将会有各种各样的高级语言。对于开发人员工作空间中的每一个给定的 A，都有一个开发人员强烈地相信非 A，对于每一种语言、框架或架构，都有一个组织或行业强烈地投资于它，因此它可能永远不会完全消失。(我确定有一家公司的主打产品是`brainf***`内置的，我很同情他们的维护开发者。)

与扩展计算机语言的空想性质背道而驰的力量包括已经解决的问题的力量。如果你的任务涉及到某个问题，而这个问题是用这种语言解决的，那么使用这种语言可能比用你目前使用的语言重新解决它更容易。

所以，最终，由于许多原因，不，永远不会有一种编程语言。

*[原发表于我的 GithubPages](https://jacoby.github.io/nostupidquestions/2017/11/06/no-stupid-questions-just-one-programming-language.html)*