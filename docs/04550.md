# 你以为你是谁？

> 原文:[https://dev.to/dwd/who-do-you-think-you-are-ad5](https://dev.to/dwd/who-do-you-think-you-are-ad5)

政府有很大的部门来证明你是谁。大多数国家都有国民身份证，几乎所有的国家都有护照办公室。

我们没有任何令人兴奋的东西。只是一个数据库，里面有些东西。那么，我们如何证明用户就是他们所声称的那个人呢？

# [](#factors)因素

基本上，我们有三种方法可以证明身份。

*   一些你知道的事。
*   你有的东西。
*   你就是这样。

理想情况下，我们希望使用一个以上的身份验证，即所谓的“多因素身份验证”(MFA)，通常是“双因素身份验证”(2FA)。

让我们逐一看一下:

# [](#something-you-are)你是什么东西

生物识别包括检查一些(希望是唯一的)物理属性，并以此为基础做出决定。这在某些情况下非常有用——大多数情况下，身份验证点离用户很近。举个例子，生物识别电子护照门工作得很好，笔记本电脑登录屏幕的指纹扫描仪也是如此。

当存在物理距离时，并且一般来说，当收集生物特征的硬件——指纹扫描仪或其他什么——不属于进行身份验证的实体时，事情就变得更棘手了。毕竟，如果我只需要发送正确的数据，我可以从你的手指上收集一次，然后每次都重放一次。

类似地，还有一个问题是你的手指是否还连着你的手的其他部分——但是我们不要纠结于此...

可以说，生物识别技术非常好，但几乎在所有情况下，它们都不适合我们。

# [](#something-you-have)你拥有的东西

智能卡和其他硬件令牌是您可以随身携带的物品，可用于识别您的身份。你可能熟悉的硬件令牌的例子包括银行卡和 Google Authenticator。

例如，我的银行卡包含一个我无法提取的加密私钥，可以通过 NFC(用于非接触式支付)或物理连接(用于“芯片和密码”)签署质询。它还有一个磁条(基本上是针对美国的),没有那么聪明。

智能卡中的私钥是不可复制的——任何物理提取它的尝试都会导致智能卡被销毁。很明显，有人可以窃取它-但我可能会很快注意到，至少对于芯片和密码，他们需要知道密码。

我的 SSH 密钥也在智能卡上——我也需要输入 PIN 才能使用它。

其他设备有一个小屏幕，屏幕上的数字经常变化。这些数字是由隐藏在设备内部的秘密密钥以同样不可提取的方式生成的，服务器知道如何验证生成的数字来自设备。

您还可以将客户端 PKI 证书视为某种您拥有的东西，即使它们只是磁盘上的一个文件。当然，它们可以被复制，但也可以被加密。

Google Authenticator 的工作方式并不完全相同——提取底层技术 TOTP 使用的共享秘密并将其复制到多个设备上几乎是微不足道的。同样的秘密也必须存储在服务器上，所以也存在攻击者从那里获取的风险——事实证明 Google Authenticator 根本不能抵御入侵。但总比什么都没有强。

# [](#something-you-know)你知道的事情

密码可能是最常见的身份验证方法。他们也被认为是最弱的。使用密码的人会选择糟糕的密码，而执行密码检查的人会以令人震惊的方式来做。

与其看如何安全地选择和处理密码(简而言之:只需使用密码管理器)，不如看如何检查密码。

# [](#simple-authentication)简单认证

OSI 目录认证的古老规范 X.509 涵盖了 PKI 和它所谓的“简单认证”。在这种情况下，用户有一个用户名，并知道一个密码。他们将密码发送给目录服务代理(即服务器)。它将其与自己的记录(用户目录服务条目中的一个属性)进行比较。如果匹配，我们就完成了。万岁。

只不过这已经是最弱的了。我们来考虑一下。

# [](#credential-storage)凭证存储

首先，如果这里的服务器被攻击者攻破，攻击者可以获取所有用户的所有密码。这显然是可怕的，我们不允许这样。因此，正确的解决方案是使用基于哈希的加密函数，允许我们证明密码是正确的，而无需实际存储它。

如果您遇到困难，这里有一个很好的例子是 PBKDF-2，它是大量重复的散列，可以基于任何散列函数。使用 SHA-256，除非你知道一些我不知道的东西——你可能知道。

# [](#the-wire)电线

但是，如果攻击者能够获得对您的服务器的稍微长一点的访问权限，他们就可以无所事事，用户会将密码发送给他们。虽然原则上以这种方式进行的入侵更容易被发现，但在实践中，人们似乎不会注意到巨大的数据库被导出，所以这很可能是一厢情愿的想法。

理想情况下，即使使用了 TLS，我们也要假设攻击者可能会看到身份验证交换。因此，解决方案不是发送密码本身，而是使用挑战-响应系统来证明知识。

麻烦的是，为了验证这些方案中的大多数，服务器需要再次知道密码本身(或者一个“明文等价物”——即，它必须有足够的信息来进行自身认证)。这是一件坏事——攻击者可以尝试其他服务上的密码，或者简单地使用它们来获得对他们刚刚入侵的系统的明显合法的访问。这可不好。

IETF 可以在这方面帮到你——SCRAM 是一系列围绕 PBKDF-2、HMAC 等常见构件设计的机制。它有一个有用的特性，就是很难从网络上获取密码，也很难从数据库中获取密码。在这两种情况下，攻击者都可以在宇宙热寂之前强行破解密码，但这对于绝大多数情况来说已经足够了。

对于真正严重的情况，有 SRP。安全远程密码使用加密技术将简单密码转换成非对称密钥对。服务器只有公钥，用户只需知道密码，所以这是令人印象深刻的东西。

# [](#time-of-check-time-of-use)检查时间，使用时间

无论您如何进行身份验证，您都希望确保在做出基于身份验证的决策时，您可以安全地将其与身份验证联系起来。

如果身份验证可以发生在通道上(如 TCP 会话，或一系列 HTTP 请求)，然后通道可以被切换(会话劫持等)，那么就有 TOCTOU 问题。这是一件坏事。

几乎可以肯定的是，解决方案是 TLS 和通道标识符的某种组合——对于严重的安全性，看看通道绑定。出于 Surevine 的目的，我们尽可能在单个 TLS 安全的 WebSocket 上运行认证操作(使用 XMPP、事实发现程序),但是确保您的会话 cookies 是安全的、仅 HTTPS 的等等是另一种方法。

# [](#putting-it-all-together)把所有的东西放在一起

您需要做什么取决于您的威胁模型，一如既往。

但是，我认为现代应用程序至少需要具备:

*   没有存储等同的明文。
*   网络上没有对应的明文。
*   所有网络流量的 TLS。
*   不要剃头。
*   可选的谷歌认证/ TOTP。

一个简单的应用程序将在 TLS 上使用一个基于 SCRAM 的解决方案，带有一个安全的会话 cookie，并有希望做 TOTP。

# [](#authenticated)通过认证

身份验证是任何应用程序的基本组成部分之一。很难做对，如果事情出错，不仅对你不好，对你的用户也很糟糕。

目前的技术水平是一个不断变化的目标，但是每个部分都有现成的、成熟的解决方案。构建良好的身份验证可以为用户和您的应用程序提供强大的保护，即使在发生违规的情况下，也不会影响您的用户体验。