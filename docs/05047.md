# 配置日志级别和可观察性

> 原文:[https://dev.to/stevemushero/configuring-for-log-levels-可观测性](https://dev.to/stevemushero/configuring-for-log-levels--observability)

在过去，我们用控制台输出、日志和天知道我们在石器时代还有哪些糟糕的工具进行调试。但经历了这些，我们学到了一些好的教训，也有了一些好的想法。

作为一名开发人员、调试人员和运营人员，我最关心的一件事就是日志。大多数程序把事情记录在某个地方，通常是一个单独的日志，通常是一个单独的日志级别，也就是说，你得到的日志就是你将要得到的全部；可能太多也可能太少。

借助今天的日志和可观测性工具，如 Honeycomb.io、ELK、Sumo 等。当然，您可以处理、搜索和标记更多内容，但这不是无限的，特别是对于调试级别和跨网络——您不能简单地将所有调试日志按比例发送给 Sumo Logic。你需要更多的粒度，以及容易改变它的方法。

人们改进的第一步是增加日志级别，遵循通常的信息、警告、错误、调试等层次结构。这很有帮助，如果您能在该死的系统运行时对其进行更改就更有帮助了(这对于更大、更关键的任务非常重要)。将它存储在您的 R`edis 缓存中，让管理员在运行时进行更改

下一步是使用 log4j 及其跨各种语言的克隆工具添加更复杂的过滤器和配置。这很有帮助，尽管通常涉及复杂的配置文件并需要重新启动，此外还需要提前考虑在哪里记录什么，在什么子系统中记录什么，log4j 配置了什么，等等。现在用 logstash 和外部发送器修复了一些问题，但对我来说仍然很混乱。

我总是对通过标志和日志级别的动态每模块日志记录更感兴趣，因为我想要我想要的日志，当我想要它们的时候，而不是更多。

例如，通常我对单个模块或问题最感兴趣，所以我真正想要的是对大多数东西进行错误调试，但对我的代码进行调试。

这可以通过多种方式实现，但我们通常会使用一个更复杂的配置行来重用现有的单个日志级别指令，如下所示:

DEF=1:SECURE=2:NET=2:RULES=5

这意味着默认为低级别 1，安全和网络为 2，我的规则模块为 5。很简单；易于解析等。你甚至可以使用 sub-sub 系统，更具体地说，比如“规则/评估者=5”。

在你的代码中，不需要 If-then/宏逻辑(就像使用 log4j 等。)，所以您只需将所有内容发送到日志记录器，标记其日志级别和模块名称(通过自省或其他特定于语言的魔法)。

然后在日志记录器中，检查模块和日志级别标记，并发出配置所需的内容。您可以根据通道使用不同的配置来增加趣味性，例如，将什么发送到标准输出、系统日志或数据库等。

就是这样。糟糕的是，在我多年来运行的数百个工具和系统中，我几乎从来没有看到过这一点，包括一长串我希望将这一点包括在内的当前工具和系统。