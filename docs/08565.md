# 不要留下破碎的窗户

> 原文：<https://dev.to/raulavila/dont-leave-broken-windows>

“不要留下破碎的窗户”。我第一次读到这个短语是在开创性的书《实用程序员》中，那可能是我职业生涯中最重要的顿悟时刻。你知道这意味着什么吗？

是(科学上？)证明了当一座建筑被废弃时，它可以抵抗很长一段时间而不被人们注意到。但是有那么一个时刻，一个至关重要的事件发生了…这改变了一切。这个事件是一扇破窗。打破的窗户不会被修理，因为大楼没有人维护，所以在短时间内每个人都会知道这种情况，破坏者会开始破坏新窗户，闯入大楼，很快就会完全混乱。

同样的想法也可以应用到软件开发中。当我们走捷径在最短的时间内交付一些东西时，我们的代码反映了我们是多么的粗心，开发人员在我们之后(来自同一个团队，一个未来的团队，甚至我们自己！)，会得出一个重要的结论:对我们产生的代码给予足够的重视并不重要。渐渐地，我们的应用程序将开始恶化，这将成为一个不可阻挡的过程。

## 破窗的等级

并非所有事情都是非黑即白的，虽然有些问题必须立即解决，但有些问题可以稍后再考虑。顺着大楼的比喻，摩天大楼的第一层和第二十层有一扇破窗是不一样的。这就是为什么我认为破窗分为两个层次:

*   让世界停下来:你绝对没有理由去解决这个问题。不这样做迟早会有严重的后果。
*   下一次迭代:假设我们遵循敏捷方法工作，这个问题应该在我们开始下一次迭代/冲刺时就解决。为了记住它，我们需要将它作为一个行动添加到我们用来跟踪工作的工具中(特雷罗、Pivotal Tracker、track)。

## 例子

我将回顾我在过去几年作为开发人员工作中所看到的一系列问题，这些问题可以明确地归类为破碎的窗口。

### 自述文件

在我们的代码库中有一个 README 文件是必要的。有时人们会提到[敏捷宣言](http://agilemanifesto.org/)，它说我们应该偏爱“工作软件而不是全面的文档”，他们把它翻译成“我们不需要文档”。

这太残忍了。请从第一天开始，编写并维护一个包含基本信息的自述文件，例如:

*   对我们的应用程序的简要描述(两行或三行，它在做什么，它解决了什么问题)。
*   如何构建项目。
*   如何以及何时部署项目。
*   如何自动测试代码(如果有必要的话——我希望不是——手动测试)。
*   我们的系统有哪些依赖关系(数据库、消息代理等)，以及如何连接到它们。
*   版本控制策略。
*   要遵循的约定(提交消息格式、编码风格指南等)。

我可能漏掉了一些东西。这个想法是，如果有人加入我们的项目，没有来自其他开发人员的大量支持，就不能快速提升(当然，总是需要最低限度的支持！)，这是因为我们的自述文件中缺少了一些东西。

### 文档太多(而且过期)

这是前一个例子的反义词。在项目的第一阶段，我们可能会在 Wiki、Word 文档等中编写大量的文档，包括需求、设计等，随着工作量的增加，我们不再维护这些文档，这些文档将在混乱的来源中自动转换。

总的来说，我认为拥有一个包含我们系统架构的高级概述的文档是很重要的，但是实现细节必须在一个地方:代码。每当你开始写一个你知道会花一些时间的新文档时，想想你增加的价值和你获得的“时间债务”。“时间债务”只不过是一个具体的行动，需要我们在未来投入更多的时间。你可以在这里阅读更多关于这个[的内容。](http://jamesclear.com/time-assets)

### 死代码

这是保留在我们代码库中的代码，但是没有人调用它，因此它是无用的。许多人决定留下这些代码，“以防我将来需要它们”。我过去经常这样做，事实是我从未见过自己恢复这段代码。此外，还有一种叫做源代码控制的东西:)，它极大地方便了恢复前一段时间实现的代码的工作。

使用当前的工具，检测死代码非常简单，删除它也非常简单。所以不要找借口。

### 注释掉代码

作为“死代码”的一个子集，这甚至更加反常。请不要在你的软件中留下注释掉的代码。

### 忽略的测试

这些测试有一天失败了，为了继续做我们正在做的事情而不破坏我们的 CI 环境，我们添加了一个漂亮的`@Ignore`而没有明确说明原因。将来，当有人看到`@Ignore`时，他可能会删除它，并且在看到测试失败后，会再次添加注释。所以它永远留在那里。

我只看到一种情况下这是合理的，那就是当我们在开发一个新特性的时候，我们想要“进行中”地推送代码。这些代码不会向最终用户公开，但会集成到 master 中，并且新功能在测试通过之前不会被激活。其他任何情况都只是一扇破窗。

### 几个依赖者做同一件事

一名开发人员决定添加一个库来完成某项任务，比如说使用 JSON，她选择了 [Jackson](https://github.com/FasterXML/jackson) 。

后来，另一个需要使用 JSON 的开发人员决定添加 [GSON](https://github.com/google/gson) 。所以我们有两个库来做同样的事情！

这传递了一个明确的信息，团队内部缺乏沟通。为了避免这种问题，进行代码审查是非常重要的。如果为时已晚，而且两个库都生活在同一个项目中，为了一致性，我们应该尽快选择一个并替换另一个。

### 代码格式不一致

谁没见过这样的代码？

```
public class DishImpl implements Dish {

    private final String name;
    private boolean mixed = false;
    private boolean cooked = false;
    private final List<Ingredient> ingredientList = Lists.newArrayList();

    public DishImpl(String name)
    {
        this.name = name;
    }

    public void add_ingredient(Ingredient ingredient)
    {
      Validate.notNull(ingredient);

      System.out.printf("%s - Adding ingredient %s%n",
                        name,
                        ingredient.getName());
      ingredientList.add(ingredient);
    }

    public void mix()
    {
        if(ingredientList.isEmpty())
        {
            throw new IllegalStateException(
                "There are no ingredients to mix");
        }

        System.out.printf("%s - Mixing ingredients: %s%n",
                            name,
                            ingredientList.toString());

        mixed = true;
    }

    public void cook() {
        if(!mixed)
            throw new IllegalStateException(
                "Ingredients are not mixed, please call mix first");

        System.out.printf("%s - Cooking...%n",
                            name);

        cooked = true;
    }

    public void serve()
    {
      if(!cooked)
        throw new IllegalStateException(
            "Dish is not cooked");

      System.out.printf("%s - Serving...%n", name);

    }
} 
```

(我知道，代码挺蠢的)

我们在这段代码中看到了一些不一致的地方，比如使用花括号的两种不同方式(有些地方是新行，有些地方是同一行)，缩进代码的两种不同方式，用一条指令组织 if 语句的两种不同方法(使用花括号与不使用花括号)，不同的命名约定(camel case 与 snake case)，等等。

所有开发人员都同意遵循风格指南，并尊重它，这是非常重要的。我对此的看法是，你永远不应该根据代码的风格知道是谁写了一段特定的代码。

在网上很容易找到好的时尚指南，例如谷歌的。

### 测试覆盖率不足

如果你实践 TDD，这应该不是一个大问题，但是如果你不这样做，我们的测试可能只覆盖 60-70%的产品代码(甚至更少！！).

在我们的用户故事的接受标准中，应该清楚的是，如果测试覆盖率降低，故事将不会被交付。这个测试覆盖率不应该低于阈值 90-95%。如果发生这种情况，我们应该分析原因(可能是压力太大，或者只是草率？).

在任何情况下，测试覆盖率本身不应该是一个目标，而是一个质量的衡量标准，所以请注意这一点！

### —部署中的手动操作

我们项目的新版本的部署应该是 100%自动化的。理想情况下，我们应该在 CI 环境中有一个任务，它执行所有必要的操作，并且只需要我们按下按钮。任何额外的行动只是浪费时间，应该进行自动化分析。

### 不稳定 CI

当我们的 CI 环境处于“阅读”状态的时间比处于“绿色”状态的时间长时，那是因为我们在做错事。我的意思是，我们的任务(在[詹金斯](https://jenkins.io/)、[竹](https://es.atlassian.com/software/bamboo)、[广场](https://concourse.ci/)等)95%的情况下都应该成功执行。如果这没有发生，我们必须停止我们正在做的任何事情，让它再次变绿。

### —未使用的导入

这是非常典型且容易避免的。我们将一个`import`语句添加到我们的类文件中，因为我们在某个时间点需要它。稍后，我们删除与该导入相关的代码(例如，因为我们重构了代码并将其移动到其他地方)，留下`import`，它现在完全没有用了。看到 25 种进口产品中只有 5 或 6 种被实际使用的情况并不罕见。

在当前的 ide 中，删除未使用的导入非常简单。有快捷方式可以立即做到这一点，甚至有[选项来激活一些选项，永久扫描](http://stackoverflow.com/questions/19026756/how-configure-optimize-imports-on-the-fly-without-rearrange-import-statements)我们的代码，并为我们删除未使用的导入。

### 未使用的依赖项

虽然前面的例子可能被归入第二类(“下一次迭代”)，但是在我们的代码中拥有不再被使用的未使用的依赖关系，为潜在的问题打开了方便之门，由于与传递性依赖关系的冲突等，这些问题可能难以察觉。

一旦你停止使用一个依赖项，就把它从你的项目中移除！

### 不明 Git 策略

如果没有如何使用 Git 的明确指导方针，每个开发人员都可以自己做决定，我们可能会发现自己的 Git 存储库充满了分支(许多分支在被合并或重新归入 master 后就消失了)，大量的合并，等等。

我不打算在这里提出一个使用 Git 的理想解决方案。有几种策略(也称为工作流)，但是在任何情况下，你都应该把决定权留给团队中的每个人。

### 脏代码

我们都知道什么是脏代码，作为专业人员，我们永远不应该交付以不可持续的方式实现的功能，因为不可读的代码会使维护变得非常困难。如果你还没有这样做，请阅读[干净代码](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=sr_1_1)或[代码完成](https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=sr_1_1)以确切知道我在说什么。

## 这不是技术债

在这篇文章中，我没有谈到技术债务，这是一个完全不同的事情。我说的是做专业人士，照顾好我们的工作！所以请你每次坐在屏幕前都不要忘记这句口头禅:“不要留下破碎的窗户”。