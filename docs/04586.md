# 删除代码的艺术

> 原文:[https://dev.to/mariosangiorgio/the-art-of-deleting-code-181](https://dev.to/mariosangiorgio/the-art-of-deleting-code-181)

如果你问开发人员他们最有效率的日子是什么样的，你肯定会多次提到他们为项目贡献负代码行的神话般的日子。

人们喜欢庆祝这些日子，他们这样做有很好的理由:他们可能消除了一些错误，使代码更简单，清理了一些技术债务。作为一个副作用，他们的项目编译和运行速度现在更快了。

在我工作的地方，我们有一个巨大的庞然大物，它有机地进化并积累了大量的残渣。去年，我们甚至花了一些时间减少我们的技术债务。我花了那段时间几乎完全摆脱了大量的代码，从那以后，我的同事们在删除一些旧代码时会用*Wario*这个词。

### 我怎么知道要删除什么？

删除代码很容易，知道删除什么肯定更有挑战性。我最不愿意做的事情就是恢复我移除的某个东西，因为事实证明某个东西实际上仍然依赖于它。我们需要一些好的方法来确定哪些代码是死的，并且有很高的可信度。

对代码库的深入了解是至关重要的，这将使你获得最佳结果，但也有一些工具非常有用，可以告诉你应用程序的哪些部分不再有用。

### 了解你的代码库和应用

首先了解一些代码是何时以及为什么被编写的是非常宝贵的，并且可以给出关于你是否仍然需要它的最佳见解。

例如，考虑读取不同版本文件格式或旧版本 HTTP API 的代码。在这两种情况下，您不能仅仅通过查看来保证这些代码没有任何用处。但是您可能知道所有您关心的文件都被转移到了新的格式，或者所有的客户端都在使用 API 的新版本。恭喜你，你已经确定了一个很好的候选人。

在遗留代码库中，你可能有许多不同的方法来做某事。统一您的应用程序以总是使用最新的方法可能是一个好主意。这将使您能够访问所有最新的功能，还允许您淘汰与旧方法相关的代码。不幸的是，通常知道如何移植新的方法并不简单，否则其他人已经做了。如果是这样的话，您需要理解这两种方法的区别，仍然依赖旧代码的用例真正需要什么，以及如何使用新代码复制功能。这通常是可能的，但是需要大量的理解和努力。

### 静态分析

在工作中，我们主要使用 C#，所以我们可以利用静态分析，就像编译器本身执行的分析一样，通过 [ReSharper](https://www.jetbrains.com/help/resharper/Find_dead_code.html) 和 [ndepend](https://www.ndepend.com/Default-Rules/webframe.html?Q_Potentially_dead_Methods.html) 识别死代码。清理它是一个好的开始，但它不会让我们走得太远:可以删除的大部分未使用的代码是技术上可达到的代码。

例如，我在前面的例子中提到的所有代码都不会被静态分析工具标记。据他们所知，我可能仍然有一个旧文件，所以他们必须产生保守的结果。他们假设，如果有一个代码路径导致一行代码的执行，它最终将被到达。

这是一个完全有效的方法:如果这些工具会给我不合理的结果，我会非常担心。

尽管如此，当我发现我可以消除什么特性后，我想轻松地摆脱所有相关的代码时，静态分析是非常有用和非常有效的。但是在我们需要使用其他方法找到该特性的入口点之前。一旦这个被删除了，其余的都会随之而来。

### 动态分析

如果我们仅仅通过分析不能知道什么代码实际上被使用了，那么我们是否可以获得更多的信息，如果我们可以监测它实际上是如何被使用的？

答案是肯定的，有几种方法可以让你获得非常好的结果，但是你需要小心假阳性。动态分析并不是详尽的，所以您需要确保在您可以将一段代码声明为死代码之前已经等待了足够长的时间。

在数据库中记录传递给应用程序的所有命令行参数将让您知道实际使用的是什么。如果没有人使用命令行开关，那么支持它的功能就没有意义。

如果你怀疑某个东西已经死了，你可以使用 [tombstoning](https://github.com/scheb/tombstone/blob/master/README.md) 方法，这是一种更具侵入性的方法，但它肯定会给你更详细的重要信息。

一旦你收集了一段时间的数据，你就会知道什么是肯定被使用的，什么是可能没有被使用的，什么是最后一次被使用的。这是宝贵的情报，它将非常有助于确定您接下来应该尝试删除的内容。

### 结论

删除代码并不总是简单明了的，但是如果对你正在开发的应用程序有很好的了解，并且在一些工具的帮助下，是有可能达到很好的效果的。

如果你已经读过了，我想向你推荐格雷格·杨的《摧毁软件的艺术》。它不会教你如何删除代码，但它会给你一些想法，告诉你如何*优化可删除性*你将编写的新代码，以便一旦你不再需要它，删除它会尽可能容易。