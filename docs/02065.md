# 在电梯里解释关闭，没有说“关闭”

> 原文:[https://dev . to/code prototype/closure-explained-in-a-elevator-without-state-the-words-close-over-bco](https://dev.to/codeprototype/closure-explained-in-an-elevator-without-saying-the-words-close-over-bco)

关于**关闭**的讨论文章很多，这里就不一一列举了。他们最终都会在解释中加入各种语言的长代码示例，这很好。许多文章选择用**关闭**这个词来描述**关闭**，而[并不意味着全部](https://stackoverflow.com/questions/30700027/what-does-it-mean-to-close-over-something)，至少对我来说是这样。

我试图在这里解释关于**闭包**的内容，但没有显示任何代码，因此是“在电梯里”。

闭包就是定义在另一个函数内部的一个函数。这个内部函数自然可以访问外部函数中定义的变量和常量。这个内部函数甚至可以修改这些变量的值(当然，内部函数不能修改任何常量，不管这个常量是在哪里定义的)。不仅如此，这个内部函数还可以访问传递给外部函数的参数。所有这些事实既不令人惊讶也不有趣。但仅此而已。这就是**闭包**的定义。很容易想象。很好理解。闭包是一个内部函数，它自然可以访问外部函数的变量、常量和参数。

如果外部函数没有返回内部函数，那么一旦外部函数返回或退出，外部函数和内部函数中定义的所有变量都将不复存在。以这种方式使用，内部函数的**闭包**只不过是一个小工具，一个更大的外部函数的辅助函数。

使**闭包**有趣的是当这个内部函数被它的外部函数返回时。外部函数的调用者将把这个返回的内部函数保存在一个变量中，这个变量以后可以被调用。发生这种情况时，即使在外部函数返回后，外部函数的变量、常数和参数仍将继续存在。这个事实导致了许多用法和模式，这使得**闭包**成为一个强大的概念。

这是一个没有代码的 2 分钟解释。现在我们可以出电梯了。