# 使用按位 AND 测试奇数/偶数

> 原文:[https://dev . to/geek cycler/testing-odd-even-using-bitwise-and-ak9](https://dev.to/geekcyclist/testing-odd-even-using-bitwise-and-ak9)

我是通过 Apple II、TI 99/4A、BASIC、VB/VBA 以及 C#进入编程世界的。但我的学术经历是在经济学领域，而不是计算机科学领域。所以偶尔我会碰到一些非常基础的东西(我想是这样的),这些东西我显然已经忘记了，介于苹果基础、高中电子产品和随后几十年塞满我大脑的其他琐事之间。

按位运算符`AND`是今天让我感到愚蠢的运算符。

在我的职业生涯中，我多次遇到测试一个数字是奇数还是偶数的代码。通常我做过或见过模除以 2 和余数的比较。

```
public static bool IsOdd(int i)
{
    return ((i % 2) == 1);
} 
```

今天我碰到:

```
public static bool IsOdd(int i)
{
    return ((i & 1) == 1);
} 
```

我不知道为什么会这样。我看了看 ms help:

> 二元&运算符是为整型和布尔型预定义的。对于整型，&计算其操作数的位与。对于 bool 操作数，&计算其操作数的逻辑与；也就是说，当且仅当两个操作数都为真时，结果才为真。

没有做一些数学计算，不是特别有启发性，所以我挖得更深一点。回顾二进制计数我在一张 3x5 的卡片上制作了一个表格，为了简单起见，假设一个 4 位的数字:

| 小数 | Zero | one | Two | three | four | five | six | seven | eight |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 二进制的 | `0000` | `0001` | `0010` | `0011` | `0100` | `0101` | `0110` | `0111` | `1000` |

然后我开始思考这个运算，但我最初在脑子里把它当作二进制加法，而不是正确的位运算:

| 3 + 1 |  |
| --- | --- |
|  | `0011` |
| + | `0001` |
| = | `0100` |

但这显然是不对的，因为结果是 4，对于任何大于 0 的正整数，如果加法是基本操作，测试就会失败。我又查了几个按位 AND 的定义，终于明白了:

> 逐位 AND 运算`(a & b)`在 a 和 b 的对应位都为正的每个位位置返回 1。

结果是对每一位进行逻辑测试:

| 3 & 1 |  |  |  |  |
| --- | --- | --- | --- | --- |
|  | `0` | `1` | `0` | `1` |
|  | `&0` | `&0` | `&0` | `&1` |
| = | `0` | `0` | `0` | `1` |

由于十进制 1 的二进制表示是 0001(前面根据需要填充了尽可能多的零，以匹配数字的位大小)，所以运算([任意整数] & 1)返回 1 的唯一方式是最右边的位是 1，即全是奇数。

下表描述了我现在正在使用的 C#中的位运算符。

| 操作员 | 使用 | 描述 |
| --- | --- | --- |
| 按位 AND | `a & b` | 在 a 和 b 的对应位都为 1 的每个位位置返回 1。 |
| 按位或 | `a &#124; b` | 在 a 或 b 或 a 和 b 的对应位都为 1 的每个位位置返回 1。 |
| 按位异或 | `a ^ b` | 在 a 或 b 的对应位(但不是 a 和 b 都是 1)的每个位位置返回 1。 |
| 按位非 | `!a` | 反转的每一位。 |

更多关于二进制是如何工作的，请看[swansontec.com/binary.html](http://www.swansontec.com/binary.html)。

顺便说一句，我从来没有真正想过零是偶数还是奇数。原来零是偶数，这就是为什么[wikipedia.org/wiki/Parity_of_zero](http://en.wikipedia.org/wiki/Parity_of_zero)。