# 实现继承是邪恶的

> 原文:[https://dev . to/wrong about everything/implementation-inheritance-is-evil-3bb](https://dev.to/wrongabouteverything/implementation-inheritance-is-evil-3bb)

* * *

关于为什么遗传不好已经说了很多。我将分享我对这个主题的看法，并说明大多数时候并不真的需要继承。

# 结构继承

## 它打破封装

从早期的 [Simula](https://en.wikipedia.org/wiki/Simula) 和 [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk) 开始，为了属性重用而继承并不是面向对象编程中的继承方式。这种继承方式打破了人类的隐喻。没有人应该接触到我的内部:胃，大脑，或者肺。它打破了对象的封装，这是它的基本特征。它打破了 OOP。

## 它是[脆弱的](https://en.wikipedia.org/wiki/Fragile_base_class)

行为和内部结构是正交的概念。它们独立变化。如果某个对象今天扩展了另一个对象的内部结构，并不意味着明天事情会保持不变。

## 是[程序上的](http://www.yegor256.com/2016/09/13/inheritance-is-procedural.html)

基于内在结构的继承必然促进程序观。好的对象就是没有机会在这么恶劣的环境下生存。它们只不过是一种数据结构。我个人对庞大的层级结构的经验正好反映了这一点。我参与的一个项目有大量的类，代表应用程序可以处理的每个请求。可怕的是这些课程充满了商业逻辑。由于没有反映域的真实对象，这些请求类中的业务逻辑更像是对一些数据进行操作的过程。因为这种继承仅仅是由请求字段重用驱动的，所以它是非常不自然和不可维护的。

## 经常感觉做作

从这个过程意义上来说，应用继承产生的实体看起来总是人为的。它们很少反映无处不在的语言，如果有的话。原因是任何领域都有自然的[接缝](https://medium.com/@wrong.about/how-to-decompose-a-system-into-modules-796bd941f036)，划分不同的责任、行为——这正是使一个对象不同于另一个对象的原因。对象内部数据本质上不能用来区分对象——仅仅因为它是内部的。

# 行为遗传

为了行为扩展而继承才是应该走的路。这就像生物物种分类学。它的建立依赖于所有物种共有的一些共同特征。例如，所有的哺乳动物都是脊椎动物，吸热并产生乳汁喂养婴儿。灵长类动物是哺乳动物的一种，但是有发达的手和脚，有手指和脚趾。人类是*灵长类的一种*，但是我们有自我反省的能力。

这是一个在[对象思维](https://www.amazon.com/Object-Thinking-Developer-Reference-David/dp/0735619654)中使用的隐喻，它有一个有趣的结果。这意味着**具体的类不能被继承**。记住生物分类学的比喻，没有具体的哺乳动物实例。没有具体的灵长类动物。有猫，狗，人类。真正的实体是层次结构的叶子。其余的都是抽象类或接口。因此，我更倾向于[分型](https://en.wikipedia.org/wiki/Subtyping)的概念，而不是继承。

# 传承难得

假设我们有一个商业实体。可以审批，也可以过期。典型的方法是创建一个“状态”属性。但是很快我们意识到行为有很大不同。被批准的商家可以做我们系统允许的任何事情，不像过期的商家。因此，我们提出了两个独立的类——一个用于批准的商户，另一个用于过期的商户。第一个推动力是用他们共享的所有内部数据——姓名、地址等——创建一个基本的 merchant 类。但是，首先，正如我在开头所写的，这是错误的动机，其次，没有任何对象内部数据必须被建模为对象的属性([并且通常不是](https://medium.com/@wrong.about/you-dont-need-an-orm-7ef83bd1b37d))。所以这种继承在两方面都是错的。

遵循行为对象分解方法，结果表明继承在大多数情况下是不必要的。我们过去认为关系非常密切的东西——批准的商户和过期的商户，都是商户——实际上没有任何共同的行为，因此没有共同的父代。

# 继承层次很小

所以按照这种分解方法，除非我们设计生物分类学，否则不会有巨大的遗传级联。装修工的数量反而大。

这都是关于分解你的领域。当[做对了](https://hackernoon.com/on-good-domain-decomposition-385ee8ce5a3)，自然就出来了。然而这并不容易。

# 包装完毕

所以不要扩展具体的类——只扩展抽象的。首先分解你的问题空间，这导致了小而罕见的继承层次，有大量的装饰者。

* * *

这是[这个](https://medium.com/@wrong.about/inheritance-based-on-internal-structure-is-evil-7474cc8e64dc)原帖的交叉贴版本。