# 论状态依赖和耦合

> 原文：<https://dev.to/hdennen/on-state-dependence-and-coupling--5af9>

应用程序中的任何函数都依赖于可变对象的状态。

依赖一个变异对象的状态让一个函数每次都能正确工作有什么不好？

一切。这是所有事情的简略清单。

1.  当变异对象出现问题时，事情就会破裂。注意我说的是当，我会讲到的，但是现在你完蛋了，因为依赖函数的行为方式可能正确，也可能不正确。这比错误更糟糕，因为有时是错误的东西也能投入生产。很棒吧？这突出了非确定性函数的问题。
2.  不仅有两个紧密耦合的对象，而且这种耦合是隐式的。因为可变状态与依赖函数没有明确的联系，所以开发者无法知道对所述可变对象的任何突变或功能改变可能以看似不相关的方式改变系统的功能。恭喜你，你埋下了一颗地雷。这突出了单一责任原则和关注点分离原则的重要性。
3.  有些事情会出错，因为当代码迭代时地雷会被踩上。这突出了坚持原则作为你做事的理由的重要性，而不是“我不得不这样做，因为[在此插入上下文和短视的推理]”
4.  当依赖函数出错时，您最初没有解决的问题将变得明显，现在解决它可能需要认真的重构。关于决策的事情是他们堆叠和分支。如果你在早期做了一个糟糕的决定，那么下游的任何好的决定都会受到影响。这突出了良好的规划和设计以及开闭原则的重要性。
5.  比赛条件！函数不仅依赖于可变对象的状态，还依赖于调用依赖函数和对象变异之间的时间间隔。最棒的是，你现在可以在系统中一个完全不相关的区域做出改变，并导致这种竞争状态的出现。这突出了状态改变控制流的影响，以及类内聚性(或缺乏内聚性)如何影响可维护性。

那么我们如何避免这种情况呢？有很多方法，但最终每个情况都是不同的，好的原则是一个很好的指导(就像现实生活一样！).此外，查看函数纯度。

选择特定领域的试探法也是一个好主意。比如:倾向于扁平结构，喜欢长的描述性名称而不是短的模糊名称，尝试将分支逻辑推上调用堆栈，以及当您不确定要做什么时，任何可以为给定情况增加一点方向的东西。对我来说大部分时间都是这样。