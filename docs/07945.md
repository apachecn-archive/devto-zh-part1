# 简洁明了的编程

> 原文：<https://dev.to/danielkun/hacky-and-clean-programming>

当我编程时，我用两种“模式”中的任何一种。每种模式都有不同的目的，我在不同的阶段使用它们来实现一个目标。了解当前所处的阶段是非常重要的，因为以错误的模式编程对生产率或代码质量都是最有害的。

我称这两种模式为“黑客模式”和“干净模式”。

# 黑客模式

在“黑客模式”中，我尝试新技术或架构想法。例如，当你当前的目标是编写一个库来控制一个蓝牙设备时，我会首先进入“黑客模式”,进行尝试，找出使用原始蓝牙 API 的最有效和最稳定的方法。

当黑客入侵时，我不关心代码质量。我可能会违反自己的准则，使用难看的类型转换，将变量命名为“x”、“foo”或“data”。越丑越好。因为我肯定会把那段代码扔掉。这是一个非常重要的方面，不应该违反。你必须意识到你会扔掉代码，并且你最终必须这样做。如果你黑客的东西不管用，扔掉它，开始新的黑客会话——一旦你学会了重要的方面，也扔掉这个。没有干净的代码。没有文件。无可奉告。没有单元测试。

如果你担心，当重写你以前破解过的东西时，第二个系统效应(如弗雷德·布鲁克斯在《人月神话》中所描述的)可能会出现，我可以向你保证，用这种方法我还没有经历过这种情况。我认为第二个系统的效果只适用于更大的规模，而且只适用于在第一个系统中努力生产高质量的产品。

在我研究出哪些调用必须以何种顺序进行，了解了最佳结果的参数，并为 API 和实现找到了一个好的结构之后，我坐下来，好好看看它，并记住重要的部分。然后我把代码藏在一边以备后用，并在心里把它标记为“要删除”。

现在我可以切换到“清洁模式”了。

# 清洁模式

当我对我想要创建的东西有一个好的心智模型时，我就在“干净模式”下编程。当我知道实现的重要关键部分，并且对 API 和架构应该是什么样子有一个想法的时候。这些信息通常来自黑客会话。有时它就在那里，因为我已经思考这个问题几天，几个月甚至几年了，现在终于决定一切都很清楚，可以放进代码了。

大多数时候，当在干净模式下编程时，我在做*DDD——文档驱动开发*。别担心，这不是你错过的新时尚范例。它本质上是 TDD，但是我甚至在编写测试之前就编写了代码的文档。

## 最重要的:文档

TDD 之所以酷的一个主要原因是因为你可以“感觉到你的代码在实际使用时是如何工作的”。同样的道理也适用于写文档。(重要提示:我说的是描述一个类/函数/等的功能和属性的文档。我说的不是描述实现细节的内联代码注释)。写文件时，我总是试图陈述重要的细节，而不是显而易见的东西。当考虑非显而易见的东西时，你会知道整体设计是否流畅，或者是否有一些粗糙的边缘。将文档和测试结合起来，你可以非常确定设计是合理的，并且在实践中运行良好。你甚至可以用这种方式来想出新的测试用例。

写文档时有几个简单的规则可以遵循。当在实际实现之前编写它们时，这一点尤其重要。

**首先**，必须明确你正在记录的元素的*目的*是什么。如果没有一个核心功能，而是完成了多个任务，你很可能做错了。用一句话描述该元素的核心功能，即用@brief。如果元素的核心功能可以毫不含糊地从它的名字推导出来，你可以跳过这一部分。

**第二个**，说明使用该元素必须满足的前提条件。你能说出的前提条件越少越好。如果没有不被类型系统强制的前提条件，那么你就做对了。如果类型系统不够强大，不足以表达输入参数的约束，则详细记录它们。有传言说 Haskell 有一个很棒的类型系统，但不幸的是我还没有机会用它来做有成效的工作。

**第三个**，可能对维护最重要的，说明可能发生的副作用，以及在什么条件下可能发生。如果你是一个真正优秀的程序员，你写的是函数代码，可以跳过这一部分。你根本没有副作用。

除此之外，标准规则显然也适用:详细描述每个参数(同样:不是显而易见的！)、可能抛出的异常、必须如何解释返回值等。

当我这样做的时候，我总是有两个想法:

1.  该元素对潜在用户有什么实际用途，她会瞄准哪些目标？
2.  我怎么可能实现这个元素呢？

非常重要的一点是，不要因为实现而分心，创建一个糟糕的 API，它不像类的用户希望它完成的任务，而是仅仅包装底层技术。但同样重要的是，不要创建不可能以任何合理的方式实现的 API，否则性能会受到很大影响。对于(几乎)所有的成本，您都应该避免泄漏的抽象，但是这通常是有限度的。(这通常值得在 hacky 模式下进行原型开发。)

当我写完文档后，我开始写测试，看看我关于如何使用 API 的想法实际上执行得如何。我使用我写的文档以及我描述的副作用和死角来导出测试用例，因此获得了相当不错的覆盖率。

我经常画一些粗糙的伪 UML 来可视化依赖和关系。

当实际实现功能时，我会应用您从干净代码中学到的所有经验。我了解这些文档，并在必要时更新它们。这也可能导致 API 和测试的重新设计。我有意识地承担不适合 API 的实现细节代价高昂的风险，因为我多次经历过这种方法是值得的，因为它产生了架构良好、可维护、干净，最重要的是易于使用的代码。

# 期末笔记

如开头所述，区分这两种编程模式并在每种情况下应用正确的模式是最重要的。此外，我建议不要混合使用两者。不要在干净的代码库中编写黑客代码，也不要在黑客攻击时编写干净的代码。这是不值得的，因为你要么损害了你的代码质量，要么生产力低于你可以。

只在深入到最低限度的新的、孤立的代码库中进行黑客攻击。这当然需要你分离出一些部分，想出一些好的、小的组件来构建你的软件，这本身就很有价值。