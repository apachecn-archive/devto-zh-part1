# Git 恢复合并 git 恢复，合并提交，混淆

> 原文：<https://dev.to/gabeguz/git-revert-merge-commits-confusion>

昨天我在理解`git`和合并提交时遇到了一个缺口。大多数时候，我参与的项目使用“无合并”的提交历史，所以我们通常将我们的更改重组+压缩到一个单独的提交中，并将它们应用到 master，留给我们一个类似于
的提交历史

```
1---2---3---4---5 master 
```

Enter fullscreen mode Exit fullscreen mode

一般来说，如果我需要恢复提交 3，我所需要做的就是`git revert 3`，并且该提交被恢复并提交为提交 6:

```
1---2---3---4---5---6 master 
```

Enter fullscreen mode Exit fullscreen mode

昨天，我需要恢复一个项目中的变更，该项目使用多个远程分支，这些分支通过一个合并提交被合并到主分支:

```
1---2---3---4---5a master
     \a---b---c/ feature 
```

Enter fullscreen mode Exit fullscreen mode

所以，我尝试了一下，得到了一条我从未见过的信息:

`error: commit 5a is a merge but no -m option was given.`

瓦特？！？我调出了 [git revert docs](https://git-scm.com/docs/git-revert) ，结果发现由于一个合并提交有两个父级(我认为是 4 和 c——不，是 2 和 c ), git 没有办法知道哪一个应该被认为是“主线”这是我对文件的解释，这是实际的相关部分:

> 通常您不能恢复合并，因为您不知道合并的哪一侧应该被认为是主线。该选项指定主线的父编号(从 1 开始),并允许相对于指定的父来反转变更。
> 
> 恢复合并提交声明您永远不会希望合并带来的树更改。因此，以后的合并将只引入不是以前恢复的合并的祖先的提交所引入的树变化。这可能是也可能不是你想要的。

好的，所以我必须告诉 git 哪个父节点是主线，但是我怎么知道呢？如果我查看合并提交(`git show 5a`)，有一行写着:`parents 2, c`。在我的简单例子中，我认为主线是 2，所以我认为我想做`git revert -m 1`(因为 2 是列出的第一个父母)，因为 commit 2 在 master 上，我认为*相当于主线，但我不是很确定。*

我相信这将还原主分支和特性分支在`c`的所有差异，但是我发现这相当令人困惑。

还有，“你永远不会希望合并带来的树的变化”是什么意思？这是否意味着，如果我稍后尝试从同一个分支重新合并这些更改，我正在恢复的这些更改将永远不会被应用？因此，如果我向我的特性分支添加一个新的提交，然后尝试将那个分支合并回主分支，我是否只能得到新的更改，而*不能得到*我恢复的更改？如果是这样，我如何获得我恢复的更改？

我还没有机会完全理清这一切，或者测试我的假设，因为在大约一个小时的无所事事之后，我认为找到问题并解决它会更容易，而不是试图恢复导致它的更改。

这肯定让我觉得“无合并”git 历史更容易处理，因为它更简单，每个提交都是一个谨慎的单元，可以很容易地撤销，但我知道有些人更喜欢合并提交工作流，所以我必须花更多的时间来弄清楚它。