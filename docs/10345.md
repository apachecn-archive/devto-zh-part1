# 图形 SQL-yay 或 Nay？

> 原文：<https://dev.to/grahamcox82/graphql---yay-or-nay>

(我刚刚把这些都写了出来，在我的手机上，在上班的公交车上，然后不小心刷新了页面，就丢了。很抱歉，如果这似乎有点缩写)

GraphQL 已经存在一段时间了。关于它已经写了很多东西——几乎都是好的。那么，它已经准备好在黄金时段使用了吗？你应该抓住它吗？当然不是。它也有不好的方面和问题，在你决定它是否是正确的选择之前，这些需要和好的方面一起考虑。

对于您的 Web APIs，GraphQL 是 REST 的替代方案。它将您的数据显示为一个有向图，允许您在请求中遍历它，不仅可以检索您想要的单个数据，还可以同时检索其他链接的数据。您还可以从客户端控制您想要检索的确切数据。在这两点之间，您可以节省大量的网络时间——可以发出一个请求来准确地检索您想要的数据，跨越多种资源类型，并且不会返回您不关心的数据。

不幸的是，尽管模式本身被设计成一个包含有意义的互连数据的漂亮图形，但是实际的查询没有任何名称空间的概念。所有的顶级查询字段都被打包在一个大袋子里，客户端开发人员必须找出哪些是真正相关的。想象一下一个博客网站——你可能有顶级的用户查询字段，文章和标签都捆绑在一起。并且可能不只是每个字段一个。您可能会有查询字段，用于按 ID 获取和搜索这些字段。随着模式的增长，这种混乱只会变得更糟。

突变让情况变得更糟。在检索领域，设计是围绕嵌套数据构建的。您将检索一篇文章，并且作为文章的一个子字段，您将检索评论。突变*必须*是顶级的。这意味着，你可以将操作评论和赞的变体与用户、帖子和标签的变体捆绑在同一个包中。您可能会有比查询字段更多的字段——在 CRUD 世界中，您可能会对您正在使用的每个资源的创建、更新和删除进行修改。

总的来说，这两个问题是我个人对 GraphQL 最大的痛点。相比之下，我的其他抱怨一般都微不足道，因为如果你小心的话，它们是可以解决的。

虽然实际的模式本身可能会变得混乱，但是用于构建模式的代码可能会变得更糟。很难有干净的代码来编写循环模式并分布在多个小文件中。我见过的几乎所有例子都在一个文件中——因为这很简单。我见过的几乎所有在多个文件中的例子都是线性的。实际上，你的数据中会有循环。(再次以博客为例，想象这个图是用户->文章->评论->用户。就在那里骑车)。有*种方式来处理这个问题，但是它们没有被很好地记录下来，并且在工作中会很混乱。*

版本控制是另一个大问题。许多人认为，因为客户端可以控制只请求它需要的字段，所以版本控制的整个概念可以消失。如果你想删除一个字段，你只需弃用它就可以了。然而，如果没有版本控制，你实际上永远无法摆脱那个字段——因为可能有人还在使用它。你很难改变一个字段的语义，因为你只是改变了它的工作方式。想象一下，将一个以秒为单位的日期字段更改为 ISO-8601。或者更糟，从纪元前到百万年前。客户端不会看到该字段被弃用，现在只是被破坏。至少在 ISO-8601 的变化中，你会有一个明显的突破，可以很容易地用眼睛发现。在自纪元以来的数百万年的变化中，它仍然是一个数字，用肉眼很难看出这个数字没有比以前大 1000 倍。

我所看到的版本控制的唯一答案是和其他世界一样。在 GraphQL 控制器之外引入版本控制，以中断变更。通过使用不同的 URL 或者通过使用标题。然后，您会暂时停止运行不同的并行模式，直到您停止对旧模式的支持。它可以工作，但是很粗糙。

那么，GraphQL 准备好了吗？这在很大程度上取决于你在做什么。如果你正在做一些内部的事情，或者相对较小的事情，那么尽一切办法去做吧。最糟糕的情况是你从中学到了一些东西。如果你正在做一些更大的事情，并且是面向公众的，那么考虑一下，但是要非常小心，因为你更有可能碰到它已经存在的问题。