# 星期五爆炸#11

> 原文：<https://dev.to/horia141/friday-blast-11-3bo6>

这是星期五爆炸系列的第 11 集。这次更多的是数据科学和职业建议。

[机器人应该纳税吗(2017)？](https://hackernoon.com/should-robots-pay-tax-a2578bdf9f38) -标题中问题的答案通常是“否”，但这次似乎是“是”。我们都知道[机器人末日](https://en.wikipedia.org/wiki/AI_takeover)即将来临。现实的方式是用机器人迅速取代人类劳动，包括知识劳动和体力劳动。我们当然在工业革命和随后的所有事件中见过这种情况，我们设法度过了难关。不太清楚的是，如果我们整体的运营方式没有大的改变，这一次会是什么情况。这篇文章在一定程度上谈到了各种解决方案，在更大程度上谈到了“机器人税”。这基本上是对资本所有者(或多或少是公司)的征税，因为他们拥有非人类工人。在包括普遍收入等事物的图腾柱上，这是非常低的，但它似乎比不涉足人工智能和让事情顺其自然的卢德答案更好。

[科技行业的三条道路:创始人、高管、员工(2017)](https://blog.ycombinator.com/three-paths-in-the-tech-industry-founder-executive-or-employee/) -这来自 Y Combinator 的博客，所以你知道这是好东西。这篇文章详细介绍了在科技领域发展职业的每种方法的利弊，并详细说明了一套实用的策略。在大型科技公司或硅谷那种成功的初创公司工作有一定的吸引力，但我不会说这是压倒性的。我真的很喜欢这种现实的方法。它不是专注于技术或有远见的想法。而是更世俗的东西，如沟通的能力，建立团队和共识，玩必要的政治游戏。最后一段相当发人深省。要让*在任何一条道路上都有好的*，大概需要 10 年的时间，所以你不能磨磨蹭蹭。

[线性代数直观指南(2013)](https://betterexplained.com/articles/linear-algebra-guide/)—[系列的一部分关于数学的更好解释](https://betterexplained.com/)，这篇文章涉及线性代数的一些方面。它做得很好，大多数人都会从中得到一些东西，但它也很短。线性代数需要更多的直觉。

[构建成功数据管道的三个最佳实践(2015)](https://www.oreilly.com/ideas/three-best-practices-for-building-successful-data-pipelines) -获取和使用数据洞察力对许多大大小小的企业来说变得越来越重要。为了可靠地做到这一点，除了统计问题之外，还必须把这个问题当作一个工程问题来处理。这意味着*数据管道*——将访问日志和购买记录等原始数据转化为用户推荐和分析等洞察的系统——需要精心打造。作者推荐的三个特性是它是可重复的、一致的和可生产的。第一个意思是，所有的工具和假设都应该安全地存储在源代码控制中，并在每次运行时以受控的方式重用。这确保了对相同输入的两次运行产生相同的输出。第二个意思是应该有一种方法将输入保持在一个“原始”状态，在最初的生成之后不会被修改。这确保了你实际上有东西可以第二次运行可重复的程序。第三意味着遵循良好的软件工程实践——公共代码被分成库，有明确依赖关系的适当运行时定义等，度量被收集，警报到位等。

[使用日志构建数据基础设施(2016)](https://www.confluent.io/blog/using-logs-to-build-a-solid-data-infrastructure-or-why-dual-writes-are-a-bad-idea/)——日志的思想——只添加记录事件的结构——出现在许多不同的地方。这篇文章详细介绍了如何围绕日志组织整个系统的架构。生成的每个事件都会记录到日志中。之后，各种系统，如数据库、缓存、搜索索引等。会读取日志，最好是接近实时的，并更新它们的状态。这种架构很有吸引力，因为它将日志放在集成的中心，而且日志非常简单和高性能。我们将把 O(N < sup > 2】变成 O(N)积分。尽管并不完美。事务和打破最喜欢的`read_request -> write_to_db -> respond_with_new_data_from_db` / read-your-writes 一致性的问题突然出现。

[在现代构建可扩展的有状态服务的案例(2015)](http://highscalability.com/blog/2015/10/12/making-the-case-for-building-scalable-stateful-services-in-t.html) -这里有一个有趣的想法。构建互联网应用程序时，最常见的方法是将任何带有应用程序逻辑味道的东西放入位于客户端(也是无状态的)和各种存储系统之间的无状态服务层。后者*不是*无国籍的，因为某些东西必须保持状态。但它们通常是现成的组件，如针对特定问题进行调整的数据库和缓存。这对于大多数情况来说都是合理的建议，而且*确实*让构建应用程序变得更加容易。但是它有性能缺陷。有时候你负担不起。这篇文章描述了某些系统如何通过状态化得到帮助。但是，这不是你爷爷的*有态*。从数据库研究中借鉴了很多。八卦协议、一致散列、集群成员等。所有人都出现了。这是研究这些东西的更多理由——在某些时候，您可能会被要求为服务层实现它们的子集。这看起来很像编程语言环境中的状态。大多数时候，考虑不可变数据结构的转换更容易，也不容易出错。但是你必须在某个点执行 state *，这通常是因为性能约束。*