# 什么是象征？

> 原文：<https://dev.to/thelonelyghost/what-is-a-symbol-3b4>

当我今天晚上浏览 twitter 时，我看到了@searls 的一条推文，询问新的 Ruby 爱好者(< 5 年)Ruby 中的一些仍然令人困惑的概念是什么。仍然令人困惑的最常见的概念是符号，所以下面是我对它的解释。

为了解释符号，我必须首先解释数据类型。

## 数据类型

你知道数据类型之间的区别吗？

### 原语

有一个`string`(如`"Lorem ipsum dolor"`)，是一组字符(`char` s)。有各种各样的数字，从整数(例如，`1`但不是`1.4`)、双精度数(一个非常大的整数)、浮点数(例如，`1.4`或`1.0`)，以及任何有符号(包括负数)或无符号(绝对值，仅正数)的数字。还有像布尔这样超级简单的概念，可以精确到“是”也可以精确到“不是”。

为什么会有这些变化？不都是文字吗？想想这个:

### 双星

计算机用二进制、一和零来思考。二进制可以代表任何数字，比如`000000`代表零，`000001`代表一，这是可以想象的。棘手的是`000010`代表了两个。击球手出局了吗我们继续。

*   `000011` →三
*   `000100` →四
*   `000101` →五
*   `000110` →六
*   `000111` →七
*   `001000` →八

明白了吗？如果我们继续这种模式，我们会看到我们最终达到了`111111`(63)，但这不是存在的最后一个数字，对吗？我们需要另一个数字来保存 0 或 1，它一直表示到 127。哇，跳得真快，对吧？所有这些与数据类型有什么关系？

### 二进制数据类型

计算机必须在内存中存储数据的表示。但是等等，我们不是刚刚讲过计算机用二进制思维吗？那仍然是真的。我们必须想出一种用二进制来存储像`1.3`这样的东西的简写方式。

让我们把它拆开。这是一个浮点数据类型。我们必须想出一些速记法来记录小数点前和小数点后的内容。不如我们说前四位是小数点前的数字，后四位是小数点后的数字。以后我们可以把这个扩展到八位数以上。

在这种情况下，`1.3`的二进制表示可能是`00010011`。这和整数`19`有什么区别？两者都用同一个二进制表示，对吗？我们需要想出一些通用的简写来说明这种区别。

在一个整数中，我们知道同一个值`010011` (19)也可能是正数或负数。这称为“有符号”整数。其他数字数据类型也可以带符号，但是我们现在只对整数进行简单的描述。我们将保留拆分数字的速记，但它是正还是负只有两种选择。我们大概可以保留第一个数字，其中`1`表示负的，`0`表示正的。所以`19`就是`0010011`的意思，`-19`就是`1010011`的意思。

### 数据头

我们必须记住所有这些速记技巧，但最终只是 1 和 0。我们如何区分之前的无符号`19`和`1.3`?让我们想出一个通用的简写方式来确定我们将为接下来的几个数字存储哪种数据类型。三位数应该够了。现在，我们将通过这种映射记住一些数据类型:

*   `001` →字符
*   `010` →无符号整数
*   `011` →带符号整数
*   `100` →浮动
*   `110` →双精度
*   `111` →布尔

为了整合这一点，我们将把它附加到每个值的开头，并且记住将前 3 个数字解释为数据类型指示符。

### 数据最大值/最小值

为了得到所有这些简写，我们必须同意下一个 *X* 位数，它将表示数据类型的值。一个布尔值，true 和 false，只需要一个数字(加上标题)，而一个无符号整数只能用 3 个数字计数 0 到 127，这对于计算体育场座位数这样有趣的事情来说可能不够。

我们将为这些数据类型提出一些任意长度的数字。以下是一些例子:

*   `0000000000` →字符(10 位数字)
*   `0000000000000` →浮点型(13 位数字)
*   `000000000` →无符号整数(9 位数)
*   `0000000000` →有符号整数(10 位数字)
*   `0` →布尔型(1 位数)

总之，一个 float 将占用值的 13 位数字+头的 3 位数字，表明它是一个 float。16 位数。如果我们有多个数据实例(数据类型头+二进制值)，我们可以把它们串在一起。

*   `1000000000010011` →值的浮点数据类型`1.3`
*   `1110` →值的布尔数据类型`false`

让我们把这两个数据实例放在一起，就像计算机可能把它们保存在内存中一样:`11101000000000010011`

什么？

好吧，我们再撕一次。

如果我们只看到这个二进制文件，而没有任何其他上下文，我们可以通过从左到右阅读来记住我们的头的简写。前 3 个数字表示它是一个布尔值，我们知道它的值长度为 1 位。我们将它读为布尔值`false`，并且我们已经解析了示例数据中的前 4 位数字。

既然我们已经完成了前 4 位，我们将从第 5 位开始，遵循相同的模式，将前 3 位解释为数据类型(`100` = float)，并将接下来的 *X* 位(float 值→ 13 位)解析为值。接下来的 13 位数字总计为`0000000010011`，我们将假装我们已经建立了一种新的速记法，其中浮点数的最后 3 位数字保留给十进制数。这就更容易了，因为我们记得这是`1.3`。

用另一个示例值:`01100000111010010001011100`再次这样做

阅读前三个数字(`011`)，我们看到它是一个有符号的整数。这意味着我们读取接下来的 10 个数字(`0000011101`)作为值。了解了有符号整数的简写，我们回忆起值的第一个数字(`0`)告诉我们它是正数还是负数，剩余的数字(`000011101`)就是数字本身。然后我们可以判断它是`+29`。

完成后的下三个数字是`001`，表示一个字符。从前面我们知道，字符数据类型为它的值保留了接下来的 10 个数字，但是我们不知道如何解码它。我们还没有建立那种速记。然而，这里重要的一点是，当不同的数据类型被放在一个由 1 和 0 组成的长长的、牢不可破的字符串中时，我们可以区分它们。

## 字符对字符串

如果你还没有意识到，一个字符可能代表你键盘上的任何一个键，包括字母、数字、标点符号(如`?`和`!`)，或者其他书面语言(如`{`或`)`)。一个字符可以组成您在键盘上可能看不到的单个字母，如“或”。关键是，一个字符可以是大量可能的值，它们和 1 或 0 在屏幕上占据相同的物理空间。

回到之前说的，计算机是用二进制思考的。我们可以想出一种方法来存储每个字符，映射到一个数字值。这些被称为字符编码。像其他数据类型一样，这告诉我们每个字符将占用多少位数。一个字符可能是 ASCII 码，只是你可能在 QWERTY 键盘上看到的，或者它可能是 UTF-8，包括表情符号和其他更丰富的字符样式。为了简单起见，我们将坚持使用 ASCII。

英语字母表中有 26 个字母，加上 11 个特殊的符号键(每个都有大写和小写字母，所以有 22 个字符)，加上 10 个键的数字键行(所以有 20 个字符)，再加上空格键，这样我们就有了 69 个可能的字符。我们需要足够多的二进制数字或比特来处理最大数量 69。根据我的计算，那是 7 比特。离我们之前为保存字符数据保留的 10 位不太远，对吗？

要制作一个类似于`"Hello world!"`的字符串，我们需要对它进行分割。首先是字符`H`，然后是字符`e`，然后是字符`l`，以此类推，表示“你好”。

等等，我们这里也有大写字母？！开枪吧。让我们修改 69 个字符的计数，增加 26 个字符，每个大写字母增加一个。总共有 95 个可能的字符。好在我们的 7 位能够存储 0 到 127 之间的任何数字。

所以我们有“你好”和“世界！”由一个空格字符分隔，相当于 12 个字符。由于每个字符占用 10 位(3 个头+ 7 个值)，我们需要 120 位来将`"Hello world!"`呈现为二进制数据。我要在这里停下来，让你思考一下。

## 符号数据类型

让我们假设您有一个字符到位值的映射，并且最大位被完美地映射出来。你有一个字符串，它占用了 12 个字符，代表 120 位，只是为了向世界问好。如果有些东西你只是为了自己的目的想在内部引用呢？我们不关心实际值，我们只关心这个值与其他值相比是唯一的。它只有语义上的意义。你知道我们有那些字母，十进制数等的映射。到二进制？那些是同一个符号的概念。这是`char`速记的一部分。如果我们更进一步呢？

首先，在所有的二元对话之后，我需要暂时抛开理论。我需要回到我所知道的编程:Ruby，Python 等。

Ruby 和 Python 是动态语言，在这两种语言中，您很少需要知道一个包含特定数据类型的变量将占用多少内存。我操作的方式，我关心的是在任何时候我能多容易地在我的头脑中保持一个程序的内部运作。我需要对计算机无关紧要的提示，但只对作为程序员的我有用。以一个日志类(在大多数语言中)为例。

我们有一个记录器的概念，它接受各种错误级别的枚举:`ERROR`、`WARN`、`INFO`、`DEBUG`，可能还有更多。我们关心存储字符串来表示它吗？不。我们只是需要一些内部表示来参考。让我们在这里选择一个内存占用非常小的数据类型。

表示`"ERROR"`(作为字符串)将是 5 个字符，每个字符 10 位= 50 位。其他日志记录级别的字符数可能更多或更少，所以我们只需要一个小于 50 位的数据类型，或者二进制数字长度来代表另一个更占用内存的值。让我们选择无符号整数`4`，其他日志级别也选择无符号整数。我们不关心`4`的价值，只关心它代表什么，所以它很可能是`986`或者便便表情符号。这是为了区分`ERROR`和`WARN`以及其他。

所以无符号整数`4`用二进制的`010000000100`表示。这是 12 位长，而字符串版本可能是 50 位。这是相当大的节省！只有原来内存占用的 25%！

在像 ruby 这样的语言中，这样小的节省可能不会产生太大的影响，但是可以用二进制编码而不是无符号整数，这样所有浪费的空间都可以回收。我们只需要头 3 位用于报头，后面 3 位用于`4`的值。如果我们的编译器足够聪明，知道我们只需要一个最大值`4`会怎么样？

在这种情况下，我们可以记住一个新的数据类型，它表示下面的 *X* 数字代表一个符号，其中 *X* 是在整个程序被分析后确定的，以计算出可能看到的最大值。在我们的例子中，它是 4，所以我们将使用的位数从 12 减少到 6。曾经的`010000000100`现在是`010100`。

但是等等，我们还有一个无符号整数的数据类型头！那会把一切都搞砸的！那是非常真实的。我们不能一直用编码/解码二进制来打破我们自己的速记惯例，所以我们必须想出一种新的、动态的数据类型，我们称之为符号。它将被称为标题`101`，因为它还没有被使用过。

从最初的 50 位到`010000000100` (12 位)，再到`101100` (6 位)，对于程序员和最终用户来说，对于完全相同的功能来说，这是相当大的缩减。

## 重述

符号就像它们听起来的那样:内存中其他东西的替代值。它们的功能是节省内存使用，当你不需要分配大量的位来拥有一个只需要表示它不同于其他标签的标签时。价值观其实并不重要。它们是一种方便的表示，最初将工作转移到编译器上，但在运行时净内存更少(和同等的计算能力)。

## 向前移动

这些优化不仅用于存储数据，还用于引用代表计算机应该遵循的逻辑的二进制数据块。你真的认为你的计算机记得在那个文件中查找字符串`my_main_function()`以便调用其中定义的逻辑吗？你觉得计算机在乎你如何给事物命名吗？不要！它将逻辑读取为二进制，并确定一个它只记得的符号，以便它可以轻松地调用该功能。这些是在您使用的编程语言中自动发生的更多编译优化。

像 C 和 Ruby 这样的语言允许您直接访问作为数据类型的符号，但是像 PHP 和早期版本的 Java 这样的语言要求您声明您喜欢的数据类型和值，当定义符号存在时，将内存优化留给程序员。

符号有帮助吗？当然可以。多久一次？这取决于你手头的任务是什么以及如何编码的。希望这将作为一个介绍，什么情况下最好使用符号而不是其他数据类型。