# 两位将军

> 原文：<https://dev.to/dwd/two-generals-8l5>

想象一下，你正坐在一个黑暗的房间里。你并不孤单。坐在你旁边的是另一个人，一个模糊的、坦率地说不可信的人，我们称之为网络。网络的另一端是你的朋友。你有一包薄荷糖。你的朋友有一袋巧克力糖。你想用一些薄荷糖换一些巧克力糖。出于某种原因，我还没有决定，这一切都必须在沉默中完成。

为了把一块薄荷糖传给你的朋友，你需要把它传给社交网络，而社交网络会——希望——把它传给你的朋友。然后，你的朋友将一滴巧克力传回网络，网络又一次满怀希望地传回。然后，你传递另一个薄荷，等等。

因为网络可能需要很长时间来传递信息，也可能直接吃掉它们，所以总会有相当多的不确定性。在你传递了第一颗薄荷糖后，你不会知道你的朋友是否有薄荷糖，除非你得到一颗巧克力糖。

同样，你的朋友不知道你有没有巧克力糖，除非他们有另一颗薄荷糖。

更一般地说，在任何给定的时刻，你知道你的状态，你的朋友知道他们的状态，但是你们从来不互相了解。

这个极其简单的问题也令人高兴地无法解决。在现实世界中，大多数消息协议都会以这样或那样的方式受到影响。拿电子邮件来说，如果你从来不回复我给你发的邮件怎么办。是邮件没有到达你那里，还是回复在回来的路上失败了？

错误消息也不能幸免——在电子邮件中，退回的消息很容易丢失，就像它们所报告的消息一样。

这个问题被称为“两个将军的问题”,它实际上是关于状态复制而不仅仅是消息。或者巧克力糖，虽然巧克力很好吃。

事实证明，通过一个潜在不可靠的网络在两个实体之间可靠地复制状态是不可能的，而且事实证明，网络总是不可靠的。实体实际上也是如此，尽管不那么明显。

然而，大多数消息传递协议都是建立在 TCP 之上的，这就增加了一些技巧来减少这个问题。简单地说——我是说非常简单地说——TCP 对通过它的每条消息都进行了编号，而且是严格有序的。如果我给你发消息“1”，然后给你发消息“2”，你只得到“2”，你知道“1”在某个地方不见了，你可以去找它(直到你得到“1”才处理“2”)。

同样，如果你两个都拿到了，然后告诉我你已经到了“2”，我知道你两个都拿到了。

当然，我可能会丢失你的“ACK”来说明你在做什么，而你永远不会得到丢失的“1”，所以这并没有完全解决两位将军的问题——但这确实意味着在任何给定的时刻，我对你的状态*使用*是什么有一个可靠的看法，并且你对它的*意味着*是什么有一些想法。换句话说，它极大地减少了潜在的状态数量——这意味着状态转换(以及消息)是严格有序的。

应用协议使用这一点并在此基础上构建。电子邮件中的 SMTP 要求电子邮件确认不仅在收到电子邮件后发生，而且在将它存储到磁盘或转发后发生。

但是一旦一个 TCP 会话被丢弃，通常很难弄清楚在它被丢弃之前事情发展到了什么程度。TCP 会话下降的原因有很多——对大多数人来说，是当你带着手机走进一栋大楼，手机切换到 WiFi 时。对其他人来说，这可能是当他们的卫星失去视线。

所以 XMPP 对此做了进一步的阐述。

XMPP 最初是为处理临时即时消息而设计的协议，现在被用于一些高度关键的任务，协议设计者希望使它尽可能可靠。输入 XEP-0198。

XEP-0198 将 TCP 的计数技巧嵌入到应用协议中。当 TCP 会话开始时，两端都可以确认通过 TCP 的每条消息(实际上是任何“节”)，并确信知道哪些已经被处理，只需使用一个简单的计数器(因为 TCP 为我们做了艰苦的工作)。

神奇的事情发生在 TCP 会话中断的时候。XMPP 客户端可以重新连接，并告诉服务器他们已经走了多远——这重新建立了排序，两端都可以重新发送任何丢失的流量，从之前继续。如果这种“会话恢复”成功发生，则不会丢失流量，并且它还节省了更多传统重新连接会遇到的流量。

当然，没有什么能够完全解决这两个问题——但是 XMPP 使用 XEP-0198 证明了这个问题可以减少到只影响长时间网络中断的程度。