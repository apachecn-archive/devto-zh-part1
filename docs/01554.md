# 曲线背后:Node.js 包开发中的“新”与“兼容”

> 原文:[https://dev . to/DM fay/behin-the-curve-new-vs-compatible-in-nodejs-package-development-34de](https://dev.to/dmfay/behind-the-curve-new-vs-compatible-in-nodejs-package-development-34de)

Node.js 的开发速度为增长和维护可重用库创造了一个复杂的空间。随着新特性的引入，为了简化现有代码和利用新功能，保持最新和最大的压力是存在的；但是反方向也有压力，因为依赖包的项目本身并不总是跟得上 Node。

我主要的开源项目是 [Massive.js](https://github.com/dmfay/massive-js) 。它是 Node 和 PostgreSQL 关系数据库的数据访问库。早在 io.js 合并回 Node 并将其升级到 ES6 之前，我就开始参与它的开发，到目前为止，我仍然在一个(没有积极开发的)产品中使用它，该产品具有基于回调的老式 API。我在其他项目中也依赖于它，Node 8 是最新的稳定发布版本，所以我开始使用许多新的特性集，这些特性集使节点开发变得更加有趣。

鉴于像我这样的库被用于旧的项目和旧的引擎，代码必须在尽可能多的引擎上运行。对于开源项目，很容易假设，如果有人*真的需要*做你的包在石器时代的引擎中所做的事情(在 Node 中更好地称为“昨天”),他们可以提出一个问题或提交一个拉请求，或者在最坏的情况下分叉你的项目并做他们必须做的任何事情来使它工作。但是实际上，一个软件包的用户群越小，开发它的意义就越小，所以在通用性和兼容性之间需要一个微妙的平衡。

## node . js 历史中的重要数字

*   io.js 合并回 Node 之前的最后一个版本，带来了最新版本的 Google V8 引擎和 ES6 实现的开端。
*   **4**:2015 年 9 月 io.js 重新整合开始的主要发布系列。一些 ES6 语言特性，比如 promises 和 generators，变得本机可用，使那些节点开发人员能够从“回调地狱”中升级。Node 还转向了“偶数主版本稳定，长期支持，奇数主版本积极开发”的发布模式。
*   **6**:2016 长期支持(LTS)发布系列通过代理、析构和默认函数参数完善了 ES6 特性集。前者是一种全新的使用对象的方式，而后两者是对开发人员生活质量的重大改进。
*   **8**:2017 LTS 发布系列，目前到 2018 年 4 月发布 Node 10 为止。这里的大问题是异步函数:承诺结果仍然有点笨拙，导致了像[公司](https://github.com/tj/co)这样的库的兴起，它们利用生成器来简化异步功能。有了`async` / `await`，这些承诺管理库就不再需要了。

## 最大兼容性意味着什么

对于像 Massive 这样的实用程序库，最终用户的理想场景是他们不必关心他们使用的是哪个引擎。还在 0.12，甚至更早？没关系，把它扔进去，看着它走。不幸的是，这不仅意味着 Massive 不能利用新的语言特性，还会影响其他人对这个包的操作。

最明显的影响是承诺，它在 4.0.0 中才成为标准。在此之前，有多个独立的实现，如 [q](https://github.com/kriskowal/q) 或[蓝鸟](https://github.com/petkaantonov/bluebird/)，大多数符合 [A+](https://promisesaplus.com/) 标准。对于 Massive 来说，在内部使用 promises 同时运行旧的引擎，它必须捆绑其中的一个引擎。并且*仍然*不会使基于承诺的 API 有用，除非项目本身集成了承诺库，因为在 4.0.0 之前的引擎上唯一保证可用的 API 隐喻是回调。

语言规范中一些最受欢迎的特性是避免回调的方法。这是有充分理由的，尽管我不会在这里详述；可以这么说，回调在最好的情况下也是笨拙的。Massive 的旧版本甚至附带了一个可选的“去同步”包装器，它可以将基于回调的 API 方法转变为同步阻塞调用。这种用法完全不适合生产，但更容易起步。

## 爆发点

随着版本 4 的更新，积极开发的项目开始朝着承诺快速前进。我们开始在问题跟踪器上看到对基于承诺的 API 的偶尔请求。我的一个老项目甚至在 Massive 周围有了一个小的“promise rify”API 包装器，因为我们升级了引擎，并开始编写路线和可重用的函数，多亏了`co`。最终，事情发展到了这样一个地步，没有理由*而不是*将大规模转移到承诺上:任何仍然需要回调的东西在当前的 API 中都很可能是稳定的，如果不是遗留代码的话。

这意味着彻底决裂。Massive 的新版本可以专门使用承诺，而任何依赖回调的东西都必须保留在旧版本上。根据语义版本化标准，不兼容的 API 变化需要一个新的主要版本。除了遵守 semver 之外，将基于 promise 的实现发布为 3.0.0 将允许在新的和改进的 3.x 版本的同时在现有的 2.x 系列上制作紧急补丁。

## 多个带标签的并发发布

npm 注册表使用“dist-tag”系统来标识特定的版本系列。当 I `npm publish` Massive 时，它更新`latest`标签上的发布版本；当用户运行`npm install massive`时，无论`latest`指向什么都会被下载到他们的系统中。包作者可以创建并发布到其他标签，如果他们不想改变默认标签的话(因为没有一个替代标签，`latest`将被更新)。这经常被用来让用户选择预发布，但它也可以很容易地让传统用户选择*退出*更新。

从代码库中的遗留分支发布到第二个标签意味着安装最新的基于回调的版本就像`npm i massive@legacy`一样简单。或者甚至可以更简单:`npm i massive@2`解析为具有该主要版本的最新版本。当然，默认情况下，package.json 不允许重大版本更改，所以不必担心意外升级。

您可以通过发出`npm dist-tag ls`来列出活动的 dist-tag，并通过其他`npm dist-tag`命令来管理它们。

## 有一次我搞砸了

7 月，一名用户报告了在版本 4 系列引擎上使用 Massive 3.x 的问题。版本 6 稳定发布已经有一段时间了，我的活动项目已经升级到这个版本有一段时间了。刚刚发布了更新的版本 8 系列，完全支持`async`和`await`。问题是我无意中使用了默认的函数参数来简化代码库。该功能仅在版本 6 发布系列中引入，这意味着 Massive 不再与版本 4 引擎一起工作。

修复这个问题以允许 Massive 在旧的引擎上运行会有点烦人，但这是可能的。然而，我在工作中有一些想法，无论如何需要打破与版本 4 系列的兼容性:代理不是向后兼容的，所以任何使用它们的东西只能在版本 6 系列和更新的引擎上运行。我没有修复与一个引擎的兼容性，这个引擎现在被取代了两次，只是为了以后再次破坏它，我最终决定不去管它，而是澄清引擎版本需求。

## 缓慢而谨慎地移动，尽量不要打碎东西

Node 上的包开发的主要教训是，你必须与当前的引擎开发保持一定的距离，以便接触到最多的用户。落后多少更主观，取决于项目和用户群。我认为 Massive 是一个完整的 LTS 版本，但一个对比的例子可以在它使用的 [pg-promise](https://github.com/vitaly-t/pg-promise) 驱动程序中找到。Vitaly 甚至允许加入非本机 promise 库，这从 2015 年开始就没有必要了——除非你被困在 io.js 合并之前的引擎上，而更通用的查询工具的用户似乎更有可能这样做。

遵循语义版本化实践不仅确保了用户的稳定性，还使遗留更新变得可行——只需检查遗留分支，修复需要修复的内容，并发布到`legacy`标签而不是`latest`。到目前为止，一个新特性和几个补丁实际上已经登陆了 Massive v2，但它通常很安静。

拥有一个明确定义的版本控制标准也有助于更好地管理持续开发的速度:弄清楚何时以及如何集成突破性的变更以最小化它们的影响仍然是困难的，但是这比无限期地推迟它们要好得多。