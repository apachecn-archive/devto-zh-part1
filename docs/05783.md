# 显式实体状态

> 原文:[https://dev.to/horia141/explicit-entity-state-1o5e](https://dev.to/horia141/explicit-entity-state-1o5e)

在典型的应用程序中，我们使用的许多甚至大部分实体都有它们可能处于的不同状态的概念。这些状态对应于该实体在应用程序中的演变，并且该实体被期望作为某些事件发生的结果从一个状态移动到另一个状态。

为了使事情更具体，考虑一个用户实体。通常一个人加入一项服务，然后被要求确认一封电子邮件。之后，产品就完全可以使用了。稍后，用户可能会退出应用程序并删除他们的帐户。我们可以说用户有三种不同的状态:加入、确认和离开。同样，首先发出电子商务订单，然后收到付款，最后发货。在发货前，订单可以随时取消。现在状态更复杂了，有了合适的有限状态机作为模型。

当像这样明确地展示出来时，事情就相当不错了。该模式是自文档化的，应用程序代码可以很容易地过滤和假设哪些列对于给定的状态是有效的，并且通过对实体的可能状态进行系统化，我们自己对代码的理解也变得很容易。

然而，很多时候事实并非如此。也就是说，没有一个 state 列来明确记录实体的状态，对它的更改也不会因为一小组定义良好的事件而发生。相反，状态隐含在各种字段的赋值中。我见过的一种常见模式是通过一个`IsRemoved`字段或一个`DateRemoval`字段来标记移除，一旦实体被移除，这个字段就不为空。

对于两种状态，这样的编码不会引起问题，但也不好。然而，当我们开始添加其他字段时，如`HasAcceptedEmail`或`HasShipped`等。事情开始出问题了。不清楚什么时候允许任何 2^n 州组合，基于州的过滤更难，结果代码变得更复杂。

所以我认为这是一个非常讨厌的反模式。这并不容易解决，因为任何数据库重构都是如此。但是作为第一种方法，它确实用于添加显式 state 列，并尝试相应地维护它，同时还并行地执行任何单独的字段工作。一旦您确信状态处理是正确的，您可以删除像`IsRemoved`或`HasShipped`这样的字段，留下像`DateRemoval`这样的字段，以便以非规范化的方式更快地访问。