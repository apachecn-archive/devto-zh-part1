# 压型

> 原文：<https://dev.to/dzeban/profiling-38b4>

## 术语

**剖析**–软件的动态分析，包括收集各种度量并从中计算一些统计信息。通常情况下，你会做概要分析来分析性能，尽管这并不是唯一的情况，例如有关于[能耗分析](http://infoscience.epfl.ch/record/181628/files/eprof.pdf)的概要分析的工作。

不要混淆分析和跟踪。*跟踪*是保存程序运行时步骤以进行调试的过程——您没有收集任何指标。

此外，不要混淆剖析和基准测试。标杆管理就是营销。您启动一些预定义的过程来获取一些可以打印在营销手册中的数字。

**剖析器**–进行剖析的程序。

**配置文件**–配置文件的结果，从收集的指标中计算出一些统计信息。

## 度量标准

profiler 可以收集和分析许多指标，我不会一一列出，而是尝试对其进行一些层次划分:

*   时间度量
    *   程序/函数运行时
    *   I/O 延迟
    *   …
*   空间度量
    *   内存使用
    *   打开文件
    *   带宽
    *   …
*   代码度量
    *   调用图
    *   函数命中计数
    *   循环深度
    *   …
*   硬件指标
    *   CPU 缓存命中/未命中比率
    *   中断计数
    *   …

## 剖析方法

度量标准的多样性意味着收集它的方法的多样性。我有一个很好的层次结构，是的:

*   侵入式分析——更改分析代码
    *   源代码检测
    *   静态二进制仪表
    *   动态二进制仪表
*   非侵入性分析–无需更改任何代码
    *   抽样
    *   基于事件的
    *   竞争

(我知道的方法就这些了。如果你想出了另一个，请随时联系我)。

方法的快速回顾。

源代码插装是最简单的一种。如果您有源代码，您可以向每个函数添加特殊的分析调用(当然不是手动的)，然后启动您的程序。分析调用将跟踪函数图，还可以计算函数花费的时间，以及分支预测概率和许多其他事情。但是通常你没有源代码。这让我成了熊猫。

二进制插装是你可以自己猜测的——你正在修改程序的二进制映像——要么在磁盘(program.exe)上，要么在内存中。这是逆向工程师喜欢做的事情。为了研究一些商业关键软件或分析恶意软件，他们进行二进制检测并分析程序行为。

无论如何，二进制工具在分析中也非常有用——许多现代工具都是建立在顶级二进制工具思想(SystemTap、ktap、DTrace)之上的。

好的，所以有时候你甚至不能插装二进制代码，例如，你在分析操作系统内核，或者一些由许多紧密耦合的模块组成的非常复杂的系统，这些模块在插装后不能工作。这就是为什么你有非侵入性侧写。

当您无法修改任何代码时，采样是您能想到的第一个自然想法。重点是分析器定期询问 CPU 寄存器(例如 PSW)并分析发生了什么。顺便说一下，这是获得硬件指标的唯一合理的方法——通过定期轮询 [PMU](https://dev.toperformance%0Amonitoring%20unit) 。

基于事件的分析是关于收集事件，这些事件必须由分析主题的供应商以某种方式准备/预安装。例如 inotify、Linux 中的内核跟踪点以及 [VTune 事件](http://software.intel.com/sites/products/documentation/doclib/iss/2013/amplifier/lin/ug_docs/GUID-EEC5294C-5599-44F7-909D-9D617DE8AB92.htm)。

最后，仿真只是在一个隔离的环境中运行你的程序，比如虚拟机或者 QEMU，这样你就可以完全控制程序的执行，但是会产生乱码行为。

## 资源

*   [剖析 wikibook](http://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Testing/Profiling)