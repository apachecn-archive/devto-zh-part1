# 不要让重复误导你

> 原文:[https://dev.to/marcosx/dont-let-duplication-mislead-you-e90](https://dev.to/marcosx/dont-let-duplication-mislead-you-e90)

在这篇文章中，我将告诉你我是如何开始理解软件设计原则的，并希望它能给你一些关于如何将它们付诸实践的见解。

# [](#duplication-is-better-than-the-wrong-abstraction)复制胜过错误的抽象

Sandi Metz 是我最喜欢的作者之一，每次我读她写的东西都会改变我对改进代码的想法。最近我一直在想的是这句话:“复制比错误的抽象要好”。

我专业使用的第一种语言是 Ruby，Ruby 社区以让编程变得有趣和创建可读代码而闻名，所以我开始阅读大量关于如何编写优秀代码的书籍/文章。

我学到的第一件事是给事物命名，但是因为命名是一个相当主观的话题，我学到的第二件事真的让我难以忘怀:不要重复你自己！

著名的干原理告诉我，重复不利于维护，所以尽量减少重复。当我听到“复制比错误的抽象要好”时，我的大脑崩溃了。我不得不重启它。

# [](#what-do-i-not-know-about-this-code)这个代码我有什么不知道的？

理解为什么复制比错误的抽象要好其实是“容易”的，我的朋友卢西亚诺·拉马尔霍说过“走路比坐错车好”，我认为这是一个很好的比喻。但是，只有当我面对一个复制的自我，并抵制提取新方法的冲动时，我才意识到为什么复制比错误的抽象更好。

我看了看我刚刚按照无耻的绿色方法写的代码(顺便说一下，摘自 Sandi Metz 和 Katrina Owen 写的令人惊叹的书《99 瓶 OOP 》)

```
def self.create_successful_event(event)
  create(leave_id: event.leave.id,
          name: event.name,
          data: event.to_json,
          status: SUCCESS)
end

def self.create_failed_event(event)
  create(leave_id: event.leave.id,
          name: event.name,
          data: event.to_json,
          status: FAILED)
end 
```

我不只是提取到一个方法，然后把东西作为参数传递，而是对自己说:“关于这段代码，我还有什么不知道的？”。然后我突然想到:复制不是关于两个相似的代码，而是关于一个尚未存在的抽象。

真正的问题不仅仅是重复，事件对象完全暴露了！它作为一个参数传递，然后被完全分解以组成这个 hash 对象，然后传递给 create 方法。

# 其他代码气味可能会有所帮助

关于这段代码，我不知道的是，事后看来很明显，事件对象应该负责构建数据散列。

当一个对象比它自己更关心接收参数时，这通常意味着一个特性放错了地方——这种代码味道被称为特性嫉妒。为了消除原来的重复，我最终做的是在 event 上创建一个新的方法来返回数据散列，然后只是调用它而不是公开对象。

```
def self.create_successful_event(event)
  create(event.data.merge(status: SUCCESS))
end

def self.create_failed_event(event)
  create(event.data.merge(status: FAILED))
end 
```

*我知道数据是一个不好的方法名:/*

# [](#refactoring-with-confidence)自信地重构

我养成了先阅读代码和识别气味的习惯，而不是一头扎进代码中进行改进，我认为这真的帮助我自信地进行了重构。

有许多自动化工具可以帮助识别代码气味，我也尝试使用它们，但是没有什么能打败直觉！花一些时间阅读关于重构、代码味道、设计模式的书籍，特别是阅读代码。

早上花些时间通读你的代码，但是不要急于做出改变，而是把注意力放在各部分是如何组合在一起的。这样你就能建立直觉的基础，理解所有这些设计原则的真正含义。

*这个帖子是[这个 twitter 帖子](https://twitter.com/MarcosBrizeno/status/918486735784464384)T3】的加长版*