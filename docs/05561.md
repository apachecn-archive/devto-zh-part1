# 我学到的关于反应的 3 件基本事情

> 原文：<https://dev.to/tamrrat/3-fundamental-things-i-learned-about-react>

我正在学习 React，我发现 Pete Hunt 的一次演讲是 React 的最佳“鸟瞰”介绍之一(尽管是 2013 年的)。这个演讲帮助我真正概念化了为什么我在制作[我的第一个 React 应用](http://www.tamrat.co/zaha-a-visual-note-taking-app/):)时使用 React

React 上有大量的教程。然而，他们中的许多人只解释了如何反应，而没有充分解释为什么反应。我相信知道任何事情发生的原因，随着时间的推移，会比知道如何发生更有价值。

以下是我在演讲中做的一些笔记:

## 短版

1.  构建组件，而不是模板。

2.  重新渲染，不要变异。

3.  虚拟 DOM 简单而快速。

## 做出反应

*   React 是一个用于创建用户界面的 JavaScript 库。
*   React 呈现用户界面并响应事件。
*   简单说 React 的基本公式就是**函数(数据)=视图**
*   JavaScript 函数接受参数并返回值。类似地，React 组件接收数据(props)作为参数，并返回 UI(view)。
*   然后整个 React 应用程序就变成了**一组函数**的组合，它们共同构成了用户界面(视图)的对象表示。
*   JSX 只是对这些函数的抽象，它只是简单地将文件转化为 DOM 对象的 JavaScript 表示。

## 1。建筑构件，而不是模板

### 答:分离概念实际上是什么意思？

*   分离关注点并不意味着分离技术(即模板)。这意味着**减少关注点之间的耦合并增加内聚力**,而不管技术如何。
*   **耦合**:每个程序模块对其他每个模块的依赖程度。如果你想实现一个特性或者修复一个 bug，并且你对一个模块或者类做了一个改变，为了让这个特性工作，你需要多长时间去你的模块或者代码库的其他部分做一次改变。这种级联变化是耦合的症状，这使得软件难以维护。
*   **内聚**:一个模块的元素属于一起的程度。它基于单一责任原则，基本上意味着将相关的功能组合成模块。试金石是问“这个函数有意义吗？或者“这个函数做了很多事情，你能把它重构为其他部分吗？"

### b .框架不知道如何为你分离你的关注点。

*   它应该只为用户提供强大的表达工具来正确地做这件事。这个强大而富有表现力的工具是一个 **React 组件**。
*   **React 组件** =一个**高度内聚**的 ui 构建块，**与其他组件松散耦合**。
*   React 使用组件将我们的关注点与 JavaScript 的全部功能分开，而不是被模板语言削弱。
*   React 组件是**可重用的、可组合的和可单元测试的**。

## 2。每次更新时重新渲染整个应用程序

*   这是使 React 令人敬畏的关键设计决策。
*   构建 ui 很难，因为有太多的状态。大量的 UI 元素、设计迭代、疯狂的环境、可变的 DOM、用户输入等等。
*   **数据随时间变化是万恶之源**。这真的很难解释。

> 我们的智力更适合于掌握静态关系，而我们对随时间演变的过程进行可视化的能力相对来说还没有发展起来。出于这个原因，我们应该尽最大努力**缩短静态程序和动态过程**之间的概念差距，使程序(在文本空间中展开)和过程(在时间中展开)之间的对应尽可能地简单 Dijkstra

*   简而言之，Dijkstra 说，我们很难想出随时间推移的过程，但对我们来说，追踪程序的流程是相当简单的。
*   因此，我们应该采用随时间推移的过程，并构建抽象，使它们看起来像在单个时间点执行的程序。
*   在 90 年代更简单:当数据改变时，只需刷新页面。
*   现在有了 React，当数据改变时， **React 重新渲染整个组件**。这使得我们很容易思考我们的应用程序处于什么状态。
*   也就是说，React 组件在任何时间点描述你的 UI，就像服务器渲染的 app 一样。
*   对每个变化进行重新渲染使事情变得简单。每个显示数据的位置都保证是最新的，无需显式的 DOM 操作——一切都是声明性的。
*   然而，每次改变都重新渲染是一个昂贵的操作！这就是为什么 React 还附带了一个虚拟 DOM。

## 3。虚拟世界

*   VirtualÂ DOM 可以快速地对每个变化进行重新渲染。
*   你不能扔掉 DOM，然后在每次更新时重新构建它。
*   虚拟 DOM 的构建是为了在执行重新渲染时优化性能和内存占用。
*   每次更新时，React 都会构建一个新的虚拟 DOM 子树，并与旧的进行比较。然后，它计算 DOM 突变的最小集合，并将它们放入队列中，最后批量执行所有更新。

* * *