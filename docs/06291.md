# 构建更好的 REST APIs

> 原文:[https://dev.to/mattcanello/building-better-rest-apis](https://dev.to/mattcanello/building-better-rest-apis)

这个帖子最初发布在[媒体](https://medium.com/@MattCanello/building-better-rest-apis-1204492038a3)上。

* * *

我已经做了将近五年的软件开发人员，大部分时间专注于为应用程序或其他类型的客户端开发后端。这段时间我学到了很多，我想分享一下我在这篇文章中所知道的一些东西。

# [](#first-things-first)先做第一件事

在我们开始之前需要指出的一点是 API 的概念。顾名思义，API(应用程序编程接口)是一种允许外部部分以编程方式与某个应用程序进行交互的方式。当一些第三方软件需要处理来自您的软件的数据时，这是非常有用的，当然，您不希望向他们开放您的数据库。在这种情况下，您可以简单地创建一组服务或操作供他们使用。

当有人构建了一个可以从网络(通常是通过互联网)访问的 API 时，我们称之为 Web API。

设计 web APIs 最常见的标准之一是 REST 架构。REST 定义了一组属性(或规则)来约束 web API 的架构。只要按照那些性质去做，就没问题。我的建议将基本上引导你通过正确的途径获得这些财产。

# [](#the-simplistic-yet-useful-approach)简单化的(然而有用的)方法

你可能认为 REST API 是一个*应答器*。有人(一个客户)问了一个问题，API 听了这个问题，思考了答案，然后对它作出回应。

因此，在设计 REST API 时，您必须记住这个非常简单的流程:

*   请求进来了；
*   API 尽可能快地做它必须做的事情；
*   将响应发送给客户端。

所有不适合这种方法的东西都应该*而不是*留在 API 中。因此，你不应该为诸如定时循环任务、服务器发送的事件或缓存引擎之类的操作使用 API。

除此之外，你应该注意“尽快”的说法。它不是偶然出现的。Web API 不应承载长期运行的任务。Web APIs 通信是建立在 HTTP 请求和响应之上的，很可能所有的客户端都会为这些请求设置一个超时。

多长时间定义为“长”？这取决于你。但是请记住，在网络世界里，一切都应该是快速的。

## [](#designing-longrunning-tasks)设计长期运行的任务

好吧，我不应该在我的 API 上运行一个长时间运行的任务，但是我确实有一个任务要运行。那么，我该如何设计呢？

在我看来，长时间运行任务的最佳设计是接收长时间运行操作的请求，将这个意图存储在某个地方(通常是一个数据库),然后用一个 URL 向请求者返回一个答案，客户端可以在这个 URL 上查询任务的状态(或进度)。

在其他地方，有另一个软件定期查询存储/数据库，获取任务并运行它们，在处理它们的同时更新条目。

在这种情况下，API 可以激活这个外部软件来处理新的请求，但是，当然，不能等到它完成。

尽管如此，我不建议 API 启动一个外部程序，因为它可能会失败。错误配置，权限之类的东西，只要远离以后可能成为问题的东西就行了。

# [](#semantics-matters)语义要紧

HTTP 可能是互联网所依赖的最令人恐惧却又最受欢迎的协议。说到 REST APIs，我认为利用该协议允许的所有优势非常重要。

HTTP 是如此健壮和完整的协议，以至于需要一篇文章来专门讨论它。嗯，这一个不是关于 HTTP 的，所以，我将在这里试着简化事情。

该协议提供了内置的特性，至少适用于您在编写 web 应用程序时可能会遇到的最常见的情况。需要国际化吗？HTTP 有一个名为“Accept-Language”的头来处理这个问题。资源需要授权吗？HTTP 有一个名为“Authorization”的头来处理这个问题。您需要向移动客户端传送压缩数据吗？等等，HTTP 有一个名为“Accept-Encoding”的头来处理这个问题！

到目前为止，我只触及了皮毛。我提到的所有例子都是关于头的，但是 HTTP 有更多的乐趣。

使用 HTTP 谓词，您可以对同一个端点完成不同的操作。假设您想要检索用户的个人资料图片。你能得到它。好的，但是现在用户想要删除它。嗯，可以删除。哦，真可惜，用户想上传新的个人资料图片！可以贴吧。该死的！用户想要替换图片。你可以把它。就是这样。字面意思。对于同一个 URL，将每个动词前的“它”替换掉，仅仅看一下，你就可以推断出这个方法执行的是什么。

这就是我在本节标题中所指的“语义学”。

使用内置的 HTTP 特性，很容易创建包含有意义数据的请求和响应。如果您一直添加专有的头或遵循“总是返回成功，即使它是一个错误”的规则，解析和理解您的请求和响应的过程将会更加昂贵。通过返回一个“自定义错误对象”和一个成功状态代码，用户必须知道它的属性来获取真正的错误。相反，如果您只是返回一个 404 响应，每个人都会很快注意到这是一个未找到的资源。

此外，请记住，API 是用于编程使用的。因此，你放在 API 上的标准内容越多，其他人就越容易使用它。

状态代码是 HTTP 的另一个优秀特性。你可以回复很多信息，只要发送正确的状态码。您可以回复 404 表示没有找到(正如我提到的)，400 表示一个错误的请求，204 表示成功但没有内容，等等。

我将稍微解释一下我最喜欢的状态代码，以及何时应用它们。

## 201–创建于

在我看来，当您响应一个长时间运行的任务被接受时，这是应该返回的正确状态代码。为什么？因为这个响应允许您传递一个名为“Location”的响应头，您应该用所创建资源的位置来填充它。我用绝对 URL 填充这个头，这样客户端可以检查任务的进度。

## 204–没有内容的成功

顾名思义，一切都很好，但是 API 没有内容来回复请求者。我提到这一点是因为这是我在实现删除时的默认响应。如果你请求 API 删除一些东西，那是因为你不想要它了，对吗？

## 400–错误请求

什么是糟糕的请求？！这是一个常见的问题。基本上是无效请求。有些数据不正确或缺失，或者客户请求的操作无法完成，等等。真的，任何 API 不能执行的东西。

## 402–要求付款

是的，你没看错。有一个状态代码。我真的不知道我是否正确地使用了它，但是每当请求的认证用户缺少付款、订阅或类似的东西时，我都会返回这个。

## 404–未找到

这个很简单，对吧？嗯，但是我通常会给这个状态代码赋予另一种含义:找不到*给你*。当用户试图通过 id 选择一个条目时，当条目存在但不属于请求用户时，我倾向于用 404 来响应。因此，请求者可能永远不会真正知道条目是否存在。当然，这不是处理这种情况的正确方法。根据规定，您应该返回 403(禁止的)，但是，我特别不喜欢使用这种方法。

## 401–未授权

每当端点需要身份验证，但客户端没有发送身份验证时，您应该返回此状态代码。此外，您必须用预期的身份验证方案填充名为“WWW-Authenticate”的响应头。如果返回的方案代表基本身份验证，那么最流行的浏览器将自动弹出一个登录对话框，供用户输入其用户名和密码。

### [](#a-side-note-about-basic-authentication)关于基本认证的旁注

基本身份验证将用户名和密码连接在一起，并通过 base64 字符串提交给服务器。这意味着，一旦请求遇到服务器，服务器就可以解码 base64 字符串，以纯文本形式检索原始用户名和密码。这也意味着客户机/请求者和服务器/API 之间的任何人都可以解码。所以请，请，只使用 SSL 的基本认证。好吧，无论何时你需要处理敏感的用户数据(例如地理位置、登录、注册表单、支付表单)，你都应该通过 SSL 与服务器通信。说真的，没那么贵。

## [](#provide-significative-urls)提供有意义的网址

另一个有趣的特性是有意义的 URL。对那些不知道你的应用的人来说很有意义。例如，当构建 API 时，您可以将操作分组到与它们相关的实体下；因此，与客户相关的所有内容都将位于/Customers URL 下。在跟踪客户端和 API 之间的错误时，这很有帮助。

# [](#consistent-behavior)行为一致

有些人认为一致的行为意味着无论请求是成功还是失败，总是独立地返回相等的答案对象。不。一致的行为代表可预测的反应情况。同样，API 是为以编程方式使用而构建的，因此当有人为此实现客户端时，所有可能的响应都清晰且有据可查是非常重要的。如果你得了 400 分，就这样读；收到一张 200 的时候，这样念；等等。

我猜这就是肥皂和休息的本质区别。在 SOAP 架构中，只需查看它的 WSDL，就可以马上知道响应结构。在 REST 架构中，您没有这种能力，但是它允许一种更加灵活的方式来处理数据。虽然即使没有像 WSDL 那样的合同，我相信保持一定程度的可预见性也是很重要的——这些都是必需的信息；这些可能会被忽略；等等。这对客户端和服务器双方的发展都有好处。

# [](#every-request-is-a-different-request)每个请求都是不同的请求

与许多其他类型的 web 应用程序不同，REST APIs 被设计成无会话的。这意味着除了动作本身的信息之外，每个请求必须包含用于识别客户端或用户(或两者)的所有必要信息。

有时数据长度或数据安全性是一个问题，因此一个替代方法是建立一个基于令牌的标识。您使用 API 服务登录用户，该服务提供一个惟一的令牌来标识下一个请求中的用户。因此，一旦登录，客户端就在所有后续的 API 调用中发送这个令牌，而不是总是发送用户名和密码。

## [](#a-side-note-about-unauthorized-password-storing)关于未授权密码存储的一个旁注

当您创建一个提供用户登录的 API 时，您应该知道，如果客户端需要，它可以存储用户输入的密码，因为用户是在它的软件中输入的，而不是直接在 API 中输入的。

因此，如果你不打算信任使用你的 API 的第三方应用，你应该*而不是*在你的 API 中写一个登录服务。另一种方法是将用户带到您的站点，让用户在您的 web 应用程序中键入他或她的凭据，您可以完全控制它，然后回调第三方通知用户的令牌。这就是脸书和 Twitter 如何完成他们的用户认证的，尽管他们有可供开发者使用的 API。

另一种选择是简单地不要你自己的用户认证。一旦你不为你的用户存储任何密码，你就不需要担心保护他们。

# [](#performance)表现

正如我之前提到的，API 应该尽可能快地响应请求。你应该明白不仅仅是你的 API 中的时间有价值。您必须计算网络延迟的总和，并考虑客户端应用程序在接收来自 API 的响应时也运行一些代码。

因此，您可以采用一些技术来提高性能，但我将重点介绍其中的两种:缓存和多线程管理。

## [](#caching)缓存

如果你不应该在你的 API 中保留一个缓存服务，因为它不适合 API 工作流，也没有必要每次都去数据库获取可用国家或货币的列表，因为它们几乎从不改变。缓存这些数据非常重要，因为让代码远离数据库可以极大地提高性能。

因此，我将指出三种缓存这些数据的方法，即使您正在实现一个 API。你必须根据具体情况选择正确的方法。

### [](#caching-service)缓存服务

缓存服务基本上是一个只管理缓存的软件。有几个选项可供您选择(有些是免费的，有些是付费的)，或者您可以自己实现一个。我广泛建议你选择一些已经创建的替代方案，因为他们可能已经考虑过一些你可能会忘记的情况。

当使用缓存服务时，您将查询该服务来检索您需要的数据，而不是去数据库。因此，正如您可能观察到的，当所有请求都必须通过您的代码运行时，这是最好的方法。

### [](#web-server-caching)Web 服务器缓存

另一个选择是配置您的 web 服务器来缓存确定端点的响应。这可以防止所有的请求接触到您的代码。因此，注意到通过 web 服务器缓存响应可能不会运行您的代码，这一点很重要。

### [](#clientside-caching)客户端缓存

我向您展示的最后一个选项是客户端缓存。利用与缓存相关的响应头，您可以设置客户端可以理解的响应信息，从而避免再次调用 API*。在这种方法中，客户端甚至不会对 web 服务器执行真正的请求，所以它肯定不会运行您的代码，因为它根本不会到达服务器。*

 *## [](#multithread-management)多线程管理

多线程是一个非常复杂的主题，仅讨论这一点就需要一整篇文章。因此，正如我对 HTTP 协议所做的那样，我将在这里简化事情。

REST APIs 天生就是多线程的，一旦它们可以同时执行多个请求。因此，每次你让一个线程同步等待某个东西，你都在浪费 CPU 时间，因为那个线程可能被用来处理另一个请求。

许多开发人员利用异步方法，但并没有真正理解它的本质。基本上，每个不在 CPU 上运行的动作都可以异步执行。电脑上除了 CPU 还有什么运行代码？驱动程序:从磁盘读写操作到键盘输入。

当你通过互联网发送一个 web 请求时，它需要 CPU(因为 TCP 利用 CPU)，但是这个过程的最大部分是由你的网卡驱动完成的。因此，这可以异步完成。当运行异步代码时，操作系统知道该线程正在等待什么，然后它可以使用该线程来运行一些需要在 CPU 上运行的代码，避免创建新线程，从而避免浪费内存和时间。

这就是利用异步方法有助于提高 API 可伸缩性的原因。

幸运的是，许多最常见的服务器端编程语言通过利用 *async* 和 *await* 关键字来帮助您编写异步方法。这样，编写一些异步执行但看起来像同步的代码就容易多了。

# [](#conclusion)结论

嗯，这些是我认为每个 web API 开发人员在构建 REST APIs 时应该知道或记住的重要内容。

我希望这篇文章能帮助你成为一名更好的开发人员。

感谢您的阅读。*