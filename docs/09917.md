# 编程概念:垃圾收集

> 原文:[https://dev . to/the code boss/programming-concepts-garbage-collection](https://dev.to/thecodeboss/programming-concepts-garbage-collection)

这篇文章最初发表在[我的个人网站](https://thesocietea.org/2017/01/programming-concepts-garbage-collection/)。如果您喜欢它，请查看该链接以获得本编程概念系列中的更多帖子！

继续这个系列，今天我们将谈论垃圾收集(GC)——它是什么，它是如何工作的，以及它背后的一些算法是什么。现在我只想说，有人比我聪明得多，他们可以给你关于特定语言如何实现 GC、什么库改变了它的标准等等的基本细节。我在这里试图完成的是给你一个整体开发的鸟瞰图，希望你能学到一些你以前不知道的东西——如果它真的让你感兴趣，那么我希望你继续搜索，找到那些深入研究具体 GC 实现的帖子。在这里，我们将坚持大约几英尺深，所以让我们开始挖掘。

## 什么是垃圾收集？

就其核心而言，GC 是一个自动化内存管理的过程，这样作为开发人员，您就少了一件担心的事情。当你分配内存时——比如通过创建一个变量——内存被分配给堆栈或堆(如果你想了解更多关于这两者的信息，请查看我关于[堆栈与堆](https://thesocietea.org/2014/10/programming-concepts-the-stack-and-the-heap/)的文章)。当你在一个局部范围内定义东西时，你分配给栈，在这个范围内你确切地知道你需要的内存块大小，比如原始数据类型，一个固定大小的数组，等等。堆栈是一个自我管理的内存存储，您不必担心——它自己分配和清除内存的速度非常快。对于其他内存分配，如对象、缓冲区、字符串或全局变量，您分配给堆。

与堆栈相比，堆不是自我管理的。分配给堆的内存将在整个程序运行期间保持不变，并且可以在您手动分配/释放内存时随时改变状态。垃圾收集器是一种工具，它消除了手动管理堆的负担。大多数现代语言，如 Java。NET 框架，Python，Ruby，Go 等。都是垃圾收集的语言；然而，C 和 C++不是，在这样的语言中，开发人员手动管理内存是一个非常重要的问题。

## 我们为什么需要它？

GC 帮助开发者避免了几个与内存相关的问题——最重要的是[内存泄漏](https://en.wikipedia.org/wiki/Memory_leak)。当你给堆分配越来越多的内存时，如果程序在它变得不再需要时没有持续释放这些内存，内存大小将开始增加——导致[堆溢出](https://en.wikipedia.org/wiki/Heap_overflow)。即使开发人员很努力地管理堆内存——只要有一个变量始终未被删除，就会导致内存泄漏，这是很糟糕的。

即使没有内存泄漏，如果您试图引用一个已经被删除或重新分配的内存位置，会发生什么呢？这叫做[悬空指针](https://en.wikipedia.org/wiki/Dangling_pointer)；这里最好的情况是，在使用该变量后不久，您将返回乱码，并有希望抛出或导致验证错误——但没有什么可以阻止该内存位置被新数据覆盖，新数据可能会以看似有效(但逻辑上不正确)的数据进行响应。你不知道会发生什么，而这类错误——内存错误——通常是最难调试的。

这就是我们需要 GC 的原因。这对所有这些都有帮助。它并不完美——它确实会消耗你机器上的额外资源来工作，并且它通常不如适当的手动内存管理有效——但是它为你节省的问题使它物有所值。

## 垃圾收集器如何以及何时运行？

这完全取决于 GC 使用的算法。没有一种简单快速的方法可以做到这一点，就像编译器和解释器一样，GC 机制会随着时间的推移变得越来越好。有时垃圾收集器会以预先确定的时间间隔运行，有时它会等待某些条件出现后才运行。垃圾收集器几乎总是与你的程序一起运行在一个单独的线程上——根据 GC 语言的实现，它可以暂停你的程序(即停止垃圾收集器)以一次清除所有垃圾，增量运行以删除小批，或者与你的程序同时运行。

如果不深入研究 GC 的特定语言实现，就很难更深入，所以让我们转到常见的 GC 算法。

## 垃圾收集算法

有很多不同的 GC 算法——但这里有一些你会遇到的最常见的算法。有趣的是，我们注意到这些常见的算法有多少是建立在彼此之上的。

### 参考计数

[引用计数](https://en.wikipedia.org/wiki/Reference_counting)可能是 GC 最基本的形式，也是最容易自己实现的。其工作方式是，每当您引用堆上的某个内存位置时，该特定内存位置的计数器就会加 1。每次删除对该位置的引用，计数器就减 1。当计数器达到 0 时，这个特定的内存位置就被垃圾回收了。

通过引用计数进行 GC 的一个很大的好处是，它可以立即判断是否有垃圾(当计数器达到 0 时)。然而，引用计数存在一些主要问题；循环引用不能被垃圾收集——这意味着如果对象 A 引用了对象 B，而对象 B 又引用了对象 A，那么根据引用计数，这两个对象都不能被垃圾收集。除此之外，引用计数非常低效，因为每个内存位置都要不断地写入计数器。

由于这些问题，其他算法(或者至少是引用计数的改进版本)在现代 GC 中更常用。

### 标记-扫描

标记-清除——以及除引用计数之外的几乎所有现代 GC 算法——是一种形式的[跟踪](https://en.wikipedia.org/wiki/Tracing_garbage_collection) GC 算法，它涉及跟踪哪些对象可以从一个或多个“根”到达，以便找到不可到达的(因此是未使用的)内存位置。与引用计数不同，这种形式的 GC 不是不断地检查，理论上它可以在任何时间点运行。

最基本的标记扫描形式是[简单标记扫描](https://en.wikipedia.org/wiki/Tracing_garbage_collection#Na.C3.AFve_mark-and-sweep)；它的工作方式是在每个分配的内存块上使用一个专门用于 GC 的特殊位，并运行两次当前在堆上分配的所有内存:第一次通过该特殊位标记死内存的位置，第二次清除(即解除分配)这些内存位置。

标记-清除比引用计数更有效，因为它不需要跟踪计数器；它还解决了不能移除循环引用的内存位置的问题。然而，天真的标记-清除是停止-世界 GC 的主要例子，因为整个程序在运行时必须暂停(非天真的跟踪算法可以增量或并发运行)。因为跟踪 GC 可能在任何时间点发生，所以您永远不知道这些停顿中的一个会在什么时候发生。堆内存也迭代了两次——这会进一步降低程序的速度。最重要的是，在标记清除中，没有对碎片内存的处理；为了给你一个直观的表示，想象画一个完整的网格来表示你所有的堆内存——标记-清除 GC 会让这个网格看起来像一个非常糟糕的俄罗斯方块游戏。这种碎片化几乎总是导致堆上内存分配效率较低。因此，我们继续优化我们的算法。

### 标记-紧凑

[标记-压缩](https://en.wikipedia.org/wiki/Mark-compact_algorithm)算法从标记-清除中提取逻辑，并在标记的内存区域上至少增加一次迭代，以压缩它们，从而对它们进行碎片整理。这解决了标记-清除导致的碎片问题，通过使用“碰撞”分配器(类似于堆栈的工作方式)可以显著提高未来分配的效率，但由于额外的迭代，在 GC 运行时会增加额外的时间和处理。

### 复制

复制(也称为 [Cheney 的算法](https://en.wikipedia.org/wiki/Cheney%27s_algorithm))与标记压缩略有相似，但不是在单个内存区域上进行多次迭代，而是在标记阶段之后，将该区域的“幸存”内存块复制到一个全新的空区域中，从而在默认情况下压缩它们。复制完成后，旧的内存区域被释放，所有对幸存内存的现有引用将指向新的内存区域。这减轻了 GC 的大量处理工作，并且将规格降低到比标记-清除过程更快的程度，因为清除阶段被消除了。

虽然您已经提高了速度，但是您现在需要一个完全可用的内存区域，其大小至少与所有幸存的内存块一样大。此外，如果您的大部分初始内存区域包括幸存的内存，那么您将复制大量数据-这是低效的。这就是 GC 调优变得重要的地方。

### 辈分

[分代 GC](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#Generational) 采用复制算法的概念，但它不是将所有幸存的成员复制到一个新的内存区域，而是根据内存的年龄将内存分成分代区域。分代 GC 背后的基本原理是，通常情况下，年轻内存的垃圾收集频率要比旧内存高得多，因此，年轻内存区域的扫描频率要比旧内存区域高得多，以检查未引用的内存。如果处理得当，这将节省时间和 CPU 处理，因为目标是只扫描必要的内存。

旧的记忆区域当然仍会被扫描——但不像新的记忆区域那么频繁。如果较新的内存区域中的内存块继续存在，则可以将其提升到较旧的内存区域，并且扫描的频率会降低。

## 最后的想法

GC 并不是最容易完全理解的话题，在使用现代语言进行开发时，你甚至不需要理解它——但是仅仅因为你不需要知道它，并不能给你一个不学习它的好借口。虽然它不会影响您编写的大部分代码，但它是每种语言实现中不可或缺的一部分，实现的垃圾收集器背后的算法往往是人们喜欢或不喜欢某些实现的一个重要原因。如果你一直和我在一起，那么我很高兴——我希望你学到了一些东西。如果您对此感兴趣，我鼓励您继续关注 GC——[这里有一个有趣的资源](https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/),它向您展示了一些不同 GC 算法如何可视化工作的动画 gif。

有趣的是，在研究这个主题的时候，我看到的绝大多数帖子都在谈论 GC 是如何专门针对 Java 的主要实现工作的。GC 当然不是 Java 的专利，但是我想这是因为 Java 经常比 C++重很多倍，c++不进行垃圾收集。希望随着时间的推移，更多关于 GC 如何在其他语言中工作的帖子会变得流行起来——但是现在，我们将尽我们所能！