# 合理期望原则

> 原文:[https://dev . to/ruidfigueiredo/principle-of-reasonable-expectations](https://dev.to/ruidfigueiredo/principle-of-reasonable-expectations)

设计领域有一个非常优雅的原则叫做*最小惊奇原则*。有时它也被称为*最小惊奇原则*。这意味着你不应该做一些让用户惊讶的事情，比如让关闭按钮打开一个新页面，这是许多垃圾网站使用的伎俩。

这个原则在设计中非常重要，因为它有助于指导创作过程。它保证了产生的设计更易于使用。

这个原则的一个优点是它非常容易理解，我们可以立即联想到我们认为它被违反的情况。

在软件领域中有一些原则，它们的目标也是引导最终产品进入一种状态，在这种状态下，它具有一些期望的属性，通常是易于阅读和易于承受变化。

不幸的是，软件比设计更抽象。这很难想象。它的原则经常被误解，人们倾向于从口头上学习。例如，坚实的原则。你认为你认识的大多数开发人员都读过介绍他们的原始论文吗？

例如，我看到单一责任原则被用于最奇怪的事情。我最常听到的一个理由是，把所有关系很远的东西放在一个类中，这几乎与原则的意思相反。

也许我们需要更简单的原则。

这并不是说我们不需要已经有的，但是也许我们可以看看其他领域，把它们的原则应用到软件中，特别是那些我们可以可视化和关联的领域。这些可能对程序员新手特别有用，因为它们很容易理解。

最小惊奇原则肯定是其中之一，而且通常人们已经在软件设计中使用它了。

另一个可能有用的原则(据我所知，这个原则还没有在软件中使用过)是合理预期原则。

这是一个法律原则，合同应该被解释为一个理性的人(没有受过法律训练的人)会如何解释它。它有利于弱势方(通情达理的人)客观上合理的期望，即使合同语言没有明确支持这些期望。

这个原则强调契约的“消费者”,在软件中，我们可以与维护或使用代码的人相提并论。而且这个人和写它的人不一定是不同的人。如果有足够的时间，甚至我们写的代码也会变得和别人的一样陌生。

原则是我们不应该违背合理的期望。以下是一些例子:

在早期版本的 jQuery UI(例如 1.8)中，如果你想检查一个对话框是否打开，而它没有打开，那么这个方法将返回被查询的 DOM 对象而不是 false，例如:

```
var isOpen = $('#theDialogContainer').dialog("isOpen");
if (!isOpen) //isOpen is a DOM object
    $('#theDialogContainer').dialog(); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

如果这是一个按钮的 click 处理程序，它将永远不会打开对话框，因为 JavaScript 是如何计算条件的。它使用 [falsy 和 truthy 值](http://www.sitepoint.com/javascript-truthy-falsy/)，一个 DOM 对象是一个“truthy”值。

人们几乎可以说，虚假值和真实值的概念违反了合理预期的原则，但是，因为这是 JavaScript 开发人员的常识，所以它属于灰色区域。然而，如果上面的代码片段这样重写，没有人会输

```
var isOpen = $('#theDialogContainer').dialog("isOpen");
if (isOpen === false) {
    $('#theDialogContainer').dialog(); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

其他的例子包括该方法所做的事情对于某些人来说是不合理的，例如，想象你正在使用一个 API 来控制元素的网格(想象一个具有动态网格/结果表的网页)。如果调用这个函数:`grid.select(element);`，包含`element`的行会高亮显示，页面会滚动到该行。第二部分，页面滚动到行，并不是 API 的消费者仅仅通过读取方法名就能预料到的。

让我给你举个例子，说明这是如何成为问题的。

假设您想要实现过滤。每次用户过滤结果时，之前选择的元素都可以被过滤掉。如果发生这种情况，您希望网格的第一个元素被选中。使用`select`函数来实现这一点是非常合理的。

到目前为止，即使添加了过滤功能，使用`select`函数的人也不太可能注意到它不仅突出显示了元素所在的行，还导致页面滚动到该元素。这是因为过滤器在页面的顶部，当它们被使用时，第一个元素也是可见的，所以滚动功能没有可见的效果。

随着时间的推移，一个新的需求出现了，即常用过滤器需要键盘快捷键。现在，用户可以在页面的任何地方过滤结果。如果用户滚动到页面底部并使用快捷方式过滤结果，页面有时(当选择的元素被过滤掉时)会跳到顶部。

负责解决这个 bug 的人可能会首先在处理触发过滤的键盘快捷键的代码中寻找它。当失败时，也有可能最终当处理过滤的代码被查看时，`select(element)`方法不被认为是罪魁祸首。这是因为期望(除非解决 bug 的人熟悉实现)选择一个元素会导致页面滚动到包含该元素的行是不合理的。

这个问题可以通过将这个函数分成另外两个函数来解决，并以一种清晰的方式命名它们，例如，`grid.highlight(element)`和`grid.scrollTo(element)`。

这个例子很好地说明了为什么我认为这个原则有地位，即使它看起来与最小惊讶原则相似。很容易想象编写`grid.select`函数的人会说，当元素被选中时，页面滚动到包含该元素的行并不奇怪。然而，假设不熟悉`select`方法实现的人期望它有那样的行为是不合理的。

这条原则的另一个有用之处是，如果某样东西没有提供合理的预期，那么它就是违反了这条原则。因此，将`functions`命名为例如`handleTriggerFailed`将违反原则，因为代码的读者无法从该方法名称中推断出太多信息。其他适用于类名的例子:`AbstractService`、 [SomethingManager](http://blog.codinghorror.com/i-shall-call-it-somethingmanager/) 、`SomethingHelper`等。

合理预期原则将重点放在代码读者可能拥有的解释上。它强调了这样一个事实，即代码的主要目标受众首先是人，然后是编译器。如果不是这样，我们都还在写汇编。