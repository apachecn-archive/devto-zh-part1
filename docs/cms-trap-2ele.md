# CMS 陷阱

> 原文：<https://dev.to/maxim/cms-trap-2ele>

## 比喻

很多年前有一个 Rails 应用。事情开始了。这些东西实际上是其他东西的蓝图。其他东西需要许多相关的零件，零件的零件。多少？蓝图知道。蓝图绝对需要有一个管理界面，但是改变蓝图会导致事物和部件的连锁反应。对事物及其蓝图的每一次修改都渗透到各种模型的耦合网络中。随着各部分继续扩展成更多的实体，管理 UI 的复杂性迅速飙升。它达到了蓝图必须有可串行化的、持久的逻辑片段的地步。在这一点上，每个功能都变得很难实现，因此应用程序退化到完全不可维护的状态。感觉好像有一个“内容管理系统”挡在了完成事情的路上，把自己作为特性和实现之间的中间人。就好像这个系统实际上迫使所有的业务逻辑根据这个更高层次的抽象来重新构建。

最糟糕的部分？对于一个新生的创业公司来说，这是一个最小的可行产品。

## 偶 CMS

[![Complexity](img/7277860feae095dc7a98f9e5937b2e3f.png "Complexity")](https://res.cloudinary.com/practicaldev/image/fetch/s--UHNOZlda--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://hakunin.s3.amazonaws.com/assets/cms-trap/complexity-62e80ab4b611fcf63200b8f9a12e63da75a264320444901b5717c704fc554781.png) 

图片<sup id="fnref:1">[1](#fn:1)</sup>by[Nero vivo](https://www.flickr.com/photos/dominik99/384027019/)

程序员的天性鼓励我们沉迷于解谜和抽象概念建模。正是这种激情让我们看不到即将到来的危险，看不到由于我们的主观臆断和模糊的猜测而陷入的陷阱，看不到为了自身利益而构建一个过度设计和过度复杂的系统的陷阱。CMS 陷阱。我们遭受着各种各样的后果，从精疲力竭、丧失热情，到错过最后期限、生意失败，然而我们似乎从来没有直接谈到这个错误。在饮水机旁边的某个地方，一位有经验的同事不经意地指出，你可能把事情过于复杂了。在 IRC 聊天中的某个地方，你被嘲笑为一个很可能永远不会公开的项目问了一些关于复杂对象模型的问题。然而，没有人能清楚地解释到底什么是潜在的思维过程。这些漫不经心的评论是我们在这个问题上得到的所有教育，人们最终以艰难的方式学习这个。这就是为什么我想解释一下这种现象。首先，这是我对 CMS 陷阱的最好定义。

***CMS 陷阱是网络应用程序的一种状态，其中内容管理系统的开发阻碍了内容的开发。*T3】**

如果你和我一样正在创业，你应该知道这个陷阱在前期特别危险。只有一小部分公司能够进行长期的博弈，到那时，他们的问题已经转移到了一个完全不同的层面上。虽然这些公司也可能会落入 CMS 陷阱，但他们可能负担得起，即使不是有意追求这一方向。在这里，我想把重点放在更丰富的种类上:小公司。一旦你向大量客户敞开大门，他们会开始使用你的项目，并为你提供真正的分析和反馈，这个问题就会变得很明显。在这一点上，你的项目将不再被你的直觉所驱动，而是你将有真实的数据来建议如何进行，指示下一步要实现哪些特性。这将是您所有最初的架构假设都被测试的时候，并且现实开始出现。现实是没有机智的，当你看到你充满希望的应用程序设计时，它不会放过你任何痛苦的事实。你会希望你可以重构，但是为时已晚，因为你将被迫跟上新的特性，并且在生产力下降的螺旋中实现它们只会变得更加困难。

## 我以后再感谢我

> "我们的大多数假设都已经过时了。"
> 
> <cite>马歇尔·麦克卢汉</cite>

简单地说，我们喜欢设计系统。一旦我们对一个问题形成了某种理解，我们就会冲向我们的`/(?:whiteboards|moleskines|mindmaps|editors)/`,开始热情地定义实体及其相互作用。感觉很好，这是我们最擅长的。我们处理一些关于项目的最基本的决定。然后，在仔细地概述了我们的假设之后，我们就致力于这些假设。我们喜欢认为我们在早期的决定中播种了智慧和灵活性，并且 _ 我们将在以后感谢我们自己 _。有了所有这些有用的扩展点和良好表示的实体，还有什么可能出错呢？现实是，这些早期的假设很可能会限制我们的未来，而不是扩展它。当我们见到老朋友的那一天到来了，那个无辜的“过去的自己”从编辑那里盯着我们，骄傲地微笑着。这个善意的人花费了数小时、数天、数周的时间将我们的努力转移到了投机架构(T2)的深渊，而对我们将面临的真正问题几乎没有任何概念。我们现在被困在所有这些“有用”的代码中。这就好像你决定做一些沙拉，但你面前不是摆放着单独的配料，而是一个陌生人给你的另一份完全煮熟的沙拉，你现在被迫翻箱倒柜，希望能找到一些你需要的东西。

在编程中，你过去的自己只不过是一个有边界问题的陌生人。

本着同样的精神，想象你回到电脑前，却发现你的应用程序被某个毫无头绪的陌生人以与现实毫无关系的方式重组了。这与我们发现自己在看一个我们过去过度模仿的系统没有太大的不同。难道您不希望不必处理这些垃圾，而是可以根据您的业务需求简单地开辟前进的道路吗？

回到我的个人故事，我最终意识到，对于每一个新的业务特性，我花了更多的时间去思考如何将它融入我强加给自己的现有框架中，而不是实际设计该特性。你可能已经猜到了，我非常感谢自己如此体贴。

## C < RUD

> “读代码比写代码难。”
> 
> <cite>乔尔·斯波尔斯基</cite>

谈论架构很像谈论代码本身。这并不是说我们永远不能关注未来，只是几率对我们不利。代码易于编写，很难更改或删除。我们随意加入的每一句台词最终都会用一个永恒的问题来嘲弄我们:“猜猜如果你碰我，什么会碎？” [![troll](img/78b36af4efb85082802889b6720914b7.png "troll")](https://res.cloudinary.com/practicaldev/image/fetch/s--FXMgYqpf--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://hakunin.s3.amazonaws.com/assets/cms-trap/troll-d177581441d17b0cbe254108fe4bdc3550076afd436e4988acb4fdbe5c644f87.png) 。架构决策就像代码一样，很容易做出，也很难取消。虽然在代码中这个问题通过测试得到了缓解，但是在架构中我们没有测试。我们对质量的唯一衡量标准实际上是我们在开发一个新功能时感受到的痛苦，而到那时往往已经太晚了。糟糕的架构会窒息你的业务，即使你的代码有 100%的测试覆盖率。

## 报警触发器

[![Fire Alarm](img/05da31c84f6733cb1160fcf38bf2bb5d.png "Fire Alarm")](https://res.cloudinary.com/practicaldev/image/fetch/s--VjnOsM2F--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://hakunin.s3.amazonaws.com/assets/cms-trap/alarm-4ecbe9c92992c9a35960bc9030e39acdf26eb3e9ac0d54f39e6c17a15922e616.png) 

图片 <sup id="fnref:1:1">[1](#fn:1)</sup> 作者[费·易勒雅斯](https://www.flickr.com/photos/renneville/3513553401/)

和大多数陷阱一样，没有具体的方法知道你什么时候会掉进陷阱。你所能期望的最好的情况是得到某种“提示”,警告你即将到来的危险。下面我列举了一些我亲身经历的故事。在你的早期项目中看到这些至少会让你产生怀疑。

### 早发的保守主义

> "一个没有变革手段的国家也就没有保护手段."
> 
> <cite>埃德蒙·伯克</cite>

比方说你面临一个新的特征，而你发现它是一个真正的 [yak 刮](https://programmers.stackexchange.com/questions/34775/correct-definition-%0Aof-the-term-yak-shaving)。你意识到这需要一个巨大的重构，而你正在为如何*避开它*而争论。在为了效率而协商特性需求和因为陷入遗留体系结构的意外累积而协商特性需求之间，有一条很细的线。会不会是因为你早期的投机性设计决策开始影响到了今天的实际业务需求？你是不是在太短的时间内建立了太多的项目，而这些陷阱的出现是否只是时间问题，是否会让你的项目陷入瘫痪？不要误会，保守往往是抵御不必要复杂性的健康防御，这是有经验的开发人员的标准做法。问题在于，在项目生命周期的早期，防御措施过多。这肯定会引起一些怀疑。

### 德鲁巴综合症

> “嗯，我们的定价规则对于不同的产品是不同的，所以我们需要找到一种方式让管理员在管理面板中定义这些规则。也许我们应该将代码存储在数据库中并对其进行评估？”

这是走进 CMS 陷阱的典型标志。你正试图想办法让管理程序一些逻辑，然后应该保存到数据库中。如果不是因为管理界面，只需要几行代码就可以完成。然而，现在我们正在讨论创建与规则相关的价格模型，以及由此产生的所有复杂性。对定价功能的任何进一步扩展，本来可以用一两行代码实现，现在必须采用数据库迁移、表单、验证和这个兔子洞里的所有其他东西的形式。此时，您真的需要定价规则的管理用户界面吗？

### 种子虚弱

你如何将你的产品分为 10 类？典型的答案包括创建一个`Category`模型，然后编写一个脚本，该脚本将播种 10 个指定的类别，这些类别将被分配给产品。然后，您要确保每个开发人员都运行这个种子文件。当然，不要忘记在生产中运行它。每次部署时。每拉一次。当设置新机器时。运行测试时。当然，如果你改变了种子文件中的一些东西。

如果您的早期应用程序依赖于大量的种子数据，那么您就走上了不归路。在这一点上，可以假设为常量的东西不需要被建模为数据库支持的实体，但是我稍后会回到这个问题上。

### 条条大路通魔多

> “一个不简单地实现业务逻辑”
> 
> <cite>博罗米尔</cite>

这有点类似于早期的保守主义，但还是有区别的。你有没有发现自己被一件琐碎的任务吓倒过？问问你自己:如果这个任务被孤立地执行，没有应用程序的其他部分围绕着它，它会令人生畏吗？如果答案是肯定的，那就看看你的脚，因为你可能会被陷进去。在一个架构良好的系统中实现一个特性不应该比孤立地实现它更困难。

### 幻痛

有时，CMS 陷阱可以通过出现来自新兴 CMS 的隐藏暗示的幻象痛苦来识别。例如，在现实中，您永远不需要删除您的类别，但是因为您将它们构建为管理员可编辑的数据库支持的记录，所以您突然想到了删除它们的不存在的场景。你的建筑冒昧地让你思考一个不真实的场景。你最终面对的是虚假的痛苦，虚幻的痛苦。

## 预防

[![Line in sand](img/e9b024e6b2cf152204323be95269979b.png "Line in sand")](https://res.cloudinary.com/practicaldev/image/fetch/s--vzbioL_f--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://hakunin.s3.amazonaws.com/assets/cms-trap/line-in-sand-ad508a85af4cb6a9f65bcf96faaadab36c42e2e93572549977166b6f14a0104f.png) 

图像 <sup id="fnref:1:2">[1](#fn:1)</sup> 由[亨利地洞](https://www.flickr.com/photos/foilman/9539213885/)

以上所有症状都有共同点。它们都是导致复杂系统的早期假设的产物。在这一点上，回答两个问题是有用的:“什么是复杂系统？”以及“如何在不做假设的情况下编程？”。

为了这篇文章的目的，我们假设一个复杂的系统是一个由网络节点组成的系统，它包含的节点和连接比你通常在大脑中所能追踪到的要多。显然，要得到一个低复杂度的系统，你需要减少节点和连接的数量。至于后一个问题，这就是我要说的重点。为了在不做早期假设的情况下编程，你必须**避免在运行时**做事情。

我来详细说明一下。被过度建模弄得伤痕累累后，我发现有一个原则应该成为所有决策的基础。让我们称之为:*保持静态，愚蠢的*，这看起来很合适，因为它实际上只不过是保持简单的一个稍微有架构意识的即兴重复。

静态化是避免过早优化的架构等价物。

这个原则的美妙之处在于，它适用于每一个抽象层次，不管你谈论的是视图、数据库还是代码。这个想法本身很简单:如果有疑问，就静态地去做。通过查看一个典型 Rails 应用程序的不同层次上的一些具体示例，更容易理解这意味着什么。

### 能用一个类解决吗？

在这篇文章的前面，我提到了定价规则。这是一个常见的问题，每个产品可能遵循不同的定价算法。价格可能取决于数量、当前用户(想想忠诚计划)、订单历史、优惠券和各种其他东西。为了避免 CMS 陷阱，我强烈建议你不要在早期运行时构建这类算法。编写一个定价方案类。*使用[策略模式](https://en.wikipedia.org/wiki/Strategy_pattern)* 。使定价算法在代码级别可交换。通过你的编程语言定义定价规则，这样逻辑的复杂性可以直接映射到代码中，而不需要整个抽象层。

编程语言已经有了许多优秀的工具，比如条件和循环。为什么要在更高的抽象层次上重新实现它们呢？这些工具足以让您通过直接编写代码来构建复杂的定价逻辑。一旦您将多个定价算法编写为可插入的对象，请随意让管理员选择其中一个，甚至可以通过将因子和关键值插入到您的算法中来“填充空白”，但是可以根据需要逐步发展此功能。随着时间的推移构建您的管理 UI，为您的策略对象注入越来越多的运行时灵活性。记住，你总是可以把静态/硬编码的东西变成动态的，但是反过来就不行了。你在运行时所做的一切调整都会给你从那时起所做的每一个决定带来复杂性，并增加你无法预见的错误的机会，即使是在你的应用程序看似不相关的部分。

### 可以用静态页面解决吗？

假设你在一个页面上列出一些东西给顾客看。这些东西很可能是产品、照片或文件，无论你正在做什么。现在，你可能已经决定在每一个元素上都有一个标题，一个描述，一张图片，也许还有作者或者品牌。您已经将您的实体分成了这些数据字段，并决定构建数据库支持的模型。在这里，我建议停下来，考虑一下你是否有充分的理由为什么它不能是一个静态页面。静态模板化视图意味着为了改变事物，你必须编辑视图并部署，是的，但是它也意味着你没有控制器、模型、迁移、表单、管理 UI 或任何其他东西。事实上，如果你使用 Github，你可能还会有一个管理用户界面。虽然没有想象中那么真实，但也还过得去。人们可以直接在 Github 上编辑视图，没有太大问题。

如果你列出的东西是按照一定的规则进行分类和布局的，这就更成问题了。在动态方法中，这将立即迫使您创建一个相关模型的网络来呈现这种页面。考虑一下在这一点上你对自己未来的需求知之甚少，以及你对未来的推测会受到多大的限制。想想看，坐下来硬编码这一页会有多快多容易。就像 strategy pattern 的情况一样，当真正的需求出现时，您可以随时向这个页面注入动态内容。如果你马上建立一个动态系统，你很可能会被它所束缚。宁可静态。

### 能用常数求解吗？

回到种子数据问题，这个例子相当简单。您正在创建类别。这些类别是预定义的。与其添加模型、表和种子数据，为什么不简单地用一个数组做一个常量呢？代码允许您在不涉及数据库的情况下携带静态数据。使用它，直到你真正需要在运行时编辑类别。到那时，您总是可以将数据从常量提取到种子文件中，而不会有任何问题。此外，即使这样也没有必要。如果你有一些永远不会改变的类别，和一些应该在管理面板中操作的类别，你甚至不应该播种以前的类别。您可以将它们保留在常量中，总是从那里读取它们，这样可以完全避免种子数据。其实是我的一个小秘密。我不喜欢种子数据。现在已经过去几年了，我们的应用程序可以在任何新开发人员的机器上开箱即用。如果你把我们的代码放入你的开发机器，应用程序就会运行。这就是为什么我说:当有疑问时，硬编码。

### 能否用数据库中的一个字符串求解？

比方说，在这一点上，应用程序工作得很好，并且您已经有了必要的数据库支持的模型。您需要显示一个自由格式的文本，该文本可能因实体而异(例如，每个产品都不同)，但它可能包含从其他地方插入的某些值。根据原则，你不应该考虑通过类来建模这个文本。首先，询问您是否可以简单地让 admin 将文本输入为字符串。但是等等，你会说。如果这个文本有从其他地方插入的值，为什么管理员要手工输入它们？她每次都要去查吗？好像不对。好吧，放松一点，考虑录音片段。没错，也许您可以简单地设置一个自由形式的文本字段，同时为 admin 提供一些预先编写的文本，其中已经插入了适当的值。当您认为需要结构化数据来存储高度灵活的东西时，可以考虑使用带有固定片段的普通字符串。

## 包装完毕

> "每一个复杂的问题都有一个清晰、简单而错误的答案."
> 
> <cite>H. L .门肯</cite>

虽然上面的文字是一个很好的通用原则，但它不能完全适用于显然需要类似 CMS 的解决方案的问题。当你的任务是构建一个高度灵活的 CMS 时，这是你应该做的。当你被要求用类似于 [Drupal](https://drupal.org) 的东西来构建一个应用程序时，你处于一个完全不同的领域，在那里 CMS 陷阱几乎是你永久存在的状态。然而，即使在那些特殊的情况下，问题也会出现，是否让一些东西更动态或更不动态，我鼓励每个开发人员总是倾向于静态。你不仅是在为未来的自己服务，也是在为下一个开发人员服务，他们宁愿分割一片静态的 html 并注入一些动态的内容，也不愿试图理解一大堆有许多活动部分的投机性架构。

同样重要的是要注意，我并不是完全反对预先架构。这在健康的程度上是好的，但是我们在个案的基础上在沙滩上画了一条线。我鼓励你在每次实现某件事情的时候，仔细考虑在哪里画这条线。

说到我的故事，它以长达一年的停滞和整个应用程序非常不情愿的修补而告终。最后，前面提到的“蓝图”已经降级为硬编码的类，并且随着时间的推移，由于自然进化的内部 DSL，它们变得非常具有声明性。今天看到这些文件，想象我将如何为所有移动部分实现运行时管理 UI 是一场噩梦。尽管它消耗了一年时间，我仍然很高兴我们咬紧牙关进行了重构。这是痛苦的，但现在这个错误已经远离我们了。

除非你很清楚自己在做什么(这不太可能)，否则就保持静止。试着付出额外的努力来决定你的业务的哪些部分可以硬编码。如果有疑问，请硬编码。在这样做的时候，确保你遵循最佳实践:永远不要把相同的条件放在两个地方，永远不要重复不变的数据，使用组合、依赖注入、继承，无论你需要什么来确保你遵守单一责任原则，并维护单一权威。

最重要的是，不要让自己纠结于过多的猜测，让故事自然展开。

在 [CC BY-SA 2.0](https://creativecommons.org/licenses/by-sa/2.0) 下使用/裁剪，添加阴影。↩ <sup>1</sup> ↩ <sup>2</sup> ↩ <sup>3</sup>